<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0051)http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm -->
<HTML><HEAD><TITLE></TITLE>
<META content="text/html; charset=ISO-8859-1" http-equiv=Content-Type>
<META content=text/css http-equiv=Content-Style-Type>
<META content="MSHTML 5.00.2614.3500" name=GENERATOR><LINK 
href="numdoc_files/numdoc.css" rel=STYLESHEET type=text/css 
CHARSET="ISO-8859-1"></HEAD>
<BODY bgColor=#ffffff>
<DIV>
<H1 class=TitleBook><A name=pgfId-90250></A>&nbsp;</H1></DIV>
<DIV>
<H1 class=TitleBook><A name=pgfId-93934></A>Numerical Python</H1>
<P class=AuthorBook><A name=pgfId-80697></A>David Ascher<BR>Paul F. 
Dubois<BR>Konrad Hinsen<BR>Jim Hugunin<BR>Travis Oliphant</P>
<P class=Body><A name=pgfId-139553></A>December 28, 2000</P>
<P class=PublisherBook><A name=pgfId-80713></A>Lawrence Livermore National 
Laboratory, Livermore, CA 94566</P>
<P class=PublisherBook><A name=pgfId-80714></A>UCRL-MA-128569</P>
<DIV>
<H4 class=Auspices><A name=pgfId-80758></A><A name=18807></A>Legal Notice</H4>
<P class=AuspicesText><A name=pgfId-80760></A>Copyright (c) 1999. The Regents of 
the University of California. All rights reserved. </P>
<P class=AuspicesText><A name=pgfId-80761></A>Permission to use, copy, modify, 
and distribute this software for any purpose without fee is hereby granted, 
provided that this entire notice is included in all copies of any software which 
is or includes a copy or modification of this software and in all copies of the 
supporting documentation for such software. </P>
<P class=AuspicesText><A name=pgfId-80762></A>This work was produced at the 
University of California, Lawrence Livermore National Laboratory under contract 
no. W-7405-ENG-48 between the U.S. Department of Energy and The Regents of the 
University of California for the operation of UC LLNL. </P>
<P class=AuspicesText><A name=pgfId-80755></A>This software was prepared as an 
account of work sponsored by an agency of the United States Government. Neither 
the United States Government nor the University of California nor any of their 
employees, makes any warranty, express or implied, or assumes any liability or 
responsibility for the accuracy, completeness, or usefulness of any information, 
apparatus, product, or process disclosed, or represents that its use would not 
infringe privately-owned rights. Reference herein to any specific commercial 
products, process, or service by trade name, trademark, manufacturer, or 
otherwise, does not necessarily constitute or imply its endorsement, 
recommendation, or favoring by the United States Government or the University of 
California. The views and opinions of authors expressed herein do not 
necessarily state or reflect those of the United States Government or the 
University of California, and shall not be used for advertising or product 
endorsement purposes.</P>
<P class=AuspicesText><A name=pgfId-90256></A>&nbsp;</P>
<P class=AuspicesText><A name=pgfId-80754></A>&nbsp;</P></DIV>
<DIV>
<H3 class=TocTitle><A name=pgfId-688118></A>Table Of Contents</H3>
<DIV>
<H4 class=ChapterSetTOC><A name=pgfId-695194></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59427">Numerical 
Python 1</A></H4>
<P class=ChapterTOC><A name=pgfId-695196></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-78440">Introduction 
2</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695198></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67465">Where to 
get information and code 3</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695200></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67319">Acknowledgments 
4</A></P>
<P class=ChapterTOC><A name=pgfId-695202></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35559">Installing 
NumPy 5</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695204></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-37275">Testing 
the Python installation 5</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695206></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-37281">Testing 
the Numeric Python Extension Installation 5</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695208></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-54827">Installing 
NumPy 5</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695210></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-68233">At the 
SourceForge... 6</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695212></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-68521">The 
Numeric Discussion List 6</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695214></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-68511">Bugs and 
Patches 6</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695216></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-68543">CVS 
Repository 6</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695218></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-68534">FTP Site 
7</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695220></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-68539">Pyfort 
7</A></P>
<P class=ChapterTOC><A name=pgfId-695222></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-37261">The 
NumTut package 8</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695224></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35585">Testing 
the NumTut package 8</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695226></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-56796">Possible 
reasons for failure: 8</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695228></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-57000">Win32 
8</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695230></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-56857">Unix 
9</A></P>
<P class=ChapterTOC><A name=pgfId-695232></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-57136">High-Level 
Overview 10</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695234></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-57154">Array 
Objects 10</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695236></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-57178">Universal 
Functions 11</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695238></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-60952">Convenience 
Functions 11</A></P>
<P class=ChapterTOC><A name=pgfId-695240></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-57315">Array 
Basics 13</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695242></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-37311">Basics 
13</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695244></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35605">Creating 
arrays from scratch 14</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695246></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35606">array() 
and typecodes 14</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695248></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35637">Multidimensional 
Arrays 15</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695250></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-68290">resize 
18</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695252></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-60291">Creating 
arrays with values specified `on-the-fly' 18</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695254></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-60120">zeros() 
and ones() 18</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695256></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35764">arrayrange() 
19</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695258></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35809">Creating 
an array from a function: fromfunction() 20</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695260></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59602">identity() 
21</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695262></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35852">Coercion 
and Casting 22</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695264></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35854">Automatic 
Coercions and Binary Operations 22</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695266></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35864">Deliberate 
up-casting: The asarray function 22</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695268></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35867">The 
typecode value table 23</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695270></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35950">Consequences 
of silent upcasting 23</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695272></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-68241">Saving 
space 24</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695274></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35975">Deliberate 
casts (potentially down): the astype method 24</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695276></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35984">Operating 
on Arrays 24</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695278></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-35985">Simple 
operations 24</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695280></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36033">Getting 
and Setting array values 25</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695282></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36074">Slicing 
Arrays 26</A></P>
<P class=ChapterTOC><A name=pgfId-695284></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36126">Ufuncs 
29</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695286></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36127">What are 
Ufuncs? 29</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695288></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36229">Ufuncs 
can operate on any Python sequence 30</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695290></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36233">Ufuncs 
can take output arguments 30</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695292></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36249">Ufuncs 
have special methods 30</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695294></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36250">The 
reduce ufunc method 30</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695296></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-61704">The 
accumulate ufunc method 31</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695298></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-61715">The outer 
ufunc method 31</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695300></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-61737">The 
reduceat ufunc method 32</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695302></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-61739">Ufuncs 
always return new arrays 32</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695304></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36300">Which are 
the Ufuncs? 32</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695306></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36302">Unary 
Mathematical Ufuncs (take only one argument) 32</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695308></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36313">Binary 
Mathematical Ufuncs 32</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695310></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36315">Logical 
Ufuncs 32</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695312></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36357">Ufunc 
shorthands 33</A></P>
<P class=ChapterTOC><A name=pgfId-695314></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36371">Pseudo 
Indices 35</A></P>
<P class=ChapterTOC><A name=pgfId-695316></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36422">Array 
Functions 37</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695318></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36425">take(a, 
indices, axis=0) 37</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695320></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-78510">put (a, 
indices, values) 38</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695322></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-84177">putmask 
(a, mask, values) 39</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695324></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36476">transpose(a, 
axes=None) 39</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695326></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36494">repeat(a, 
repeats, axis=0) 39</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695328></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36498">choose(a, 
(b0, ..., bn)) 40</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695330></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36512">ravel(a) 
40</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695332></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58067">nonzero(a) 
40</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695334></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36518">where(condition, 
x, y) 40</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695336></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36520">compress(condition, 
a, axis=0) 40</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695338></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58163">diagonal(a, 
k=0) 41</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695340></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36523">trace(a, 
k=0) 41</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695342></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36532">searchsorted(a, 
values) 41</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695344></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66636">sort(a, 
axis=-1) 42</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695346></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-65841">argsort(a, 
axis=-1) 42</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695348></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66027">argmax(a, 
axis=-1), argmin(a, axis=-1) 42</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695350></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36538">fromstring(string, 
typecode) 43</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695352></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36540">dot(m1, 
m2) 43</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695354></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36542">matrixmultiply(m1, 
m2) 43</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695356></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36545">clip(m, 
m_min, m_max) 43</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695358></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66267">indices(shape, 
typecode=None) 43</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695360></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58407">swapaxes(a, 
axis1, axis2) 44</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695362></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58428">concatenate((a0, 
a1, ... , an), axis=0) 44</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695364></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58474">innerproduct(a, 
b) 45</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695366></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-84301">outerproduct(a,b) 
45</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695368></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-84308">array_repr() 
45</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695370></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58479">array_str() 
45</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695372></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58481">resize(a, 
new_shape) 45</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695374></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58514">diagonal(a, 
offset=0, axis1=-2, axis2=-1) 46</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695376></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58523">repeat 
(a, counts, axis=0) 46</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695378></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67914">convolve 
(a, v, mode=0) 46</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695380></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67917">cross_correlate 
(a, v, mode=0) 47</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695382></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67907">where 
(condition, x, y) 47</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695384></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58536">identity(n) 
47</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695386></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58544">sum(a, 
index=0) 47</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695388></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58556">cumsum(a, 
index=0) 47</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695390></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58558">product(a, 
index=0) 47</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695392></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58560">cumproduct(a, 
index=0) 47</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695394></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58562">alltrue(a, 
index=0) 47</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695396></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-58564">sometrue(a, 
index=0) 48</A></P>
<P class=ChapterTOC><A name=pgfId-695398></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36552">Array 
Methods 49</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695400></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36554">itemsize() 
49</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695402></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36565">iscontiguous() 
49</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695404></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36568">typecode() 
49</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695406></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36576">byteswapped() 
49</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695408></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36582">tostring() 
49</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695410></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36588">tolist() 
50</A></P>
<P class=ChapterTOC><A name=pgfId-695412></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36604">Array 
Attributes 51</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695414></A><EM class=Emphasis><A 
class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36606">flat 
51</A></EM> </P>
<P class=FM1HeadingTOC><A name=pgfId-695416></A><EM class=Emphasis><A 
class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36629">real</A></EM> 
and <EM class=Emphasis>imaginary 51</EM> </P>
<P class=ChapterTOC><A name=pgfId-695418></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59071">Special 
Topics 53</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695420></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67984">Subclassing 
53</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695422></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67992">Code 
Organization 53</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695424></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66725">Numeric.py 
and friends 53</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695426></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66711">UserArray.py 
53</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695428></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66719">Matrix.py 
53</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695430></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66783">Precision.py 
53</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695432></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66787">ArrayPrinter.py 
53</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695434></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66808">Mlab.py 
53</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695436></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66920">bartlett(M) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695438></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66922">blackman(M) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695440></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66924">corrcoef(x, 
y=None) 54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695442></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66926">cov(m,y=None) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695444></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66928">cumprod(m) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695446></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66930">cumsum(m) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695448></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66932">diag(v, 
k=0) 54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695450></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66934">diff(x, 
n=1) 54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695452></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66936">eig(m) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695454></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66938">eye(N, 
M=N, k=0, typecode=None) 54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695456></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66940">fliplr(m) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695458></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66942">flipud(m) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695460></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66944">hamming(M) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695462></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66946">hanning(M) 
54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695464></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66948">kaiser(M, 
beta) 54</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695466></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66950">max(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695468></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67179">mean(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695470></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66954">median(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695472></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66956">min(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695474></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66958">msort(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695476></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66960">prod(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695478></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66962">ptp(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695480></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66964">rand(d1, 
..., dn) 55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695482></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67153">rot90(m,k=1) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695484></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67155">sinc(x) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695486></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66970">squeeze(a) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695488></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66972">std(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695490></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66974">sum(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695492></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66976">svd(m) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695494></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66978">trapz(y,x=None) 
55</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695496></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66980">tri(N, 
M=N, k=0, typecode=None) 56</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695498></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66982">tril(m,k=0) 
56</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695500></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66984">triu(m,k=0) 
56</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695502></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-66811">The 
multiarray object 56</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695504></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59085">Typecodes 
56</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695506></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59290">Indexing 
in and out, slicing 57</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695508></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59320">Ellipses 
58</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695510></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59324">NewAxis 
58</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695512></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59327">Set-indexing 
and Broadcasting 59</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695514></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59331">Axis 
specifications 59</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695516></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59333">Textual 
representations of arrays 59</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695518></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59418">Comparisons 
61</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695520></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-67223">Pickling 
and Unpickling -- storing arrays on disk 61</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695522></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59422">Dealing 
with floating point exceptions 62</A></P>
<P class=ChapterTOC><A name=pgfId-695524></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36640">Writing a 
C extension to NumPy 63</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695526></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36641">Introduction 
63</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695528></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36646">Preparing 
an extension module for NumPy arrays 63</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695530></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36649">Accessing 
NumPy arrays from C 64</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695532></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36650">Types and 
Internal Structure 64</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695534></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36661">Element 
data types 64</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695536></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36717">Contiguous 
arrays 65</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695538></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36719">Zero-dimensional 
arrays 65</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695540></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36721">A simple 
example 65</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695542></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36748">Accepting 
input data from any sequence type 66</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695544></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36783">Creating 
NumPy arrays 67</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695546></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36796">Returning 
arrays from C functions 67</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695548></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-36801">A less 
simple example 68</A></P>
<P class=ChapterTOC><A name=pgfId-695550></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-57398">C API 
Reference 70</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695552></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-25107">ArrayObject 
C Structure and API 70</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695554></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-57404">Structures 
70</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695556></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-34282">The 
ArrayObject API 71</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695558></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-586">Notes 
74</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695560></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-587">UfuncObject 
C Structure and API 74</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695562></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-589">C Structure 
74</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695564></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-590">UfuncObject 
C API 76</A></P>
<P class=ChapterTOC><A name=pgfId-695566></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-57323">Glossary 
79</A></P></DIV>
<DIV>
<H4 class=ChapterSetTOC><A name=pgfId-695568></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304408">Optional 
Packages 81</A></H4>
<P class=FM1HeadingTOC><A name=pgfId-695570></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304744">License 
and disclaimer for packages MA and RNG 82</A></P>
<P class=ChapterTOC><A name=pgfId-695572></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304711">FFT 
Reference 83</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695574></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-302955">Python 
Interface 83</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695576></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-302958">fft(data, 
n=None, axis=-1) 83</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695578></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-302970">inverse_fft(data, 
n=None, axis=-1) 83</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695580></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-302973">real_fft(data, 
n=None, axis=-1) 83</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695582></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-302986">inverse_real_fft(data, 
n=None, axis=-1) 84</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695584></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-302988">fft2d(data, 
s=None, axes=(-2,-1)) 84</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695586></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-302990">real_fft2d(data, 
s=None, axes=(-2,-1)) 84</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695588></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-302992">C API 
84</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695590></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303012">Compilation 
Notes 85</A></P>
<P class=ChapterTOC><A name=pgfId-695592></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303015">LinearAlgebra 
Reference 86</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695594></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303017">Python 
Interface 86</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695596></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303019">solve_linear_equations(a, 
b) 86</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695598></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303023">inverse(a) 
86</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695600></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303047">eigenvalues(a) 
86</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695602></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303058">eigenvectors(a) 
87</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695604></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303076">singular_value_decomposition(a, 
full_matrices=0) 87</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695606></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303079">generalized_inverse(a, 
rcond=1e-10) 87</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695608></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303082">determinant(a) 
87</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695610></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303085">linear_least_squares(a, 
b, rcond=e-10) 87</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695612></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303088">Compilation 
Notes 87</A></P>
<P class=ChapterTOC><A name=pgfId-695614></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303091">RandomArray 
Reference 88</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695616></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303094">Python 
Interface 88</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695618></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303096">seed(x=0, 
y=0) 88</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695620></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303099">get_seed() 
88</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695622></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303102">random(shape=</A><EM 
class=Emphasis> ReturnFloat</EM> ) 88</P>
<P class=FM2HeadingTOC><A name=pgfId-695624></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303105">uniform(minimum, 
maximum, shape=ReturnFloat) 88</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695626></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303108">randint(minimum, 
maximum, shape=ReturnFloat) 88</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695628></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303111">permutation(n) 
88</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695630></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305397">Floating 
point random arrays 89</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695632></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305398">standard_normal 
(shape=ReturnFloat) 89</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695634></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305400">normal 
(mean, stddev, shape=ReturnFloat) 89</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695636></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305402">multivariate_normal 
(mean, covariance) or <BR>multivariate_normal (mean, covariance, 
leadingAxesShape) 89</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695638></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305407">exponential 
(mean, shape=ReturnFloat) 89</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695640></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305409">beta (a, 
b, shape=ReturnFloat) 89</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695642></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305411">gamma 
(a, r, shape=ReturnFloat) 90</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695644></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305413">chi_square 
(df, shape=ReturnFloat) 90</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695646></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305415">noncentral_chi_square 
(df, nonc, shape=ReturnFloat) 90</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695648></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305417">F (dfn, 
dfd, shape=ReturnFloat) 90</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695650></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305419">noncentral_F 
(dfn, dfd, nconc, shape=ReturnFloat) 90</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695652></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305421">Integer 
random arrays 90</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695654></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305422">binomial 
(trials, prob, shape=ReturnInt) 90</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695656></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305424">negative_binomial 
(trials, prob, shape=ReturnInt) 90</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695658></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305426">poisson 
(mean, shape=ReturnInt) 90</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695660></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305428">multinomial 
(trials, probs) or multinomial (trials, probs, leadingAxesShape) 90</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695662></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305431">Examples 
91</A></P>
<P class=ChapterTOC><A name=pgfId-695664></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-290702">Independent 
Random Streams 93</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695666></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304780">Background 
93</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695668></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304419">Usage 
93</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695670></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304559">Module 
RNG 93</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695672></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304635">Generator 
objects 93</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695674></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304493">Module 
ranf 94</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695676></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304426">Examples 
94</A></P>
<P class=ChapterTOC><A name=pgfId-695678></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-303698">Masked 
Arrays 95</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695680></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-296294">What is 
a masked array? 95</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695682></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304772">Installing 
and using MA 95</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695684></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-296950">Class MA 
96</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695686></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305213">Attributes 
of masked arrays 96</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695688></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305217">Methods 
on masked arrays. 96</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695690></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-298181">Constructing 
masked arrays 98</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695692></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304244">The 
filled function 98</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695694></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304372">Working 
with Masks 99</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695696></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305173">Copying 
or not? 100</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695698></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305435">Behaviors 
100</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695700></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304210">Indexing 
and Slicing 100</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695702></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306592">Indexing 
that produces a scalar result 100</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695704></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304229">Assignment 
to elements and slices 100</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695706></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-297249">Module 
MA: Attributes 101</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695708></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305706">Module 
MA: Functions 101</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695710></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-298306">Unary 
functions 101</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695712></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-298312">Binary 
functions 101</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695714></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-298340">Comparison 
operators 101</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695716></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-298353">Logical 
operators 101</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695718></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-298365">Special 
array operators 102</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695720></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305726">Controlling 
the size of the string representations 103</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695722></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-304172">Helper 
classes 104</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695724></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306892">MAError 
104</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695726></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306894">The 
constant masked 104</A></P>
<P class=FM3HeadingTOC><A name=pgfId-695728></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306903">Example 
of masked behavior 104</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695730></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305737">Class 
masked_unary_function 104</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695732></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-305759">Class 
masked_binary_function 105</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695734></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306950">ActiveAttributes 
105</A></P>
<P class=FM1HeadingTOC><A name=pgfId-695736></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306123">Examples 
of Using MA 106</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695738></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306127">Data 
with a given value representing missing data 106</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695740></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306145">Filling 
in the missing data 106</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695742></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306378">Numerical 
operations 106</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695744></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306406">Seeing 
the mask 106</A></P>
<P class=FM2HeadingTOC><A name=pgfId-695746></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-306428">Filling 
it your way 107</A></P></DIV>
<DIV>
<H4 class=IndexTitleTOC><A name=pgfId-695748></A><A class=Index 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-862972">Index 
109</A></H4></DIV></DIV>
<DIV>
<H2 class=ChapterSet><A name=pgfId-59427></A>
<DIV><IMG src="numdoc_files/numdoc-1.gif"> </DIV>Part I: <A 
name=92764></A>Numerical Python
<DIV><IMG src="numdoc_files/numdoc-2.gif"> </DIV></H2>
<P class=ChapterDescription><A name=pgfId-78485></A>Numerical Python ("Numpy") 
adds a fast multidimensional array facility to Python. This part contains all 
you need to know about "Numpy" arrays and the functions that operate upon 
them.</P></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-78440></A>1. Introduction</H2>
<P class=ChapterDescription><A name=pgfId-37405></A>This chapter introduces the 
Numeric Python extension and outlines the rest of the document.</P>
<P class=Body><A name=pgfId-35556></A>The Numeric Python extensions (NumPy 
henceforth) is a set of extensions to the Python programming language which 
allows Python programmers to efficiently manipulate large sets of objects 
organized in grid-like fashion. These sets of objects are called arrays, and 
they can have any number of dimensions: one dimensional arrays are similar to 
standard Python sequences, two-dimensional arrays are similar to matrices from 
linear algebra. Note that one-dimensional arrays are also different from any 
other Python sequence, and that two-dimensional matrices are also different from 
the matrices of linear algebra, in ways which we will mention later in this 
text.</P>
<P class=Body><A name=pgfId-35557></A>Why are these extensions needed? The core 
reason is a very prosaic one, and that is that manipulating a set of a million 
numbers in Python with the standard data structures such as lists, tuples or 
classes is much too slow and uses too much space. Anything which we can do in 
NumPy we can do in standard Python - we just may not be alive to see the program 
finish. A more subtle reason for these extensions however is that the kinds of 
operations that programmers typically want to do on arrays, while sometimes very 
complex, can often be decomposed into a set of fairly standard operations. This 
decomposition has been developed similarly in many array languages. In some 
ways, NumPy is simply the application of this experience to the Python language 
- thus many of the operations described in NumPy work the way they do because 
experience has shown that way to be a good one, in a variety of contexts. The 
languages which were used to guide the development of NumPy include the infamous 
APL family of languages, Basis, MATLAB, FORTRAN, S and S+, and others. This 
heritage will be obvious to users of NumPy who already have experience with 
these other languages. This tutorial, however, does not assume any such 
background, and all that is expected of the reader is a reasonable working 
knowledge of the standard Python language.</P>
<P class=Body><A name=pgfId-35558></A>This document is the "official" 
documentation for NumPy. It is both a tutorial and the most authoritative source 
of information about NumPy with the exception of the source code. The tutorial 
material will walk you through a set of manipulations of simple, small, arrays 
of numbers, as well as image files. This choice was made because: </P>
<UL>
  <LI class=Bullet><A name=pgfId-67348></A>A concrete data set makes explaining 
  the behavior of some functions much easier to motivate than simply talking 
  about abstract operations on abstract data sets; 
  <LI class=Bullet><A name=pgfId-67349></A>Every reader will have at least an 
  intuition as to the meaning of the data and organization of image files, and 
  <LI class=Bullet><A name=pgfId-67350></A>The result of various manipulations 
  can be displayed simply since the data set has a natural graphical 
  representation. </LI></UL>
<P class=Body><A name=pgfId-67351></A>All users of NumPy, whether interested in 
image processing or not, are encouraged to follow the tutorial with a working 
NumPy installation at their side, testing the examples, and, more importantly, 
transferring the understanding gained by working on images to their specific 
domain. The best way to learn is by doing - the aim of this tutorial is to guide 
you along this "doing."</P>
<P class=Body><A name=pgfId-67367></A>Here is what the rest of this part 
contains:</P>
<P class=KeepTogetherList><A name=pgfId-67265></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#71535">Installing 
NumPy</A> provides information on testing Python, NumPy, and compiling and 
installing NumPy if necessary.</P>
<P class=KeepTogetherList><A name=pgfId-67266></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#35986">The NumTut 
package</A> provides information on testing and installing the NumTut package, 
which allows easy visualization of arrays.</P>
<P class=KeepTogetherList><A name=pgfId-67267></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#70766">High-Level 
Overview</A> gives a high-level overview of the components of the NumPy system 
as a whole.</P>
<P class=KeepTogetherList><A name=pgfId-67268></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#82200">Array 
Basics</A> provides a detailed step-by-step introduction to the most important 
aspect of NumPy, the multidimensional array objects.</P>
<P class=KeepTogetherList><A name=pgfId-67269></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#30906">Ufuncs</A> 
provides information on universal functions, the mathematical functions which 
operate on arrays and other sequences elementwise.</P>
<P class=KeepTogetherList><A name=pgfId-67270></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#21398">Pseudo 
Indices</A> covers syntax for some special indexing operators.</P>
<P class=KeepTogetherList><A name=pgfId-67271></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#28351">Array 
Functions</A> is a catalog of each of the utility functions which allow easy 
algorithmic processing of arrays.</P>
<P class=KeepTogetherList><A name=pgfId-67272></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#42194">Array 
Methods</A> discusses the methods of array objects.</P>
<P class=KeepTogetherList><A name=pgfId-67273></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#86746">Array 
Attributes</A> presents the attributes of array objects.</P>
<P class=KeepTogetherList><A name=pgfId-67274></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#92607">Special 
Topics</A> is a collection of special topics, from the organization of the 
codebase to the mechanisms for customizing printing.</P>
<P class=KeepTogetherList><A name=pgfId-67275></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#69650">Writing a C 
extension to NumPy</A> is an tutorial on how to write a C extension which uses 
NumPy arrays.</P>
<P class=KeepTogetherList><A name=pgfId-67276></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#36241">C API 
Reference</A> is a reference for the C API to NumPy objects (both PyArrayObjects 
and UFuncObjects).</P>
<P class=KeepTogetherList><A name=pgfId-67292></A><A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#92539">Glossary</A> is 
a glossary of terms.</P>
<P class=KeepTogetherList><A name=pgfId-78480></A>Reference material for the 
optional packages distributed with Numeric Python are described in the next 
part, <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#90799">Optional 
Packages</A>.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-67465></A><A name=18177></A>Where to get 
information and code</H6>
<P class=FirstBody><A name=pgfId-67469></A>Numerical Python and its 
documentation are available at SourceForge. The main web site is:</P>
<P class=Body><A name=pgfId-68053></A>http://numpy.sourceforge.net</P>
<P class=Body><A name=pgfId-68060></A>Downloads, bug reports, and patch 
facility, and releases are at the main project page, reachable from the above 
site or directly at: http://sourceforge.net/projects/numpy</P>
<P class=Body><A name=pgfId-67489></A>The Python web site is www.python.org</P>
<P class=Body><A name=pgfId-84341></A>Many packages are available from third 
parties that use Numeric to interface to a variety of mathematical and 
statistical software. </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-67319></A>Acknowledgments</H6>
<P class=FirstBody><A name=pgfId-67323></A>Numerical Python is the outgrowth of 
a long collaborative design process carried out by the Matrix SIG of the Python 
Software Activity (PSA). Jim Hugunin, while a graduate student at MIT, wrote 
most of the code and initial documentation. When Jim joined CNRI and began 
working on JPython, he didn't have the time to maintain Numerical Python so Paul 
Dubois at LLNL agreed to become the maintainer of Numerical Python. David 
Ascher, working as a consultant to LLNL, wrote most of this document, 
incorporating contributions from Konrad Hinsen and Travis Oliphant, both of whom 
are major contributors to Numerical Python. </P>
<P class=Body><A name=pgfId-84342></A>Since the source was moved to SourceForge, 
the Numeric user community has become a significant part of the process. 
Numerical Python illustrates the power of the open source software concept. </P>
<P class=Body><A name=pgfId-84350></A>Please send comments and corrections to 
this manual to paul@pfdubois.com, or to Paul F. Dubois, L-264, Lawrence 
Livermore National Laboratory, Livermore, CA 94566, U.S.A.</P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-35559></A>2. <A name=71535></A>Installing 
NumPy</H2>
<P class=ChapterDescription><A name=pgfId-37406></A>This chapter explains how to 
install and test NumPy, from either the source distribution or from the binary 
distribution.</P>
<P class=FirstBody><A name=pgfId-37274></A>Before we start with the actual 
tutorial, we will describe the steps needed for you to be able to follow along 
the examples step by step. These steps including installing Python, the NumPy 
extensions, and some tools and sample files used in the examples of this 
tutorial.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-37275></A>Testing the Python 
installation</H6>
<P class=FirstBody><A name=pgfId-37276></A>The first step is to install Python 
if you haven't already. Python is available from the Python website's download 
directory at <EM class=URL>http://www.python.org/download</EM> . Click on the 
link corresponding to your platform, and follow the instructions described 
there. When installed, starting Python by typing <EM class=Code>python</EM> at 
the shell or double-clicking on the Python interpreter should give a prompt such 
as:</P>
<P class=Python><A name=pgfId-37277></A>Python 1.5.1 (#0, Apr 13 1998, 20:22:04) 
[MSC 32 bit (Intel)] on win32</P>
<P class=Python><A name=pgfId-37278></A>Copyright 1991-1995 Stichting 
Mathematisch Centrum, Amsterdam</P>
<P class=Python><A name=pgfId-37279></A>&gt;&gt;&gt;</P>
<P class=Body><A name=pgfId-37280></A>If you have problems getting this part to 
work, consider contacting a local support person or emailing <EM 
class=URL>python-help@python.org</EM> for help. If neither solution works, 
consider posting on the comp.lang.python newsgroup (details on the 
newsgroup/mailing list are available at <EM 
class=URL>http://www.python.org/psa/MailingLists.html#clp</EM> ).</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-37281></A>Testing the Numeric Python 
Extension Installation</H6>
<P class=FirstBody><A name=pgfId-37282></A>The standard Python distribution does 
not come as of this writing with the Numeric Python extensions installed, but 
your system administrator may have installed them already. To find out if your 
Python interpreter has NumPy installed, type <EM class=Code>import</EM> <EM 
class=Code>Numeric</EM> at the Python prompt. You'll see one of two behaviors 
(throughout this document, <EM class=CodeInput>bold</EM> <EM 
class=CodeInput>Courier New</EM> font indicates user input, and <EM 
class=Code>standard</EM> <EM class=Code>Courier New</EM> font indicates 
output):</P>
<P class=Python><A name=pgfId-37283></A>&gt;&gt;&gt; <EM class=CodeInput>import 
Numeric</EM> </P>
<P class=Python><A name=pgfId-37284></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-37285></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-37286></A>ImportError: No module named Numeric</P>
<P class=Python><A name=pgfId-37287></A>&gt;&gt;&gt;</P>
<P class=Body><A name=pgfId-37288></A>indicating that you don't have NumPy 
installed, or:</P>
<P class=Python><A name=pgfId-37289></A>&gt;&gt;&gt; <EM class=CodeInput>import 
Numeric</EM> </P>
<P class=Python><A name=pgfId-37290></A>&gt;&gt;&gt; </P>
<P class=Body><A name=pgfId-37291></A>indicating that you do. If you do, go on 
to the next step. If you don't, you have to get the NumPy extensions. </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-54827></A><A name=marker-59513></A>Installing 
NumPy</H6>
<P class=FirstBody><A name=pgfId-68084></A>The release facility at SourceForge 
is accessed through the project page, http://sourceforge.net/projects/numpy. 
Click on the "numpy" releases and you will be presented with a list of the 
available files. The files whose names end in ".tar.gz" are source code 
releases. The others are "prebuilt" for a given platform. </P>
<P class=Body><A name=pgfId-78642></A>On Windows, we currently have .zip files 
that should be unzipped into the top of your Python distribution; there is no 
"Setup" to run. </P>
<P class=Body><A name=pgfId-78643></A>In general, there may not be a prebuilt 
version of a particular kind available in every minor release. If you need a 
prebuilt version, choose the most recent version available. </P>
<P class=Body><A name=pgfId-59525></A><A name=marker-59524></A>The source 
distribution should be uncompressed and unpacked using the the tar program:</P>
<P class=Python><A name=pgfId-57128></A>csh&gt; tar xfz Numeric-n.m.tar.gz</P>
<P class=Body><A name=pgfId-57132></A>Follow the instructions in the top-level 
directory for compilation and installation. Note that there are ptions you must 
consider before beginning.</P>
<UL>
  <LI class=Bullet><A name=pgfId-68107></A>Read the README file. With many 
  software distributions, this is an optional step. It isn't for Numeric Python. 
  Your build won't work unless you make a decision about LAPACK and the BLAS. 
  <LI class=Bullet><A name=pgfId-68111></A>Subdirectory Packages contains some 
  optional packages you may wish to install. The Makefile in the top-level 
  directory can be used to do this after you have completed the main 
  installation. These packages are described in <A class=XRef 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#90799">Optional 
  Packages</A>. </LI></UL>
<P class=Body><A name=pgfId-68613></A>Once your lapack_lite decision is made and 
the library built if necessary, installation is usually as simple as:</P>
<P class=Python><A name=pgfId-68617></A>python setup.py install</P>
<P class=Body><A name=pgfId-68624></A>However, please (please!) see the README 
itself for the latest details.</P>
<DIV>
<H6 class=NoteTip><A name=pgfId-67455></A>
<DIV><IMG src="numdoc_files/numdoc-3.gif"> </DIV>&nbsp;</H6>
<P class=Note><A name=pgfId-67445></A><A 
name="from Numeric import * explanation"></A>Just like all Python modules and 
packages, the Numeric module can be invoked using either the <EM 
class=Code>import Numeric</EM> form, or the <EM class=Code>from Numeric import 
...</EM> form. Because most of the functions we'll talk about are in the Numeric 
module, in this document, all of the code samples will assume that they have 
been preceded by a statement: </P>
<P class=PythonNote><A name=pgfId-67314></A><EM class=CodeInput>from Numeric 
import *</EM> </P>
<P class=PythonNote><A name=pgfId-68210></A>
<DIV><IMG src="numdoc_files/numdoc-4.gif"> </DIV>&nbsp;
<P></P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-68233></A>At the SourceForge...</H6>
<P class=FirstBody><A name=pgfId-68540></A>The <A 
name=marker-68558></A>SourceForge facility is at 
http://sourceforge.net/projects/numpy. Look on SourceForge also for various 
Numeric-based packages supplied by individuals.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-68521></A>The Numeric <A 
name=marker-68556></A>Discussion List</H6>
<P class=FirstBody><A name=pgfId-68237></A>You can subscribe to a discussion 
list about Numeric python using the project page at SourceForge. The list is a 
good place to ask questions and get help. Send mail to 
numpy-discussion@lists.sourceforge.net.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-68511></A><A name=marker-68554></A>Bugs and 
<A name=marker-68555></A>Patches</H6>
<P class=Body><A name=pgfId-68512></A>Bug tracking and patch-management 
facilities is provided on the SourceForge project page.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-68543></A><A name=marker-68553></A>CVS 
Repository</H6>
<P class=Body><A name=pgfId-68530></A>You can get the latest and greatest 
(albeit less tested and trustworthy) version of Numeric directly from our CVS 
repository.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-68534></A><A name=marker-68557></A>FTP 
Site</H6>
<P class=Body><A name=pgfId-68535></A>The FTP Site contains this documentation 
in several formats, plus maybe some other goodies we have lying 
around.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-68539></A><A 
name=marker-68559></A>Pyfort</H6>
<P class=FirstBody><A name=pgfId-68550></A>One tool for connecting Fortran to 
Numeric and Python is Pyfort, sourceforge.net/projects/pyfortran. 
</P></DIV></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-37261></A>3. <A name=35986></A>The <A 
name=marker-59530></A>NumTut package</H2>
<P class=ChapterDescription><A name=pgfId-67256></A>This chapter leads the user 
through the installation and testing of the NumTut package, which should have 
been distributed with this document.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-35585></A>Testing the NumTut package</H6>
<P class=Body><A name=pgfId-67257></A>This tutorial assumes that the NumTut 
package has been installed. This package contains a few sample images and 
utility functions for displaying arrays and the like. To find out if NumTut has 
been installed, do:</P>
<P class=Python><A name=pgfId-35586></A>&gt;&gt;&gt; <EM class=CodeInput>from 
NumTut import *</EM> </P>
<P class=Python><A name=pgfId-35587></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(greece)</EM> <A name=marker-59535></A><A 
name=marker-59531></A></P>
<P class=Python><A name=pgfId-56844></A>&nbsp;</P>
<DIV><IMG src="numdoc_files/numdoc-5.gif"> </DIV>
<P class=Body><A name=pgfId-35588></A>If a picture of a greek street shows up on 
your screen, you're all set, and you can go to the next chapter.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-56796></A>Possible reasons for failure:</H6>
<P class=Python><A name=pgfId-56961></A>&gt;&gt;&gt; <EM class=CodeInput>import 
NumTut</EM> </P>
<P class=Python><A name=pgfId-56970></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-56971></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-56967></A>ImportError: No module named NumTut</P>
<P class=Body><A name=pgfId-56966></A>This message indicates that you do not 
have the NumTut package installed in your PythonPath. NumTut is distributed 
along with the Python source in the Demo subdirectory. Copy the NumTut 
subdirectory somewhere into your Python path, or just execute python from the 
Demo directory. </P>
<P class=Body><A name=pgfId-68566></A>On Win32, the NumTut directory can be 
placed in the main directory of your Python installation. On Unix, it can be 
placed in the site-packages directory of your installation.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-57000></A>Win32</H6>
<P class=Python><A name=pgfId-57005></A>&gt;&gt;&gt; <EM class=CodeInput>import 
NumTut</EM> </P>
<P class=Python><A name=pgfId-57006></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-57007></A>[...]</P>
<P class=Python><A name=pgfId-57008></A>ConfigurationError: view needs Tkinter 
on Win32, and either threads or the IDLE editor"</P>
<P class=Body><A name=pgfId-57019></A>or:</P>
<P class=Python><A name=pgfId-57028></A>ConfigurationError: view needs either 
threads or the IDLE editor to be enabled.</P>
<P class=Body><A name=pgfId-56880></A>On Win32 (Windows 95, 98, NT), the <A 
name=marker-59532></A>Tk toolkit is needed to view the images. Additionally, 
either the Python interpreter needs to be compiled with <A 
name=marker-59533></A>thread support (which is true in the standard win32 
distribution) or you need to call the NumTut program from the <A 
name=marker-59534></A>IDLE interactive development environment.</P>
<P class=Body><A name=pgfId-57100></A>If you do not wish to modify your Python 
installation to match these requirements, you can simply ignore the references 
to the demonstrations which use the <EM class=Code>view()</EM> command later in 
this document. Using NumPy does not require image display tools, they just make 
some array operations easier to understand.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-56857></A>Unix</H6>
<P class=Body><A name=pgfId-56884></A>On Unix machines, NumTut will work best 
with a Python interpreter with Tk support (not true in the default 
configuration), with the Tkinter GUI framework available and optionally with the 
tkImaging add-on (part of the Python Imaging Library). If this is not the case, 
it will try to use an external viewer which is able to read PPM files. The 
default viewer is 'xv', a common image viewer available from <EM 
class=URL>ftp://ftp.cis.upenn.edu/pub/xv. </EM>If xv is not installed, you will 
get an error message similar to:</P>
<P class=Python><A name=pgfId-57062></A>&gt;&gt;&gt; <EM class=CodeInput>import 
NumTut</EM> </P>
<P class=Python><A name=pgfId-57063></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-57064></A>[...]</P>
<P class=Python><A name=pgfId-57065></A>ConfigurationError: PPM image viewer 
'xv' not found</P>
<P class=Body><A name=pgfId-57057></A>You can configure NumTut to use a 
different image viewer, by typing e.g.:</P>
<P class=Python><A name=pgfId-56923></A>&gt;&gt;&gt; <EM class=CodeInput>import 
NumTut</EM> </P>
<P class=Python><A name=pgfId-56927></A>&gt;&gt;&gt; <EM 
class=CodeInput>NumTut.view.PPMVIEWER = 'ppmviewer'</EM> </P>
<P class=Python><A name=pgfId-56943></A>&gt;&gt;&gt; <EM class=CodeInput>from 
NumTut import *</EM> </P>
<P class=Python><A name=pgfId-56947></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(greece)</EM> </P>
<P class=Body><A name=pgfId-57089></A>If you do not have a PPM image viewer, you 
can simply ignore the references to the demonstrations which use the <EM 
class=Code>view()</EM> command later in this document. Using NumPy does not 
require image display tools, they just make some array operations easier to 
understand.</P></DIV></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-57136></A>4. <A name=70766></A>High-Level 
Overview</H2>
<P class=ChapterDescription><A name=pgfId-57137></A>In this chapter, a 
high-level overview of the extensions is provided, giving the reader the 
definitions of the key components of the system. This section defines the 
concepts used by the remaining sections.</P>
<P class=Body><A name=pgfId-57138></A>Numeric Python consists of a set of 
modules:</P>
<UL>
  <LI class=Bullet><A name=pgfId-57145></A><EM class=Code>Numeric.py</EM> <A 
  name=marker-59536></A>(and its helper modules <EM class=Code>multiarray</EM> 
  and <EM class=Code>umath</EM> .) </LI></UL>
<P class=CBullet><A name=pgfId-57146></A>This module defines two new object 
types, and a set of functions which manipulate these objects, as well as convert 
between them and other Python types. The objects are the new array object 
(technically called <EM class=Code>multiarray</EM> <A 
name=marker-59537></A>objects), and <A name=marker-59539></A>universal functions 
(technically <EM class=Code>ufunc</EM> <A name=marker-59538></A>objects). </P>
<UL>
  <LI class=Bullet><A name=pgfId-68164></A>Other optional packages shipped with 
  Numeric are discussed in <A class=XRef 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#90799">Optional 
  Packages</A>. Among these a packages for linear algebra, random numbers, 
  masked or missing values, and Fast Fourier Transforms. </LI></UL>
<DIV>
<H6 class=FM1Heading><A name=pgfId-57154></A><A name=30538></A>Array 
Objects</H6>
<P class=Body><A name=pgfId-57155></A>The array objects are generally 
homogeneous collections of potentially large numbers of numbers. All numbers in 
a multiarray are the same kind (i.e. number representation, such as 
double-precision floating point). Array objects must be full (no empty cells are 
allowed), and their size is immutable. The specific numbers within them can 
change throughout the life of the array.</P>
<P class=Body><A name=pgfId-68201></A>Note: In some applications arrays of 
numbers may contain entries representing invalid or missing values. An optional 
package "MA" is available to represent such arrays. <A 
name=marker-68202></A>Attempting to do so by using NaN as a value may lead to 
disappointment or lack of portability.</P>
<P class=Body><A name=pgfId-67507></A>Mathematical operations on arrays return 
new arrays containing the results of these operations performed <EM 
class=Emphasis>elementwise</EM> on the arguments of the operation.</P>
<P class=Body><A name=pgfId-57156></A>The <EM class=Emphasis>size</EM> of an 
array is the total number of elements therein (it can be 0 or more). It does not 
change throughout the life of the array.</P>
<P class=Body><A name=pgfId-57157></A>The <EM class=Emphasis>shape</EM> of an 
array is the number of dimensions of the array and its extent in each of these 
dimensions (it can be 0, 1 or more). It can change throughout the life of the 
array. In Python terms, the shape of an array is a tuple of integers, one 
integer for each dimension that represents the extent in that dimension.</P>
<P class=Body><A name=pgfId-57158></A>The <EM class=Emphasis>rank</EM> of an 
array is the number of dimensions along which it is defined. It can change 
throughout the life of the array. Thus, the rank is the length of the shape.</P>
<P class=Body><A name=pgfId-57159></A>The <EM class=Emphasis>typecode</EM> of an 
array is a single character description of the kind of element it contains 
(number format, character or Python reference). It determines the itemsize of 
the array.</P>
<P class=Body><A name=pgfId-57160></A>The <EM class=Emphasis>itemsize</EM> of an 
array is the number of 8-bit bytes used to store a single element in the array. 
The total memory used by an array tends to its size times its itemsize, as the 
size goes to infinity (there is a fixed overhead per array, as well as a fixed 
overhead per dimension).</P>
<P class=Body><A name=pgfId-57161></A>To put this in more familiar mathematicial 
language: A vector is a rank-1 array (it has only one dimension along which it 
can be indexed). A matrix as used in linear algebra is a rank-2 array (it has 
two dimensions along which it can be indexed). There are also rank-0 arrays, 
which can hold single scalars -- they have no dimension along which they can be 
indexed, but they contain a single number. </P>
<P class=Body><A name=pgfId-67522></A>Here is an example of Python code using 
the array objects (bold text refers to user input, non-bold text to computer 
output):</P>
<P class=Python><A name=pgfId-57163></A>&gt;&gt;&gt; <EM class=CodeInput>vector1 
= array((1,2,3,4,5))</EM> </P>
<P class=Python><A name=pgfId-57164></A>&gt;&gt;&gt; <EM class=CodeInput>print 
vector1</EM> </P>
<P class=Python><A name=pgfId-57165></A>[1 2 3 4 5]</P>
<P class=Python><A name=pgfId-57166></A>&gt;&gt;&gt; <EM class=CodeInput>matrix1 
= array(([0,1],[1,3]))</EM> </P>
<P class=Python><A name=pgfId-57167></A>&gt;&gt;&gt; <EM class=CodeInput>print 
matrix1</EM> </P>
<P class=Python><A name=pgfId-57168></A>[[0 1]</P>
<P class=Python><A name=pgfId-57169></A>[1 3]]</P>
<P class=Python><A name=pgfId-57170></A>&gt;&gt;&gt; <EM class=CodeInput>print 
vector1.shape, matrix1.shape</EM> </P>
<P class=Python><A name=pgfId-57171></A>(5,) (2,2)</P>
<P class=Python><A name=pgfId-57172></A>&gt;&gt;&gt; <EM class=CodeInput>print 
vector1 + vector1</EM> </P>
<P class=Python><A name=pgfId-57173></A>[ 2 4 6 8 10]]</P>
<P class=Python><A name=pgfId-57174></A>&gt;&gt;&gt; <EM class=CodeInput>print 
matrix1 * matrix1</EM> </P>
<P class=Python><A name=pgfId-57175></A>[[0 1] <EM class=Emphasis># note that 
this is not the matrix </EM></P>
<P class=Python><A name=pgfId-57176></A>[1 9]] <EM class=CodeInput># 
multiplication of linear algebra</EM> </P>
<P class=Body><A name=pgfId-67551></A>If this example does not work for you 
because it complains of an unknown name "array", you forgot to begin your 
session with </P>
<P class=Python><A name=pgfId-67558></A><EM class=CodeInput>from Numeric import 
*</EM> </P>
<P class=Body><A name=pgfId-67559></A>See <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#from Numeric import * explanation">Just 
like all Python modules and packages, the Numeric module can be invoked using 
either the import Numeric form, or the from Numeric import ... form. Because 
most of the functions we'll talk about are in the Numeric module, in this 
document, all of the code samples will assume that they have been preceded by a 
statement:</A>.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-57178></A><A name=24371></A>Universal 
Functions</H6>
<P class=Body><A name=pgfId-57179></A>Universal functions (ufuncs) are functions 
which operate on arrays and other sequences. Most ufuncs perform mathematical 
operations on their arguments, also elementwise. </P>
<P class=Body><A name=pgfId-57180></A>Here is an example of Python code using 
the ufunc objects:</P>
<P class=Python><A name=pgfId-67532></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sin([pi/2., pi/4., pi/6.])</EM> </P>
<P class=Python><A name=pgfId-67533></A>[ 1. , 0.70710678, 0.5 ]</P>
<P class=Python><A name=pgfId-57182></A>&gt;&gt;&gt; <EM class=CodeInput>print 
greater([1,2,4,5], [5,4,3,2])</EM> </P>
<P class=Python><A name=pgfId-57183></A>[0 0 1 1]</P>
<P class=Python><A name=pgfId-57184></A>&gt;&gt;&gt; <EM class=CodeInput>print 
add([1,2,4,5], [5,4,3,2])</EM> </P>
<P class=Python><A name=pgfId-57185></A>[6 6 7 7]</P>
<P class=Python><A name=pgfId-57186></A>&gt;&gt;&gt; <EM class=CodeInput>print 
add.reduce([1,2,4,5])</EM> </P>
<P class=Python><A name=pgfId-60950></A>12 # 1 + 2 + 3 + 4 + 5</P>
<P class=Body><A name=pgfId-60956></A>Ufuncs are covered in detail in <A 
class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#30906">Ufuncs</A>. 
</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-60952></A><A 
name=marker-60951></A>Convenience Functions</H6>
<P class=FirstBody><A name=pgfId-60953></A>The Numeric module provides, in 
addition to the functions which are needed to create the objects above, a set of 
powerful functions to manipulate arrays, select subsets of arrays based on the 
contents of other arrays, and other array-processing operations.</P>
<P class=Python><A name=pgfId-57192></A>&gt;&gt;&gt; <EM class=CodeInput>data = 
arange(10)</EM> # convenient homolog of builtin range()</P>
<P class=Python><A name=pgfId-57193></A>&gt;&gt;&gt; <EM class=CodeInput>print 
data</EM> </P>
<P class=Python><A name=pgfId-57194></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-57195></A>&gt;&gt;&gt; <EM class=CodeInput>print 
where(greater(data, 5), -1, data)</EM> </P>
<P class=Python><A name=pgfId-57196></A>[ 0 1 2 3 4 5 -1 -1 -1 -1] # selection 
facility</P>
<P class=Python><A name=pgfId-57197></A>&gt;&gt;&gt; <EM class=CodeInput>data = 
resize(array((0,1)), (9, 9))</EM> </P>
<P class=Python><A name=pgfId-57198></A>&gt;&gt;&gt; <EM class=CodeInput>print 
data </EM></P>
<P class=Python><A name=pgfId-57199></A>[[0 1 0 1 0 1 0 1 0]</P>
<P class=Python><A name=pgfId-57200></A>[1 0 1 0 1 0 1 0 1]</P>
<P class=Python><A name=pgfId-57201></A>[0 1 0 1 0 1 0 1 0]</P>
<P class=Python><A name=pgfId-57202></A>[1 0 1 0 1 0 1 0 1]</P>
<P class=Python><A name=pgfId-57203></A>[0 1 0 1 0 1 0 1 0]</P>
<P class=Python><A name=pgfId-57204></A>[1 0 1 0 1 0 1 0 1]</P>
<P class=Python><A name=pgfId-57205></A>[0 1 0 1 0 1 0 1 0]</P>
<P class=Python><A name=pgfId-57206></A>[1 0 1 0 1 0 1 0 1]</P>
<P class=Python><A name=pgfId-60992></A>[0 1 0 1 0 1 0 1 0]]</P>
<P class=Body><A name=pgfId-60993></A>All of the functions which operate on 
NumPy arrays are described in <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#28351">Array 
Functions</A>.</P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-57315></A>5. <A name=82200></A>Array Basics</H2>
<P class=ChapterDescription><A name=pgfId-35604></A>This chapter introduces some 
of the basic functions which will be used throughout the text.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-37311></A>Basics</H6>
<P class=Body><A name=pgfId-37312></A>Before we explore the world of image 
manipulation as a case-study in array manipulation, we should first define a few 
terms which we'll use over and over again. Discussions of arrays and matrices 
and vectors can get confusing due to disagreements on the nomenclature. Here is 
a brief definition of the terms used in this tutorial, and more or less 
consistently in the error messages of NumPy.</P>
<P class=Body><A name=pgfId-37313></A>The python objects under discussion are 
formally called "<A name=marker-59540></A>multiarray" objects, but informally 
we'll just call them "array" objects or just "arrays." These are different from 
the array objects defined in the standard Python <EM class=Code>array</EM> 
module (which is an older module designed for processing one-dimensional data 
such as sound files). </P>
<P class=Body><A name=pgfId-37314></A>These array objects hold their data in a 
<A name=marker-59541></A>homogeneous block of elements, i.e. their elements all 
have the same C type (such as a 64-bit floating-point number). This is quite 
different from most Python container objects, which can contain heterogeneous 
collections. (You can, however, have an array of Python objects, as discussed 
later).</P>
<P class=Body><A name=pgfId-37318></A>Any given array object has a <A 
name=marker-59542></A>rank, which is the number of "<A 
name=marker-59543></A>dimensions" or "<A name=marker-59544></A>axes" it has. For 
example, a point in 3D space [1, 2, 1] is an array of rank 1 - it has one 
dimension. That dimension has a <EM class=Emphasis>length</EM> of 3. </P>
<P class=Body><A name=pgfId-37319></A>As another example, the array </P>
<P class=Python><A name=pgfId-37320></A>1.0 0.0 0.0</P>
<P class=Python><A name=pgfId-37321></A>0.0 1.0 2.0</P>
<P class=Body><A name=pgfId-61092></A>is an array of rank 2 (it is 
2-dimensional). The first dimension has a length of 2, the second dimension has 
a length of 3. Because the word "dimension" has many different meanings to 
different folks, in general the word "axis" will be used instead. Axes are 
numbered just like Python list indices: they start at 0, and can also be counted 
from the end, so that axis -1 is the last axis of an array, axis -2 is the 
penultimate axis, etc. </P>
<P class=Body><A name=pgfId-61093></A>There are two important and potentially 
unintuitive behaviors of NumPy arrays which take some getting used to. The first 
is that by default, operations on arrays are performed <A 
name=marker-61094></A>element-wise. This means that when adding two arrays, the 
resulting array has as elements the pairwise sums of the two operand arrays. 
This is true for all operations, including multiplication. Thus, array 
multiplication using the * operator will default to element-wise multiplication, 
not matrix multiplication as used in linear algebra. Many people will want to 
use arrays as linear algebra-type matrices (including their rank-1 versions, 
vectors). For those users, the Matrix class provides a more intuitive interface. 
We defer discussion of the Matrix class until later. </P>
<P class=Body><A name=pgfId-67591></A>The second behavior which will catch many 
users by surprise is that functions which return arrays which are simply 
different views at the same data will in fact share their data. This will be 
discussed at length when we have more concrete examples of what exactly this 
means.</P>
<P class=Body><A name=pgfId-37324></A>Now that all of these definitions and 
warnings are laid out, let's see what we can do with these arrays. </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-35605></A>Creating arrays from scratch</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35606></A><A name=marker-59546></A>array() 
and <A name=marker-59547></A>typecodes</H6>
<P class=Body><A name=pgfId-35607></A>There are many ways to create arrays. The 
most basic one is the use of the <EM class=Code>array()</EM> function: </P>
<P class=Python><A name=pgfId-35608></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1.2, 3.5, -1])</EM> </P>
<P class=Body><A name=pgfId-35609></A>to make sure this worked, do: </P>
<P class=Python><A name=pgfId-35610></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35611></A>[ 1.2 3.5 -1. ]</P>
<P class=Body><A name=pgfId-35615></A>The <EM class=Code>array(numbers, 
typecode=None, savespace=0) </EM>function takes three arguments - the first one 
is the values, which have to be in a Python sequence object (such as a list or a 
tuple). The optional second argument is the typecode of the elements. If it is 
omitted, as in the example above, Python tries to find the one type which can 
represent all the elements. The third is discussed in <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#29152">Saving 
space</A>. </P>
<P class=Body><A name=pgfId-68273></A>Since the elements we gave our example 
were two floats and one integer, it chose `float' as the type of the resulting 
array. If one specifies the typecode, one can specify unequivocally the type of 
the elements - this is especially useful when, for example, one wants to make 
sure that an array contains floats even though in some cases all of its elements 
are integers: </P>
<P class=Python><A name=pgfId-35616></A>&gt;&gt;&gt; <EM class=CodeInput>x,y,z = 
1,2,3</EM> </P>
<P class=Python><A name=pgfId-35617></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([x,y,z]) </EM># integers are enough for 1, 2 and 3</P>
<P class=Python><A name=pgfId-35618></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35619></A>[1 2 3]</P>
<P class=Python><A name=pgfId-35620></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([x,y,z], Float) </EM># not the default type</P>
<P class=Python><A name=pgfId-35621></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35622></A>[ 1. 2. 3.]</P>
<DIV>
<H6 class=NoteTip><A name=pgfId-84321></A>
<DIV><IMG src="numdoc_files/numdoc-3.gif"> </DIV>&nbsp;</H6>
<P class=Note><A name=pgfId-84322></A>Pop Quiz: What will be the type of an 
array defined as follows:<BR></P>
<P class=PythonNote><A name=pgfId-61028></A><EM class=Code>&gt;&gt;&gt; </EM><EM 
class=CodeInput>mystery = array([1, 2.0, -3j])</EM> </P>
<P class=Note><A name=pgfId-61029></A>Hint: <EM class=Code>-3j</EM> is an 
imaginary number.</P>
<P class=Note><A name=pgfId-61032></A><A name=marker-84325></A>Answer: try it 
out! 
<DIV><IMG src="numdoc_files/numdoc-4.gif"> </DIV>
<P></P></DIV>
<DIV>
<H6 class=NoteTip><A name=pgfId-61036></A>
<DIV><IMG src="numdoc_files/numdoc-3.gif"> </DIV>&nbsp;</H6>
<P class=Note><A name=pgfId-61047></A>A very common mistake is to call array 
with a set of numbers as arguments, as in <EM class=Code>array(1,2,3,4,5)</EM> . 
This doesn't produce the expected result as soon as at least two numbers are 
used, because the first argument to <EM class=Code>array()</EM> must be the 
entire data for the array -- thus, in most cases, a sequence of numbers. The 
correct way to write the preceding invocation is most likely <EM 
class=Code>array((1,2,3,4,5))</EM> .
<DIV><IMG src="numdoc_files/numdoc-4.gif"> </DIV>
<P></P>
<P class=Body><A name=pgfId-35625></A>Possible values for the second argument to 
the <EM class=Code>array</EM> creator function (and indeed to any function which 
accepts a so-called typecode for arrays) are: </P>
<OL>
  <LI class=Step><A name=pgfId-35626></A>One type corresponding to single ASCII 
  characters: <EM class=Code>Character</EM> <A name=marker-59548></A>. 
  <LI class=Step><A name=pgfId-35627></A>One unsigned numeric type: <EM 
  class=Code>UnsignedInt8</EM> <A name=marker-59549></A>, used to store numbers 
  between 0 and 255. 
  <LI class=Step><A name=pgfId-35628></A>Many signed numeric types: 
  <LI class=BulletLev2><A name=pgfId-59564></A>Signed integer choices: <EM 
  class=Code>Int</EM> <A name=marker-59558></A>, <EM class=Code>Int0</EM> <A 
  name=marker-59559></A>, <EM class=Code>Int8</EM> <A name=marker-59560></A>, 
  <EM class=Code>Int16</EM> <A name=marker-59561></A>, <EM class=Code>Int32</EM> 
  <A name=marker-59562></A>, and on some platforms, <EM class=Code>Int64</EM> <A 
  name=marker-59563></A>and <EM class=Code>Int128</EM> <A 
  name=marker-59565></A>(their ranges depend on their size). 
  <LI class=BulletLev2><A name=pgfId-59567></A>Floating point choices: <EM 
  class=Code>Float</EM> <A name=marker-59566></A>, <EM class=Code>Float0</EM> <A 
  name=marker-59570></A>, <EM class=Code>Float8</EM> <A name=marker-59571></A>, 
  <EM class=Code>Float16</EM> <A name=marker-59572></A>, <EM 
  class=Code>Float32</EM> <A name=marker-59573></A>, <EM class=Code>Float64</EM> 
  <A name=marker-59574></A>, and on some platforms, <EM class=Code>Float128</EM> 
  <A name=marker-59575></A>. 
  <LI class=BulletLev2><A name=pgfId-35631></A>Complex number choices: <EM 
  class=Code>Complex</EM> <A name=marker-59576></A>, <EM 
  class=Code>Complex0</EM> <A name=marker-59577></A>, <EM 
  class=Code>Complex8</EM> <A name=marker-59578></A>, <EM 
  class=Code>Complex16</EM> <A name=marker-59579></A>, <EM 
  class=Code>Complex32</EM> <A name=marker-59580></A>, <EM 
  class=Code>Complex64</EM> <A name=marker-59581></A>, <EM 
  class=Code>Complex128</EM> <A name=marker-59582></A>. </LI></OL>
<P class=Body><A name=pgfId-35632></A>The meaning of these is as follows:</P>
<UL>
  <LI class=BulletLev2><A name=pgfId-35633></A>The versions without any numbers 
  (<EM class=Code> Int</EM> , <EM class=Code>Float</EM> , <EM 
  class=Code>Complex</EM> ) correspond to the <EM class=Code>int</EM> , <EM 
  class=Code>float</EM> and <EM class=Code>complex</EM> datatypes in Python. 
  They are thus long integers and double-precision floating point numbers, with 
  a complex number corresponding to two double-precision floats. 
  <LI class=BulletLev2><A name=pgfId-35634></A>The versions with a number 
  following correspond to whatever words are available on the specific platform 
  you are using which have <EM class=Emphasis>at least</EM> that many bits in 
  them. Thus, <EM class=Code>Int0</EM> corresponds to the smallest integer word 
  size available, <EM class=Code>Int8</EM> corresponds to the smallest integer 
  word size available which has at least 8 bits, etc. The word sizes for the 
  complex numbers refer to the total number of bits used by both the real and 
  imaginary parts (in other words, the data portion of an array of N <EM 
  class=Code>Complex128</EM> elements uses up the same amount of memory as the 
  data portions of two arrays of typecode <EM class=Code>Float64</EM> with 2N 
  elements). 
  <LI class=Step><A name=pgfId-35635></A>One non-numeric type, <EM 
  class=Code>PyObject</EM> <A name=marker-59583></A>. Arrays of typecode <EM 
  class=Code>PyObject</EM> are arrays of Python references, and as such their 
  data area can contain references to any kind of Python objects. </LI></UL>
<P class=Body><A name=pgfId-35636></A>The last typecode deserves a little 
comment. Indeed, it seems to indicate that arrays can be filled with any Python 
objects. This appears to violate the notion that arrays are homogeneous. In 
fact, the typecode <EM class=Code>PyObject</EM> does allow heterogeneous arrays. 
However, if you plan to do numerical computation, you're much better off with a 
homogeneous array with a potentially "large" type than with a heterogeneous 
array. This is because a heterogeneous array stores references to objects, which 
incurs a memory cost, and because the speed of computation is much slower with 
arrays of <EM class=Code>PyObject</EM> 's than with uniform number arrays. Why 
does it exist, then? </P>
<P class=Body><A name=pgfId-68287></A>A very useful features of arrays is the 
ability to slice them, dice them, select and choose from them, etc. This feature 
is so nice that sometimes one wants to do the same operations with, e.g., arrays 
of class instances. In such cases, computation speed is not as important as 
convenience. Also, if the array is filled with objects which are instances of 
classes which define the appropriate methods, then NumPy will let you do math 
with those objects. For example, if one creates an object class which has an <EM 
class=Code>__add__</EM> method, then arrays (created with the <EM 
class=Code>PyObject</EM> typecode) of instances of such a class can be added 
together. </P></DIV></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35637></A>Multidimensional Arrays</H6>
<P class=Body><A name=pgfId-35638></A>The following example shows one way of 
creating multidimensional arrays: </P>
<P class=Python><A name=pgfId-35639></A>&gt;&gt;&gt; <EM class=CodeInput>ma = 
array([[1,2,3],[4,5,6]])</EM> </P>
<P class=Python><A name=pgfId-35640></A>&gt;&gt;&gt; <EM class=CodeInput>print 
ma</EM> </P>
<P class=Python><A name=pgfId-35641></A>[[1 2 3]</P>
<P class=Python><A name=pgfId-35642></A>[4 5 6]]</P>
<P class=Body><A name=pgfId-35643></A>The first argument to <EM 
class=Code>array()</EM> in the code above is a single list containing two lists, 
each containing three elements. If we wanted floats instead, we could specify, 
as discussed in the previous section, the optional typecode we wished: </P>
<P class=Python><A name=pgfId-35644></A>&gt;&gt;&gt; <EM 
class=CodeInput>ma_floats = array([[1,2,3],[4,5,6]], Float)</EM> </P>
<P class=Python><A name=pgfId-35645></A>&gt;&gt;&gt; <EM class=CodeInput>print 
ma_floats</EM> </P>
<P class=Python><A name=pgfId-35646></A>[[ 1. 2. 3.]</P>
<P class=Python><A name=pgfId-35647></A>[ 4. 5. 6.]]</P>
<P class=Body><A name=pgfId-35648></A>This array allows us to introduce the 
notion of `shape'. The shape of an array is the set of numbers which define its 
dimensions. The shape of the array <EM class=Code>ma</EM> defined above is 2 by 
3. More precisely, all arrays have a shape attribute which is a tuple of 
integers. So, in this case: </P>
<P class=Python><A name=pgfId-35649></A>&gt;&gt;&gt; <EM class=CodeInput>print 
ma.shape</EM> </P>
<P class=Python><A name=pgfId-35650></A>(2, 3)</P>
<P class=Body><A name=pgfId-35651></A>Using the earlier definitions, this is a 
shape of rank 2, where the first axis has length 2, and the seond axis has 
length 3. The rank of an array <EM class=Code>A</EM> is always equal to <EM 
class=Code>len(A.shape)</EM> . </P>
<P class=Body><A name=pgfId-35652></A>Note that <EM class=Code>shape</EM> is an 
<EM class=Emphasis>attribute</EM> of <EM class=Code>array</EM> objects. It is 
the first of several which we will see throughout this tutorial. If you're not 
used to object-oriented programming, you can think of attributes as "features" 
or "qualities" of individual arrays. The relation between an array and its shape 
is similar to the relation between a person and their hair color. In Python, 
it's called an object/attribute relation. </P>
<P class=Body><A name=pgfId-35653></A>What if one wants to change the dimensions 
of an array? For now, let us consider changing the shape of an array without 
making it "grow." Say, for example, we want to make the 2x3 array defined above 
(<EM class=Code> ma</EM> ) an array of rank 1: </P>
<P class=Python><A name=pgfId-35654></A>&gt;&gt;&gt; <EM 
class=CodeInput>flattened_ma = reshape(ma, (6,))</EM> </P>
<P class=Python><A name=pgfId-35655></A>&gt;&gt;&gt; <EM class=CodeInput>print 
flattened_ma</EM> </P>
<P class=Python><A name=pgfId-35656></A>[1 2 3 4 5 6]</P>
<P class=Body><A name=pgfId-35657></A>One can change the shape of arrays to any 
shape as long as the product of all the lengths of all the axes is kept constant 
(in other words, as long as the number of elements in the array doesn't change): 
</P>
<P class=Python><A name=pgfId-35658></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1,2,3,4,5,6,7,8])</EM> </P>
<P class=Python><A name=pgfId-35659></A>[1 2 3 4 5 6 7 8]</P>
<P class=Python><A name=pgfId-35660></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35661></A>&gt;&gt;&gt; <EM class=CodeInput>b = 
reshape(a, (2,4)) </EM># 2*4 == 8</P>
<P class=Python><A name=pgfId-35662></A>[[1 2 3 4]</P>
<P class=Python><A name=pgfId-35663></A>[5 6 7 8]]</P>
<P class=Python><A name=pgfId-35664></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-35665></A>&gt;&gt;&gt; <EM class=CodeInput>c = 
reshape(b, (4,2) </EM># 4*2 == 8 </P>
<P class=Python><A name=pgfId-35666></A>&gt;&gt;&gt; <EM class=CodeInput>print 
c</EM> </P>
<P class=Python><A name=pgfId-35667></A>[[1 2]</P>
<P class=Python><A name=pgfId-35668></A>[3 4]</P>
<P class=Python><A name=pgfId-35669></A>[5 6]</P>
<P class=Python><A name=pgfId-35670></A>[7 8]]</P>
<P class=Body><A name=pgfId-35671></A>Notice that we used a new function, <EM 
class=Code>reshape()</EM> <A name=marker-59584></A>. It, like <EM 
class=Code>array()</EM> , is a function defined in the <EM 
class=Code>Numeric</EM> module. It expects an array as its first argument, and a 
shape as its second argument. The shape has to be a sequence of integers (a list 
or a tuple). Keep in mind that a tuple with a single element needs a comma at 
the end; the right shape tuple for a rank-1 array with 5 elements is <EM 
class=Code>(5,)</EM> , not <EM class=Code>(5)</EM> . </P>
<P class=Body><A name=pgfId-35672></A>One nice feature of shape tuples is that 
one entry in the shape tuple is allowed to be <EM class=Code>-1</EM> . The <EM 
class=Code>-1</EM> will be automatically replaced by whatever number is needed 
to build a shape which does not change the size of the array. Thus: </P>
<P class=Python><A name=pgfId-35673></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
reshape(array(range(25)), (5,-1))</EM> </P>
<P class=Python><A name=pgfId-35674></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a, a.shape </EM></P>
<P class=Python><A name=pgfId-35675></A>[[ 0 1 2 3 4]</P>
<P class=Python><A name=pgfId-35676></A>[ 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-35677></A>[10 11 12 13 14]</P>
<P class=Python><A name=pgfId-35678></A>[15 16 17 18 19]</P>
<P class=Python><A name=pgfId-35679></A>[20 21 22 23 24]] (5, 5)</P>
<P class=Body><A name=pgfId-35680></A>The shape of an array is a modifiable 
attribute of the array. You can therefore change the shape of an array simply by 
assigning a new shape to it: </P>
<P class=Python><A name=pgfId-35681></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1,2,3,4,5,6,7,8,9,10]) </EM></P>
<P class=Python><A name=pgfId-35682></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.shape</EM> </P>
<P class=Python><A name=pgfId-35683></A>(10,) </P>
<P class=Python><A name=pgfId-35684></A>&gt;&gt;&gt; <EM class=CodeInput>a.shape 
= (2,5) </EM></P>
<P class=Python><A name=pgfId-35685></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35686></A>[[ 1 2 3 4 5]</P>
<P class=Python><A name=pgfId-35687></A>[ 6 7 8 9 10]]</P>
<P class=Python><A name=pgfId-35688></A>&gt;&gt;&gt; <EM class=CodeInput>a.shape 
= (10,1) </EM># second axis has length 1</P>
<P class=Python><A name=pgfId-35689></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35690></A>[[ 1]</P>
<P class=Python><A name=pgfId-35691></A>[ 2]</P>
<P class=Python><A name=pgfId-35692></A>[ 3]</P>
<P class=Python><A name=pgfId-35693></A>[ 4]</P>
<P class=Python><A name=pgfId-35694></A>[ 5]</P>
<P class=Python><A name=pgfId-35695></A>[ 6]</P>
<P class=Python><A name=pgfId-35696></A>[ 7]</P>
<P class=Python><A name=pgfId-35697></A>[ 8]</P>
<P class=Python><A name=pgfId-35698></A>[ 9]</P>
<P class=Python><A name=pgfId-35699></A>[10]]</P>
<P class=Python><A name=pgfId-35700></A>&gt;&gt;&gt; <EM class=CodeInput>a.shape 
= (5,-1) </EM># note the -1 trick described above</P>
<P class=Python><A name=pgfId-35701></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35702></A>[[ 1 2]</P>
<P class=Python><A name=pgfId-35703></A>[ 3 4]</P>
<P class=Python><A name=pgfId-35704></A>[ 5 6]</P>
<P class=Python><A name=pgfId-35705></A>[ 7 8]</P>
<P class=Python><A name=pgfId-35706></A>[ 9 10]]</P>
<P class=Body><A name=pgfId-35707></A>As in the rest of Python, violating rules 
(such as the one about which shapes are allowed) results in exceptions:</P>
<P class=Python><A name=pgfId-35708></A>&gt;&gt;&gt; <EM class=CodeInput>a.shape 
= (6,-1)</EM> </P>
<P class=Python><A name=pgfId-35709></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-35710></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-35711></A>ValueError: total size of new array must 
be unchanged</P>
<DIV>
<H6 class=MoreTip><A name=pgfId-35713></A>
<DIV><IMG src="numdoc_files/numdoc-6.gif"> </DIV>&nbsp;</H6>
<P class=Note><A name=pgfId-61102></A>The default printing routine provided by 
the Numeric module prints arrays as follows:</P>
<OL>
  <LI class=NoteEnum><A name=pgfId-35714></A>The last axis is always printed 
  left to right 
  <LI class=NoteEnum><A name=pgfId-35715></A>The next-to-last axis is printed 
  top to bottom 
  <LI class=NoteEnum><A name=pgfId-35716></A>The remaining axes are printed top 
  to bottom with increasing numbers of separators 
  <DIV><IMG src="numdoc_files/numdoc-4.gif"> </DIV></LI></OL>
<P class=Body><A name=pgfId-35717></A>This explains why rank-1 arrays are 
printed from left to right, rank-2 arrays have the first dimension going down 
the screen and the second dimension going from left to right, etc. </P>
<P class=Body><A name=pgfId-35718></A>If you want to change the shape of an 
array so that it has more elements than it started with (i.e. grow it), then you 
have many options: One solution is to use the <EM class=Code>concat()</EM> 
method discussed later. An alternative is to use the <EM class=Code>array()</EM> 
creator function with existing arrays as arguments: </P>
<P class=Python><A name=pgfId-35719></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35720></A>[0 1 2 3 4 5 6 6 7]</P>
<P class=Python><A name=pgfId-35721></A>&gt;&gt;&gt; <EM class=CodeInput>b = 
array([a,a]) </EM></P>
<P class=Python><A name=pgfId-35722></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-35723></A>[[1 2 3 4 5 6 7 8]</P>
<P class=Python><A name=pgfId-35724></A>[1 2 3 4 5 6 7 8]] </P>
<P class=Python><A name=pgfId-35725></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b.shape</EM> </P>
<P class=Python><A name=pgfId-35726></A>(2, 8) </P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-68290></A>resize</H6>
<P class=Body><A name=pgfId-65778></A>A final possibility is the <EM 
class=Code>resize()</EM> <A name=marker-59585></A>function, which takes a "base" 
array as its first argument and the desired shape as the second argument. Unlike 
<EM class=Code>reshape()</EM> , the shape argument to <EM 
class=Code>resize()</EM> can corresponds to a smaller or larger shape than the 
input array. Smaller shapes will result in arrays with the data at the 
"beginning" of the input array, and larger shapes result in arrays with data 
containing as many replications of the input array as are needed to fill the 
shape. For example, starting with a simple array</P>
<P class=Python><A name=pgfId-35728></A>&gt;&gt;&gt; <EM class=CodeInput>base = 
array([0,1])</EM> </P>
<P class=Body><A name=pgfId-35729></A>one can quickly build a large array with 
replicated data: </P>
<P class=Python><A name=pgfId-35730></A>&gt;&gt;&gt; <EM class=CodeInput>big = 
resize(base, (9,9)) </EM></P>
<P class=Python><A name=pgfId-35731></A>&gt;&gt;&gt; <EM class=CodeInput>print 
big</EM> </P>
<P class=Python><A name=pgfId-35732></A>[[0 1 0 1 0 1 0 1 0]</P>
<P class=Python><A name=pgfId-35733></A>[1 0 1 0 1 0 1 0 1]</P>
<P class=Python><A name=pgfId-35734></A>[0 1 0 1 0 1 0 1 0]</P>
<P class=Python><A name=pgfId-35735></A>[1 0 1 0 1 0 1 0 1]</P>
<P class=Python><A name=pgfId-35736></A>[0 1 0 1 0 1 0 1 0]</P>
<P class=Python><A name=pgfId-35737></A>[1 0 1 0 1 0 1 0 1]</P>
<P class=Python><A name=pgfId-35738></A>[0 1 0 1 0 1 0 1 0]</P>
<P class=Python><A name=pgfId-35739></A>[1 0 1 0 1 0 1 0 1]</P>
<P class=Python><A name=pgfId-35740></A>[0 1 0 1 0 1 0 1 0]]</P>
<P class=Body><A name=pgfId-35741></A>and if you imported the <EM 
class=Code>view</EM> function from the <EM class=Code>NumTut</EM> package, you 
can do:</P>
<P class=Python><A name=pgfId-35742></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(resize(base, (100,100)))</EM> </P>
<P class=Python><A name=pgfId-35743></A><EM class=Emphasis># grey grid of 
horizontal lines is shown</EM> </P>
<P class=Python><A name=pgfId-59939></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(resize(base, (101,101)))</EM> </P>
<P class=Python><A name=pgfId-59947></A><EM class=Emphasis># grey grid of 
alternating black and white pixels is shown</EM> </P>
<DIV>
<H6 class=MoreTip><A name=pgfId-60322></A>
<DIV><IMG src="numdoc_files/numdoc-6.gif"> </DIV>&nbsp;</H6>
<P class=Note><A name=pgfId-60323></A>Sections denoted such as this one with an 
"eye" symbol will be used to indicate aspects of the functions which may not be 
needed for a first introduction at NumPy, but which should be mentioned for the 
sake of completeness.</P>
<P class=Note><A name=pgfId-60312></A>&nbsp;</P>
<P class=Note><A name=pgfId-60338></A>The <EM class=Code>array</EM> constructor 
takes a mandatory <EM class=Code>data</EM> argument, an optional typecode, and 
optional <EM class=Code>savespace</EM> argument, and an optional <EM 
class=Code>copy</EM> argument. If the <EM class=Code>data</EM> argument is a 
sequence, then array creates a new object of type multiarray, and fills the 
array with the elements of the <EM class=Code>data</EM> object. The shape of the 
array is determined by the size and nesting arrangement of the elements of 
data.</P>
<P class=Note><A name=pgfId-60116></A>&nbsp;</P>
<P class=Note><A name=pgfId-60301></A>If <EM class=Code>data</EM> is not a 
sequence, then the array returned is an array of shape <EM class=Code>()</EM> 
(the empty tuple), of typecode <EM class=Code>'O'</EM> , containing a single 
element, which is <EM class=Code>data</EM> .
<DIV><IMG src="numdoc_files/numdoc-4.gif"> </DIV>
<P></P></DIV></DIV></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-60291></A>Creating arrays with values 
specified `on-the-fly' </H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-60120></A><A name=marker-60118></A>zeros() 
and <A name=marker-60119></A>ones() </H6>
<P class=Body><A name=pgfId-35748></A>Often, one needs to manipulate arrays 
filled with numbers which aren't available beforehand. The Numeric module 
provides a few functions which create arrays from scratch: </P>
<P class=Body><A name=pgfId-35749></A><EM class=Code>zeros()</EM> and <EM 
class=Code>ones()</EM> simply create arrays of a given shape filled with zeros 
and ones respectively: </P>
<P class=Python><A name=pgfId-35750></A>&gt;&gt;&gt; <EM class=CodeInput>z = 
zeros((3,3))</EM> </P>
<P class=Python><A name=pgfId-35751></A>&gt;&gt;&gt; <EM class=CodeInput>print 
z</EM> </P>
<P class=Python><A name=pgfId-35752></A>[[0 0 0]</P>
<P class=Python><A name=pgfId-35753></A>[0 0 0]</P>
<P class=Python><A name=pgfId-35754></A>[0 0 0]]</P>
<P class=Python><A name=pgfId-35755></A>&gt;&gt;&gt; <EM class=CodeInput>o = 
ones([2,3])</EM> </P>
<P class=Python><A name=pgfId-35756></A>&gt;&gt;&gt; <EM class=CodeInput>print 
o</EM> </P>
<P class=Python><A name=pgfId-35757></A>[[1 1 1]</P>
<P class=Python><A name=pgfId-35758></A>[1 1 1]]</P>
<P class=Body><A name=pgfId-35759></A>Note that the first argument is a shape - 
it needs to be a list or a tuple of integers. Also note that the default type 
for the returned arrays is <EM class=Code>Int</EM> , which you can feel free to 
override using something like: </P>
<P class=Python><A name=pgfId-35760></A>&gt;&gt;&gt; <EM class=CodeInput>o = 
ones((2,3), Float)</EM> </P>
<P class=Python><A name=pgfId-35761></A>&gt;&gt;&gt; <EM class=CodeInput>print 
o</EM> </P>
<P class=Python><A name=pgfId-35762></A>[[ 1. 1. 1.]</P>
<P class=Python><A name=pgfId-35763></A>[ 1. 1. 1.]]</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35764></A><A 
name=marker-59594></A>arrayrange() </H6>
<P class=Body><A name=pgfId-35765></A>The <EM class=Code>arrayrange()</EM> 
function is similar to the <EM class=Code>range()</EM> function in Python, 
except that it returns an array as opposed to a list. </P>
<P class=Python><A name=pgfId-35766></A>&gt;&gt;&gt; <EM class=CodeInput>r = 
arrayrange(10) </EM></P>
<P class=Python><A name=pgfId-35767></A>&gt;&gt;&gt; <EM class=CodeInput>print 
r</EM> </P>
<P class=Python><A name=pgfId-35768></A>[0 1 2 3 4 5 6 7 8 9] </P>
<P class=Body><A name=pgfId-35769></A>Combining the <EM 
class=Code>arrayrange()</EM> with the <EM class=Code>reshape()</EM> function, we 
can get: </P>
<P class=Python><A name=pgfId-35770></A>&gt;&gt;&gt; <EM class=CodeInput>big = 
reshape(arrayrange(100),(10,10))</EM> </P>
<P class=Python><A name=pgfId-35771></A>&gt;&gt;&gt; <EM class=CodeInput>print 
big<BR></EM>[[ 0 1 2 3 4 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-35772></A>[10 11 12 13 14 15 16 17 18 19]</P>
<P class=Python><A name=pgfId-35773></A>[20 21 22 23 24 25 26 27 28 29]</P>
<P class=Python><A name=pgfId-35774></A>[30 31 32 33 34 35 36 37 38 39]</P>
<P class=Python><A name=pgfId-35775></A>[40 41 42 43 44 45 46 47 48 49]</P>
<P class=Python><A name=pgfId-35776></A>[50 51 52 53 54 55 56 57 58 59]</P>
<P class=Python><A name=pgfId-35777></A>[60 61 62 63 64 65 66 67 68 69]</P>
<P class=Python><A name=pgfId-35778></A>[70 71 72 73 74 75 76 77 78 79]</P>
<P class=Python><A name=pgfId-35779></A>[80 81 82 83 84 85 86 87 88 89]</P>
<P class=Python><A name=pgfId-35780></A>[90 91 92 93 94 95 96 97 98 99]]</P>
<P class=Python><A name=pgfId-35781></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(reshape(arrayrange(10000),(100,100)))</EM> </P>
<P class=Python><A name=pgfId-35782></A><EM class=Emphasis># array of increasing 
lightness from top down (slowly) and from left to</EM> </P>
<P class=Python><A name=pgfId-35783></A><EM class=Emphasis># right (faster) is 
shown</EM> </P>
<P class=Body><A name=pgfId-35784></A><EM class=Code>arange()</EM> is a 
shorthand for <EM class=Code>arrayrange()</EM> . </P>
<P class=Body><A name=pgfId-35785></A>One can set the start, stop and step 
arguments, which allows for more varied ranges: </P>
<P class=Python><A name=pgfId-35786></A>&gt;&gt;&gt; <EM class=CodeInput>print 
arrayrange(10,-10,-2)</EM> </P>
<P class=Python><A name=pgfId-35787></A>[10 8 6 4 2 0 -2 -4 -6 -8]</P>
<P class=Body><A name=pgfId-35788></A>An important feature of arrayrange is that 
it can be used with non-integer starting points and strides:</P>
<P class=Python><A name=pgfId-35789></A>&gt;&gt;&gt; <EM class=CodeInput>print 
arrayrange(5.0)</EM> </P>
<P class=Python><A name=pgfId-35790></A>[ 0. 1. 2. 3. 4.]</P>
<P class=Python><A name=pgfId-35791></A>&gt;&gt;&gt; <EM class=CodeInput>print 
arrayrange(0, 1, .2)</EM> </P>
<P class=Python><A name=pgfId-35792></A>[ 0. 0.2 0.4 0.6 0.8]</P>
<P class=Body><A name=pgfId-60244></A>If you want to create an array with just 
one value, repeated over and over, you can use the * operator applied to lists 
</P>
<P class=Python><A name=pgfId-60245></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([[3]*5]*5)</EM> </P>
<P class=Python><A name=pgfId-60246></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35796></A>[[3 3 3 3 3]</P>
<P class=Python><A name=pgfId-35797></A>[3 3 3 3 3]</P>
<P class=Python><A name=pgfId-35798></A>[3 3 3 3 3]</P>
<P class=Python><A name=pgfId-35799></A>[3 3 3 3 3]</P>
<P class=Python><A name=pgfId-35800></A>[3 3 3 3 3]]</P>
<P class=Body><A name=pgfId-35801></A>but that is relatively slow, since the 
duplication is done on Python lists. A quicker way would be to start with 0's 
and add 3: </P>
<P class=Python><A name=pgfId-35802></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
zeros([5,5]) + 3</EM> </P>
<P class=Python><A name=pgfId-35803></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35804></A>[[3 3 3 3 3]</P>
<P class=Python><A name=pgfId-35805></A>[3 3 3 3 3]</P>
<P class=Python><A name=pgfId-35806></A>[3 3 3 3 3]</P>
<P class=Python><A name=pgfId-35807></A>[3 3 3 3 3]</P>
<P class=Python><A name=pgfId-35808></A>[3 3 3 3 3]]</P>
<P class=FirstBody><A name=pgfId-66497></A>The optional typecode argument can 
force the typecode of the resulting array, which is otherwise the "highest" of 
the starting and stopping arguments. The starting argument defaults to 0 if not 
specified. Note that if a typecode is specified which is "lower" than that which 
arrayrange would normally use, the array is the result of a precision-losing 
cast (a round-down, as that used in the <EM class=Code>astype</EM> method for 
arrays.)</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35809></A>Creating an array from a function: 
<A name=marker-59598></A>fromfunction()</H6>
<P class=Body><A name=pgfId-35810></A>Finally, one may want to create an array 
with contents which are the result of a function evaluation. This is done using 
the <EM class=Code>fromfunction()</EM> function, which takes two arguments, a 
shape and a callable object (usually a function). For example: </P>
<P class=Python><A name=pgfId-35811></A>&gt;&gt;&gt; <EM class=CodeInput>def 
dist(x,y):</EM> </P>
<P class=Python><A name=pgfId-35812></A>... <EM class=CodeInput>return 
(x-5)**2+(y-5)**2 </EM># distance from point (5,5) squared</P>
<P class=Python><A name=pgfId-35813></A>...</P>
<P class=Python><A name=pgfId-35814></A>&gt;&gt;&gt; <EM class=CodeInput>m = 
fromfunction(dist, (10,10))</EM> </P>
<P class=Python><A name=pgfId-35815></A>&gt;&gt;&gt; <EM class=CodeInput>print 
m</EM> </P>
<P class=Python><A name=pgfId-35816></A>[[50 41 34 29 26 25 26 29 34 41]</P>
<P class=Python><A name=pgfId-35817></A>[41 32 25 20 17 16 17 20 25 32]</P>
<P class=Python><A name=pgfId-35818></A>[34 25 18 13 10 9 10 13 18 25]</P>
<P class=Python><A name=pgfId-35819></A>[29 20 13 8 5 4 5 8 13 20]</P>
<P class=Python><A name=pgfId-35820></A>[26 17 10 5 2 1 2 5 10 17]</P>
<P class=Python><A name=pgfId-35821></A>[25 16 9 4 1 0 1 4 9 16]</P>
<P class=Python><A name=pgfId-35822></A>[26 17 10 5 2 1 2 5 10 17]</P>
<P class=Python><A name=pgfId-35823></A>[29 20 13 8 5 4 5 8 13 20]</P>
<P class=Python><A name=pgfId-35824></A>[34 25 18 13 10 9 10 13 18 25]</P>
<P class=Python><A name=pgfId-35825></A>[41 32 25 20 17 16 17 20 25 32]]</P>
<P class=Python><A name=pgfId-35826></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(fromfunction(dist, (100,100))</EM> </P>
<P class=Python><A name=pgfId-35827></A><EM class=Emphasis># shows image which 
is dark in topleft corner, and lighter away from it.</EM> </P>
<P class=Python><A name=pgfId-35828></A>&gt;&gt;&gt; <EM class=CodeInput>m = 
fromfunction(lambda i,j,k: 100*(i+1)+10*(j+1)+(k+1), (4,2,3))</EM> </P>
<P class=Python><A name=pgfId-35829></A>&gt;&gt;&gt; <EM class=CodeInput>print 
m</EM> </P>
<P class=Python><A name=pgfId-35830></A>[[[111 112 113]</P>
<P class=Python><A name=pgfId-35831></A>[121 122 123]]</P>
<P class=Python><A name=pgfId-35832></A>[[211 212 213]</P>
<P class=Python><A name=pgfId-35833></A>[221 222 223]]</P>
<P class=Python><A name=pgfId-35834></A>[[311 312 313]</P>
<P class=Python><A name=pgfId-35835></A>[321 322 323]]</P>
<P class=Python><A name=pgfId-35836></A>[[411 412 413]</P>
<P class=Python><A name=pgfId-35837></A>[421 422 423]]]</P>
<P class=Body><A name=pgfId-35838></A>By examining the above examples, one can 
see that <EM class=Code>fromfunction()</EM> creates an array of the shape 
specified by its second argument, and with the contents corresponding to the 
value of the function argument (the first argument) evaluated at the indices of 
the array. Thus the value of <EM class=Code>m[3,4]</EM> in the first example 
above is the value of <EM class=Code>dist</EM> when <EM class=Code>x=3</EM> and 
<EM class=Code>y=4</EM> . Similarly for the lambda function in the second 
example, but with a rank-3 array.</P>
<P class=Body><A name=pgfId-66372></A>The implementation of fromfunction 
consists of:</P>
<P class=Python><A name=pgfId-66373></A>def fromfunction(function, 
dimensions):</P>
<P class=Python><A name=pgfId-66374></A>return apply(function, 
tuple(indices(dimensions)))</P>
<P class=Body><A name=pgfId-66375></A>which means that the function function is 
called for each element in the sequence indices(dimensions). As described in the 
definition of indices, this consists of arrays of indices which will be of rank 
one less than that specified by dimensions. This means that the function 
argument must accept the same number of arguments as there are dimensions in 
dimensions, and that each argument will be an array of the same shape as that 
specified by dimensions. Furthermore, the array which is passed as the first 
argument corresponds to the indices of each element in the resulting array along 
the first axis, that which is passed as the second argument corresponds to the 
indices of each element in the resulting array along the second axis, etc. A 
consequence of this is that the function which is used with fromfunction will 
work as expected only if it performs a separable computation on its arguments, 
and expects its arguments to be indices along each axis. Thus, no logical 
operation on the arguments can be performed, or any non-shape preserving 
operation. The first example below satisfies these requirements, hence works 
(the <EM class=Code>x</EM> and <EM class=Code>y</EM> arrays both get 10x10 
arrays as input corresponding to the values of the indices along the two 
dimensions), while the second array attemps to do a comparison test on an array 
of indices, which fails.</P>
<P class=Python><A name=pgfId-66411></A>&gt;&gt;&gt; <EM class=CodeInput>def 
buggy(test):</EM> </P>
<P class=Python><A name=pgfId-66412></A>... <EM class=CodeInput>if test &gt; 4: 
return 1</EM> </P>
<P class=Python><A name=pgfId-66413></A>... <EM class=CodeInput>else: return 
0</EM> </P>
<P class=Python><A name=pgfId-66414></A>...</P>
<P class=Python><A name=pgfId-66415></A>&gt;&gt;&gt; <EM class=CodeInput>print 
fromfunction(buggy, (10,))</EM> </P>
<P class=Python><A name=pgfId-66416></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-66417></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-66418></A>File "C:\PYTHON\LIB\Numeric.py", line 
157, in fromfunction</P>
<P class=Python><A name=pgfId-66419></A>return apply(function, 
tuple(indices(dimensions)))</P>
<P class=Python><A name=pgfId-66420></A>File "&lt;stdin&gt;", line 2, in 
buggy</P>
<P class=Python><A name=pgfId-66421></A>TypeError: Comparison of multiarray 
objects is not implemented.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-59602></A><A 
name=marker-59606></A>identity()</H6>
<P class=Body><A name=pgfId-59603></A>The simplest array constructor is the <EM 
class=Code>identity(n)</EM> function, which takes a single integer argument and 
returns a square identity array of that size of integers: </P>
<P class=Python><A name=pgfId-35844></A>&gt;&gt;&gt; <EM class=CodeInput>print 
identity(5)</EM> </P>
<P class=Python><A name=pgfId-35845></A>[[1 0 0 0 0]</P>
<P class=Python><A name=pgfId-35846></A>[0 1 0 0 0]</P>
<P class=Python><A name=pgfId-35847></A>[0 0 1 0 0]</P>
<P class=Python><A name=pgfId-35848></A>[0 0 0 1 0]</P>
<P class=Python><A name=pgfId-35849></A>[0 0 0 0 1]]</P>
<P class=Python><A name=pgfId-35850></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(identity(100))</EM> </P>
<P class=Python><A name=pgfId-35851></A><EM class=Emphasis># shows black square 
with a single white diagonal</EM> </P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-35852></A><A name=marker-59607></A>Coercion 
and <A name=marker-59608></A>Casting</H6>
<P class=Body><A name=pgfId-35853></A>We've mentioned the typecodes of arrays, 
and how to create arrays with the right typecode, but we haven't covered what 
happens when arrays with different typecodes interact.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35854></A><A name=marker-59609></A>Automatic 
Coercions and Binary Operations</H6>
<P class=Body><A name=pgfId-35855></A>The rules followed by NumPy when 
performing binary operations on arrays mirror those used by Python in general. 
Operations between numeric and non-numeric types are not allowed (e.g. an array 
of characters can't be added to an array of numbers), and operations between 
mixed number types (e.g. floats and integers, floats and omplex numbers, or in 
the case of NumPy, operations between any two arrays with different numeric 
typecodes) first perform a coercion of the 'smaller' numeric type to the type of 
the `larger' numeric type. Finally, when scalars and arrays are operated on 
together, the scalar is converted to a rank-0 array first. Thus, adding a 
"small" integer to a "large" floating point array is equivalent to first casting 
the integer "up" to the typecode of the array:</P>
<P class=Python><A name=pgfId-35856></A>&gt;&gt;&gt; <EM 
class=CodeInput>arange(0, 1.0, .1) + 12</EM> </P>
<P class=Python><A name=pgfId-35857></A>array([ 12. , 12.1, 12.2, 12.3, 12.4, 
12.5, 12.6, 12.7, 12.8, 12.9])</P>
<P class=Body><A name=pgfId-35858></A>The automatic coercions are described in 
Figure 1. Avoiding upcasting is discussed in <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#29152">Saving 
space</A>.</P>
<P class=Body><A name=pgfId-35862></A><EM class=Code></EM>&nbsp;</P>
<DIV><IMG src="numdoc_files/numdoc-7.gif"> </DIV></DIV></DIV>
<DIV>
<H6 class=Figure><A name=pgfId-35863></A>Up-casts are indicated with arrows. 
Down-casts are allowed by the <EM class=Code>astype()</EM> method, but may 
result in loss of information.</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35864></A>Deliberate up-casting: The asarray 
function</H6>
<P class=Body><A name=pgfId-35865></A>One more array constructor is the <EM 
class=Code>asarray()</EM> function. It is used if you want to have an array of a 
specific typecode and you don't know what typecode array you have (for example, 
in a generic function which can operate on all kinds of arrays, but needs them 
to be converted to complex arrays). If the array it gets as an argument is of 
the right typecode, it will get sent back unchanged. If the array is not of the 
right typecode, each element of the new array will be the result of the coercion 
to the new type of the old elements. <EM class=Code>asarray()</EM> will refuse 
to operate if there might be loss of information -- in other words, <EM 
class=Code>asarray()</EM> only casts 'up'. </P>
<P class=Body><A name=pgfId-35866></A><EM class=Code>asarray</EM> is also used 
when you have a function that operates on arrays, but you want to allow people 
to call it with an arbitrary python sequence object. This gives your function a 
behavior similar to that of most of the builtin functions that operate on 
arrays. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35867></A>The <A 
name=marker-59613></A>typecode value table</H6>
<P class=Body><A name=pgfId-35868></A>The typecodes identifiers (<EM class=Code> 
Float0</EM> , etc.) have as values single-character strings. The mapping between 
typecode and character strings is machine dependent. An example of the 
correspondences between typecode characters and the typecode identifiers for 
32-bit architectures are shown in Table 3-X.</P>
<TABLE border=1>
  <CAPTION>
  <H6 class=TableTitle><A name=pgfId-35871></A>Typecode character/identifier 
  table on a Pentium computer</H6></CAPTION>
  <TBODY>
  <TR>
    <TH>
      <P class=CellHeading><A name=pgfId-35879></A>Character</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-35881></A># of bytes</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-35883></A># of bits</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-35885></A>Identifiers</P></TH></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-35887></A><EM class=Code>D</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35889></A>16</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35891></A>128</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35893></A><EM class=Code>Complex, 
      Complex64</EM> </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-35895></A><EM class=Code>F</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35897></A>8</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35899></A>64</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35901></A><EM class=Code>Complex0, 
      Complex16, Complex32, Complex8</EM> </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-35903></A><EM class=Code>d</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35905></A>8</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35907></A>64</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35909></A><EM class=Code>Float, 
      Float64</EM> </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-35911></A><EM class=Code>f</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35913></A>4</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35915></A>32</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35917></A><EM class=Code>Float0, Float16, 
      Float32, Float8</EM> </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-35919></A><EM class=Code>l</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35921></A>4</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35923></A>32</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35925></A><EM class=Code>Int</EM> 
  </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-35927></A><EM class=Code>1</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35929></A>1</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35931></A>8</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35933></A><EM class=Code>Int0, Int8</EM> 
      </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-35935></A><EM class=Code>s</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35937></A>2</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35939></A>16</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35941></A><EM class=Code>Int16</EM> 
  </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-35943></A><EM class=Code>i</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35945></A>4</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35947></A>32</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-35949></A><EM class=Code>Int32</EM> 
  </P></TD></TR></TBODY></TABLE></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35950></A>Consequences of silent 
upcasting</H6>
<P class=Body><A name=pgfId-35951></A>When dealing with very large arrays of 
floats and if precision is not important (or arrays of small integers), then it 
may be worthwhile to cast the arrays to "small" typecodes, such as <EM 
class=Code>Int8</EM> , <EM class=Code>Int16</EM> or <EM class=Code>Float32</EM> 
. As the standard Python integers and floats correspond to the typecodes <EM 
class=Code>Int32</EM> and <EM class=Code>Float64</EM> , using them in apparently 
"innocent" ways will result in up-casting, which may null the benefit of the use 
of small typecode arrays. For example:</P>
<P class=Python><A name=pgfId-35952></A>&gt;&gt;&gt; <EM 
class=CodeInput>mylargearray.typecode()</EM> </P>
<P class=Python><A name=pgfId-35953></A>'f' # a.k.a. Float32 on a Pentium</P>
<P class=Python><A name=pgfId-35954></A>&gt;&gt;&gt; <EM 
class=CodeInput>mylargearray.itemsize()</EM> </P>
<P class=Python><A name=pgfId-35955></A>4</P>
<P class=Python><A name=pgfId-35956></A>&gt;&gt;&gt; <EM 
class=CodeInput>mylargearray = mylargearray + 1</EM> # 1 is an Int64 on a 
Pentium</P>
<P class=Python><A name=pgfId-35957></A>&gt;&gt;&gt; <EM 
class=CodeInput>mylargearray.typecode()</EM> # see Fig. 1 for explanation.</P>
<P class=Python><A name=pgfId-35958></A>'d'</P>
<P class=Python><A name=pgfId-35959></A>&gt;&gt;&gt; <EM 
class=CodeInput>mylargearray.itemsize()</EM> </P>
<P class=Python><A name=pgfId-35960></A>8</P>
<P class=Body><A name=pgfId-35961></A>Note that the sizes returned by the <EM 
class=Code>itemsize()</EM> method are expressed in bytes.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-68241></A><A name=29152></A>Saving space</H6>
<P class=FirstBody><A name=pgfId-68245></A>Numeric arrays can be created using 
an optional, keyworded argument to the constructor, savespace. If savespace is 
set to 1, Numeric will attempt to avoid the silent upcasting behavior. The 
status of an array can be queried with the spacesaver() method. If 
x.spacesaver() is true, x has its space-saving flag set. The flag can be set 
with the savespace method: x.savespace(1) to set it, x.savespace(0) to clear 
it.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35975></A>Deliberate casts (potentially 
down): the <A name=marker-59617></A>astype method</H6>
<P class=Body><A name=pgfId-35976></A>You may also force NumPy to cast any 
number array to another number array. For example, to take an array of any 
numeric type (IntX or FloatX or ComplexX or UnsignedInt8) and convert it to a 
64-bit float, one can do:</P>
<P class=Python><A name=pgfId-35977></A>&gt;&gt;&gt; <EM 
class=CodeInput>floatarray = otherarray.astype(Float64)</EM> </P>
<P class=Body><A name=pgfId-35978></A>The typecode can be any of the number 
typecodes, "larger" or "smaller". If it is larger, this is a cast-up, as if 
asarray() had been used. If it is smaller, the standard casting rules of the 
underlying language (C) are used, which means that truncation or loss of 
precision can occur:</P>
<P class=Python><A name=pgfId-35979></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-35980></A>[ 0. 0.4 0.8 1.2 1.6]</P>
<P class=Python><A name=pgfId-35981></A>&gt;&gt;&gt; <EM 
class=CodeInput>x.astype(Int)</EM> </P>
<P class=Python><A name=pgfId-35982></A>array([0, 0, 0, 1, 1])</P>
<P class=Body><A name=pgfId-35983></A>If the typecode used with <EM 
class=Code>astype()</EM> is the original array's typecode, then a copy of the 
original array is returned.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-35984></A>Operating on Arrays</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-35985></A>Simple operations </H6>
<P class=Body><A name=pgfId-35986></A>If you have a keen eye, you have noticed 
that some of the previous examples did something new. It added a number to an 
array. Indeed, most Python operations applicable to numbers are directly 
applicable to arrays: </P>
<P class=Python><A name=pgfId-35987></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-35988></A>[1 2 3]</P>
<P class=Python><A name=pgfId-35989></A>&gt;&gt;&gt; <EM class=CodeInput>print a 
* 3</EM> </P>
<P class=Python><A name=pgfId-35990></A>[3 6 9]</P>
<P class=Python><A name=pgfId-35991></A>&gt;&gt;&gt; <EM class=CodeInput>print a 
+ 3</EM> </P>
<P class=Python><A name=pgfId-35992></A>[4 5 6]</P>
<P class=Body><A name=pgfId-35993></A>Note that the mathematical operators 
behave differently depending on the types of their operands. When one of the 
operands is an array and the other is a number, the number is added to all the 
elements of the array and the resulting array is returned. This is called <EM 
class=Emphasis>broadcasting</EM> . This also occurs for unary mathematical 
operations such as sin and the negative sign</P>
<P class=Python><A name=pgfId-35994></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sin(a)</EM> </P>
<P class=Python><A name=pgfId-35995></A>[ 0.84147098 0.90929743 0.14112001]</P>
<P class=Python><A name=pgfId-35996></A>&gt;&gt;&gt; <EM class=CodeInput>print 
-a</EM> </P>
<P class=Python><A name=pgfId-35997></A>[-1 -2 -3]</P>
<P class=Body><A name=pgfId-35998></A>When both elements are arrays with the 
same shape, then a new array is created, where each element is the sum of the 
corresponding elements in the original arrays: </P>
<P class=Python><A name=pgfId-35999></A>&gt;&gt;&gt; <EM class=CodeInput>print a 
+ a</EM> </P>
<P class=Python><A name=pgfId-36000></A>[2 4 6]</P>
<P class=Body><A name=pgfId-36001></A>If the operands of operations such as 
addition are arrays which have the same rank but different non-integer 
dimensions, then an exception is generated: </P>
<P class=Python><A name=pgfId-36002></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36003></A>[1 2 3]</P>
<P class=Python><A name=pgfId-36004></A>&gt;&gt;&gt; <EM class=CodeInput>b = 
array([4,5,6,7])</EM> # note this has four elements</P>
<P class=Python><A name=pgfId-36005></A>&gt;&gt;&gt; <EM class=CodeInput>print a 
+ b</EM> </P>
<P class=Python><A name=pgfId-36006></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-36007></A>File ``&lt;stdin&gt;``, line 1, in ?</P>
<P class=Python><A name=pgfId-36008></A>ArrayError: frames are not aligned</P>
<P class=Body><A name=pgfId-36009></A>This is because there is no reasonable way 
for NumPy to interpret addition of a <EM class=Code>(3,)</EM> shaped array and a 
<EM class=Code>(4,) </EM>shaped array.</P>
<P class=Body><A name=pgfId-36010></A>Note what happens when adding arrays with 
different rank </P>
<P class=Python><A name=pgfId-36011></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36012></A>[1 2 3]</P>
<P class=Python><A name=pgfId-36013></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-36014></A>[[ 4 8 12]</P>
<P class=Python><A name=pgfId-36015></A>[ 5 9 13]</P>
<P class=Python><A name=pgfId-36016></A>[ 6 10 14]</P>
<P class=Python><A name=pgfId-36017></A>[ 7 11 15]]</P>
<P class=Python><A name=pgfId-36018></A>&gt;&gt;&gt; <EM class=CodeInput>print a 
+ b</EM> </P>
<P class=Python><A name=pgfId-36019></A>[[ 5 10 15]</P>
<P class=Python><A name=pgfId-36020></A>[ 6 11 16]</P>
<P class=Python><A name=pgfId-36021></A>[ 7 12 17]</P>
<P class=Python><A name=pgfId-36022></A>[ 8 13 18]]</P>
<P class=Body><A name=pgfId-36023></A>This is another form of broadcasting. To 
understand this, one needs to look carefully at the shapes of <EM 
class=Code>a</EM> and <EM class=Code>b</EM> : </P>
<P class=Python><A name=pgfId-36024></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.shape</EM> </P>
<P class=Python><A name=pgfId-36025></A>(3,)</P>
<P class=Python><A name=pgfId-36026></A>&gt;&gt;&gt; <EM 
class=CodeInput>b.shape</EM> </P>
<P class=Python><A name=pgfId-36027></A>(4,3)</P>
<P class=Body><A name=pgfId-36028></A>Because array <EM class=Code>a</EM> 's 
last dimension had length 3 and array <EM class=Code>b</EM> 's last dimension 
also had length 3, those two dimensions were "matched" and a new dimension was 
created and automatically "assumed" for array a. The data already in <EM 
class=Code>a</EM> was "replicated" as many times as needed (4, in this case) to 
make the two shapes of the operand arrays conform. This replication 
(broadcasting) occurs when arrays are operands to binary operations and their 
shapes differ and when the following conditions are true:</P>
<UL>
  <LI class=BulletLev2><A name=pgfId-36029></A>starting from the last axis, the 
  axis lengths (dimensions) of the operands are compared 
  <LI class=BulletLev2><A name=pgfId-36030></A>if both arrays have an axis 
  length greater than 1, an exception is raised 
  <LI class=BulletLev2><A name=pgfId-36031></A>if one array has an axis length 
  greater than 1, then the other array's axis is "stretched" to match the length 
  of the first axis -- if the other array's axis is not present (i.e., if the 
  other array has smaller rank), then a new axis of the same length is created. 
  </LI></UL>
<P class=Body><A name=pgfId-36032></A>This algorithm is complex, but intuitive 
in practice. For more details, consult the Numeric Reference.</P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36033></A><A name=marker-59618></A>Getting 
and <A name=marker-59619></A>Setting array values</H6>
<P class=Body><A name=pgfId-36034></A>Just like other Python sequences, array 
contents are manipulated with the [] notation. For rank-1 arrays, there are no 
differences between list and array notations:</P>
<P class=Python><A name=pgfId-36035></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arrayrange(10)</EM> </P>
<P class=Python><A name=pgfId-36036></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[0] </EM># get first element</P>
<P class=Python><A name=pgfId-36037></A>0</P>
<P class=Python><A name=pgfId-36038></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[1:5] </EM># get second through fifth element</P>
<P class=Python><A name=pgfId-36039></A>[1 2 3 4]</P>
<P class=Python><A name=pgfId-36040></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[:-1] </EM># get last element</P>
<P class=Python><A name=pgfId-36041></A>9</P>
<P class=Body><A name=pgfId-36042></A>The first difference with lists comes with 
multidimensional indexing. If an array is multidimensional (of rank &gt; 1), 
then specifying a single integer index will return an array of dimension one 
less than the original array. </P>
<P class=Python><A name=pgfId-36043></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arrayrange(9)</EM> </P>
<P class=Python><A name=pgfId-36044></A>&gt;&gt;&gt; <EM class=CodeInput>a.shape 
= (3,3)</EM> </P>
<P class=Python><A name=pgfId-36045></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36046></A>[[0 1 2]</P>
<P class=Python><A name=pgfId-36047></A>[3 4 5]</P>
<P class=Python><A name=pgfId-36048></A>[6 7 8]]</P>
<P class=Python><A name=pgfId-36049></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[0] </EM># get first row, not first element!</P>
<P class=Python><A name=pgfId-36050></A>[0 1 2]</P>
<P class=Python><A name=pgfId-36051></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[1] </EM># get second row</P>
<P class=Python><A name=pgfId-36052></A>[3 4 5]</P>
<P class=Body><A name=pgfId-36053></A>To get to individual elements in a rank-2 
array, one specifies both indices separated by commas:</P>
<P class=Python><A name=pgfId-36054></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[0,0] </EM># get elt at first row, first column</P>
<P class=Python><A name=pgfId-36055></A>0</P>
<P class=Python><A name=pgfId-36056></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[0,1] </EM># get elt at first row, second column</P>
<P class=Python><A name=pgfId-36057></A>1</P>
<P class=Python><A name=pgfId-36058></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[1,0] </EM># get elt at second row, first column</P>
<P class=Python><A name=pgfId-36059></A>3</P>
<P class=Python><A name=pgfId-36060></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[2,-1] </EM># get elt at third row, last column</P>
<P class=Python><A name=pgfId-36061></A>8</P>
<P class=Body><A name=pgfId-36062></A>Of course, the <EM class=Code>[]</EM> 
notation can be used to <EM class=Emphasis>set</EM> values as well: </P>
<P class=Python><A name=pgfId-36063></A>&gt;&gt;&gt; <EM class=CodeInput>a[0,0] 
= 123</EM> </P>
<P class=Python><A name=pgfId-36064></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36065></A>[[123 1 2]</P>
<P class=Python><A name=pgfId-36066></A>[ 3 4 5]</P>
<P class=Python><A name=pgfId-36067></A>[ 6 7 8]]</P>
<P class=Body><A name=pgfId-36068></A>Note that when referring to rows, the 
right hand side of the equal sign needs to be a sequence which "fits" in the 
referred array subset (in the code sample below, a 3-element row):</P>
<P class=Python><A name=pgfId-36069></A>&gt;&gt;&gt; <EM class=CodeInput>a[1] = 
[10,11,12]</EM> </P>
<P class=Python><A name=pgfId-36070></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36071></A>[[123 1 2]</P>
<P class=Python><A name=pgfId-36072></A>[ 10 11 12]</P>
<P class=Python><A name=pgfId-36073></A>[ 6 7 8]]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36074></A><A name=marker-59620></A>Slicing 
Arrays </H6>
<P class=Body><A name=pgfId-36075></A>The standard rules of Python slicing apply 
to arrays, on a per-dimension basis. Assuming a 3x3 array: </P>
<P class=Python><A name=pgfId-36076></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
reshape(arrayrange(9),(3,3))</EM> </P>
<P class=Python><A name=pgfId-36077></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36078></A>[[0 1 2]</P>
<P class=Python><A name=pgfId-36079></A>[3 4 5]</P>
<P class=Python><A name=pgfId-36080></A>[6 7 8]]</P>
<P class=Body><A name=pgfId-36081></A>The plain [<A name=marker-59830></A>:] 
operator slices from beginning to end:</P>
<P class=Python><A name=pgfId-36082></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[:,:]</EM> </P>
<P class=Python><A name=pgfId-36083></A>[[0 1 2]</P>
<P class=Python><A name=pgfId-36084></A>[3 4 5]</P>
<P class=Python><A name=pgfId-36085></A>[6 7 8]]</P>
<P class=Body><A name=pgfId-36086></A>In other words, [:] with no arguments is 
the same as [:] for lists - it can be read ``all indices along this axis. So, to 
get the second row along the second dimension: </P>
<P class=Python><A name=pgfId-36087></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[:,1]</EM> </P>
<P class=Python><A name=pgfId-36088></A>[1 4 7]</P>
<P class=Body><A name=pgfId-36089></A>Note that what was a "column" vector is 
now a "row" vector -- any "integer slice" (as in the 1 in the example above) 
results in a returned array with rank one less than the input array.</P>
<P class=Body><A name=pgfId-36090></A>If one does not specify as many slices as 
there are dimensions in an array, then the remaining slices are assumed to be 
``all''. If <EM class=Code>A</EM> is a rank-3 array, then</P>
<P class=Python><A name=pgfId-36091></A><EM class=Code>A[1] == A[1,:] == 
A[1,:,:]</EM> </P>
<P class=Body><A name=pgfId-36092></A>There is one addition to the slice 
notation for arrays which does not exist for lists, and that is the optional 
third argument, meaning the ``step size'' also called stride or increment. Its 
default value is 1, meaning return every element in the specified range. 
Alternate values allow one to skip some of the elements in the slice: </P>
<P class=Python><A name=pgfId-36093></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(12)</EM> </P>
<P class=Python><A name=pgfId-36094></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36095></A>[ 0 1 2 3 4 5 6 7 8 9 10 11]</P>
<P class=Python><A name=pgfId-36096></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[::2]</EM> <A name=marker-59831></A># return every *other* element</P>
<P class=Python><A name=pgfId-36097></A>[ 0 2 4 6 8 10]</P>
<P class=Body><A name=pgfId-36098></A>Negative strides are allowed as long as 
the starting index is greater than the stopping index:</P>
<P class=Python><A name=pgfId-36099></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
reshape(arrayrange(9),(3,3))</EM> </P>
<P class=Python><A name=pgfId-36100></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36101></A>[[0 1 2]</P>
<P class=Python><A name=pgfId-36102></A>[3 4 5]</P>
<P class=Python><A name=pgfId-36103></A>[6 7 8]]</P>
<P class=Python><A name=pgfId-36104></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[:, 0]</EM> </P>
<P class=Python><A name=pgfId-36105></A>[0 3 6]</P>
<P class=Python><A name=pgfId-36106></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[0:3, 0]</EM> </P>
<P class=Python><A name=pgfId-36107></A>[0 3 6]</P>
<P class=Python><A name=pgfId-36108></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[2:-1, 0]</EM> </P>
<P class=Python><A name=pgfId-36109></A>[6 3 0]</P>
<P class=Body><A name=pgfId-36110></A>If a negative stride is specified and the 
starting or stopping indices are omitted, they default to "end of axis" and 
"beginning of axis" respectively. Thus, the following two statements are 
equivalent for the array given:</P>
<P class=Python><A name=pgfId-36111></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[2:-1, 0]</EM> </P>
<P class=Python><A name=pgfId-36112></A>[6 3 0]</P>
<P class=Python><A name=pgfId-36113></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[::-1, 0]</EM> </P>
<P class=Python><A name=pgfId-36114></A>[6 3 0]</P>
<P class=Python><A name=pgfId-36115></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[::-1]</EM> # this reverses only the first axis</P>
<P class=Python><A name=pgfId-36116></A>[[6 7 8]</P>
<P class=Python><A name=pgfId-36117></A>[3 4 5]</P>
<P class=Python><A name=pgfId-36118></A>[0 1 2]]</P>
<P class=Python><A name=pgfId-36119></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[::-1,::-1]</EM> # this reverses both axes </P>
<P class=Python><A name=pgfId-36120></A>[[8 7 6]</P>
<P class=Python><A name=pgfId-36121></A>[5 4 3]</P>
<P class=Python><A name=pgfId-36122></A>[2 1 0]]</P>
<P class=Body><A name=pgfId-36123></A>One final way of slicing arrays is with 
the keyword <EM class=Code>...</EM> <A name=marker-59821></A>This keyword is 
somewhat complicated. It stands for ``however many `:' I need depending on the 
rank of the object I'm indexing, so that the indices I *do* specify are at the 
end of the index list as opposed to the usual beginning.`` </P>
<P class=Body><A name=pgfId-59823></A>So, if one has a rank-3 array <EM 
class=Code>A</EM> , then <EM class=Code>A[...,0]</EM> is the same thing as <EM 
class=Code>A[:,:,0]</EM> but if <EM class=Code>B</EM> is rank-4, then <EM 
class=Code>B[...,0] </EM>is the same thing as: <EM class=Code>B[:,:,:,0]</EM> . 
Only one <EM class=CodeInput>...</EM> is expanded in an index expression, so if 
one has a rank-5 array <EM class=Code>C</EM> , then: <EM 
class=Code>C[...,0,...]</EM> is the same thing as <EM 
class=Code>C[:,:,:,0,:]</EM> .</P>
<P class=Body><A name=pgfId-36125></A>&nbsp;</P></DIV></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-36126></A>6. <A name=marker-59621></A><A 
name=30906></A>Ufuncs </H2>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36127></A>What are Ufuncs?</H6>
<P class=FirstBody><A name=pgfId-36128></A>The operations on arrays that were 
mentioned in the previous section (element-wise addition, multiplication, etc.) 
all share some features -- they all follow similar rules for broadcasting, 
coercion and "element-wise operation". Just like standard addition is available 
in Python through the add function in the operator module, array operations are 
available through callable objects as well. Thus, the following objects are 
available in the Numeric module:</P>
<TABLE>
  <CAPTION>
  <H6 class=TableTitle><A name=pgfId-36131></A>Universal Functions, or <EM 
  class=Code>ufunc</EM> s. The operators which invoke them when applied to 
  arrays are indicated in parentheses. The entries in slanted typeface refer to 
  unary ufuncs, while the others refer to binary ufuncs.</H6></CAPTION>
  <TBODY>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36139></A><EM class=Code>add (+)</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36141></A><EM class=Code>subtract (-)</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36143></A><EM class=Code>multiply (*)</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36145></A><EM class=Code>divide (/)</EM> 
      </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36147></A><EM class=Code>remainder 
      (%)</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36149></A><EM class=Code>power (**)</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36151></A><EM class=Emphasis>arccos</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36153></A><EM class=Emphasis>arccosh</EM> 
      </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36155></A><EM class=Emphasis>arcsin</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36157></A><EM class=Emphasis>arcsinh</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36159></A><EM class=Emphasis>arctan</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36161></A><EM class=Emphasis>arctanh</EM> 
      </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36163></A><EM class=Emphasis>cos</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36165></A><EM class=Emphasis>cosh</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36167></A><EM class=Emphasis>exp</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36169></A><EM class=Emphasis>log</EM> 
    </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36171></A><EM class=Emphasis>log10</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36173></A><EM class=Emphasis>sin</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36175></A><EM class=Emphasis>sinh</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36177></A><EM class=Emphasis>sqrt</EM> 
    </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36179></A><EM class=Emphasis>tan</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36181></A><EM class=Emphasis>tanh</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36183></A><EM class=Code>maximum</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36185></A><EM class=Code>minimum</EM> 
    </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36187></A><EM 
      class=Emphasis>conjugate</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36189></A><EM class=Code>equal (==)</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36191></A><EM class=Code>not_equal 
      (!=)</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36193></A><EM class=Code>greater 
      (&gt;)</EM> </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36195></A><EM class=Code>greater_equal 
      (&gt;=)</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36197></A><EM class=Code>less (&lt;)</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36199></A><EM class=Code>less_equal 
      (&lt;=)</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36201></A><EM class=Code>logical_and 
      (and)</EM> </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36203></A><EM class=Code>logical_or 
      (or)</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36205></A><EM class=Code>logical_xor</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36207></A><EM class=Code>logical_not 
      (not)</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36209></A><EM class=Code>bitwise_and 
      (&amp;)</EM> </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36211></A><EM class=Code>bitwise_or 
      (|)</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36213></A><EM class=Code>bitwise_xor</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36215></A><EM class=Code>bitwise_not 
      (~)</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36217></A>&nbsp;</P></TD></TR></TBODY></TABLE>
<P class=Body><A name=pgfId-36218></A>All of these ufuncs can be used as 
functions. For example, to use <EM class=Code>add</EM> , which is a binary ufunc 
(i.e. it takes two arguments), one can do either of:</P>
<P class=Python><A name=pgfId-36219></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(10)<BR></EM>&gt;&gt;&gt; <EM class=CodeInput>print add(a,a)</EM> </P>
<P class=Python><A name=pgfId-36220></A>[ 0 2 4 6 8 10 12 14 16 18]</P>
<P class=Python><A name=pgfId-36221></A>&gt;&gt;&gt; <EM class=CodeInput>print a 
+ a</EM> </P>
<P class=Python><A name=pgfId-36222></A>[ 0 2 4 6 8 10 12 14 16 18]</P>
<P class=Body><A name=pgfId-36223></A>In other words, the + operator on arrays 
performs exactly the same thing as the <EM class=Code>add</EM> ufunc when 
operated on arrays. For a unary ufunc such as <EM class=Code>sin</EM> , one can 
do, e.g.:</P>
<P class=Python><A name=pgfId-36224></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(10)<BR></EM>&gt;&gt;&gt; <EM class=CodeInput>print sin(a)</EM> </P>
<P class=Python><A name=pgfId-36225></A>[ 0. 0.84147098 0.90929743 0.14112001 
-0.7568025 -0.95892427</P>
<P class=Python><A name=pgfId-36226></A>-0.2794155 0.6569866 0.98935825 
0.41211849]</P>
<P class=Body><A name=pgfId-36227></A>Unary ufuncs return arrays with the same 
shape as their arguments, but with the contents corresponding to the 
corresponding mathematical function applied to each element (sin(0)=0, 
sin(1)=0.84147098, etc.). </P>
<P class=Body><A name=pgfId-36228></A>There are three additional features of 
ufuncs which make them different from standard Python functions. They can 
operate on any Python sequence in addition to arrays; they can take an "output" 
argument; they have attributes which are themselves callable with arrays and 
sequences. Each of these will be described in turn.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36229></A>Ufuncs can operate on any Python 
sequence</H6>
<P class=FirstBody><A name=pgfId-36230></A>Ufuncs have so far been described as 
callable objects which take either one or two arrays as arguments (depending on 
whether they are unary or binary). In fact, any Python sequence which can be the 
input to the array() constructor can be used. The return value from ufuncs is 
always an array. Thus:</P>
<P class=Python><A name=pgfId-36231></A>&gt;&gt;&gt; <EM 
class=CodeInput>add([1,2,3,4], (1,2,3,4))</EM> </P>
<P class=Python><A name=pgfId-36232></A>array([2, 4, 6, 8])</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36233></A>Ufuncs can take output 
arguments</H6>
<P class=FirstBody><A name=pgfId-36234></A>In many computations with large sets 
of numbers, arrays are often used only once. For example, a computation on a 
large set of numbers could involve the following step</P>
<P class=Python><A name=pgfId-36235></A>dataset = dataset * 1.20</P>
<P class=Body><A name=pgfId-36236></A>This operation as written needs to create 
a temporary array to store the results of the computation, and then eventually 
free the memory used by the original dataset array (provided there are no other 
references to the data it contains). It is more efficient, both in terms of 
memory and computation time, to do an "in-place" operation. This can be done by 
specifying an existing array as the place to store the result of the ufunc. In 
this example, one can write:</P>
<P class=Python><A name=pgfId-36237></A>multiply(dataset, 1.20, dataset)</P>
<P class=Body><A name=pgfId-36238></A>This is not a step to take lightly, 
however. For example, the "big and slow" version (<EM class=Code> dataset = 
dataset * 1.20</EM> ) and the "small and fast" version above will yield 
different results in two cases: </P>
<UL>
  <LI class=BulletLev2><A name=pgfId-36239></A>If the typecode of the target 
  array is not that which would normally be computed, the operation will fail 
  and raise a TypeError exception. 
  <LI class=BulletLev2><A name=pgfId-36240></A>If the target array corresponds 
  to a different "view" on the same data as either of the source arrays, 
  inconsistencies will result. For example, </LI></UL>
<P class=Python><A name=pgfId-36241></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(5, typecode=Float64)</EM> </P>
<P class=Python><A name=pgfId-36242></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a[::-1] * 1.2</EM> </P>
<P class=Python><A name=pgfId-36243></A>[ 4.8 3.6 2.4 1.2 0. ]</P>
<P class=Python><A name=pgfId-36244></A>&gt;&gt;&gt; <EM 
class=CodeInput>multiply(a[::-1], 1.2, a)</EM> </P>
<P class=Python><A name=pgfId-36245></A>array([ 4.8 , 3.6 , 2.4 , 4.32, 
5.76])</P>
<P class=Python><A name=pgfId-36246></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36247></A>[ 4.8 3.6 2.4 4.32 5.76]</P>
<P class=BulletLev2Continuation><A name=pgfId-36248></A>This is because the 
ufunc does not know which arrays share which data, and in this case the 
overwriting of the data contents follows a different path through the shared 
data space of the two arrays, thus resulting in strangely distorted 
data.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36249></A><A name=87042></A>Ufuncs have 
special methods</H6>
<DIV>
<H6 class=FM3Heading><A name=pgfId-36250></A>The reduce ufunc method</H6>
<P class=Body><A name=pgfId-61696></A>If you don't know about the <EM 
class=Code>reduce</EM> command in Python, review section 5.1.1 of the Python 
Tutorial (<EM class=URL> http://www.python.org/doc/tut/functional.html</EM> ). 
Briefly, <EM class=Code>reduce</EM> is most often used with two arguments, a 
callable object (such as a function), and a sequence. It calls the callable 
object with the first two element of the sequence, then with the result of that 
operation and the third element, and so on, returning at the end the successive 
"reduction" of the specified callable object over the sequence elements. 
Similarly, the <EM class=Code>reduce</EM> method of ufuncs is called with a 
sequence as an argument, and performs the reduction of that ufunc on the 
sequence. As an example, adding all of the elements in a rank-1 array can be 
done with:</P>
<P class=Python><A name=pgfId-36251></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1,2,3,4])</EM> </P>
<P class=Python><A name=pgfId-36252></A>&gt;&gt;&gt; <EM class=CodeInput>print 
add.reduce(a)</EM> </P>
<P class=Python><A name=pgfId-36253></A>10 </P>
<P class=Body><A name=pgfId-36254></A>When applied to arrays which are of rank 
greater than one, the reduction proceeds by default along the first axis:</P>
<P class=Python><A name=pgfId-36255></A>&gt;&gt;&gt; <EM class=CodeInput>b = 
array([[1,2,3,4],[6,7,8,9]])</EM> </P>
<P class=Python><A name=pgfId-36256></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-36257></A>[[1 2 3 4]</P>
<P class=Python><A name=pgfId-36258></A>[6 7 8 9]]</P>
<P class=Python><A name=pgfId-36259></A>&gt;&gt;&gt; <EM class=CodeInput>print 
add.reduce(b)</EM> </P>
<P class=Python><A name=pgfId-36260></A>[ 7 9 11 13]</P>
<P class=Body><A name=pgfId-36261></A>A different axis of reduction can be 
specified with a second integer argument:</P>
<P class=Python><A name=pgfId-36262></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-36263></A>[[1 2 3 4]</P>
<P class=Python><A name=pgfId-36264></A>[6 7 8 9]]</P>
<P class=Python><A name=pgfId-36265></A>&gt;&gt;&gt; <EM class=CodeInput>print 
add.reduce(b, 1)</EM> </P>
<P class=Python><A name=pgfId-36266></A>[10 30] </P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-61704></A>The accumulate ufunc method</H6>
<P class=Body><A name=pgfId-36267></A>The <EM class=Code>accumulate</EM> ufunc 
method is simular to <EM class=Code>reduce</EM> , except that it returns an 
array containing the intermediate results of the reduction: </P>
<P class=Python><A name=pgfId-36268></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(10)</EM> </P>
<P class=Python><A name=pgfId-36269></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36270></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-36271></A>&gt;&gt;&gt; <EM class=CodeInput>print 
add.accumulate(a)</EM> </P>
<P class=Python><A name=pgfId-36272></A>[ 0 1 3 6 10 15 21 28 36 45] # 0, 0+1, 
0+1+2, 0+1+2+3, ... 0+...+9</P>
<P class=Python><A name=pgfId-36273></A>&gt;&gt;&gt; <EM class=CodeInput>print 
add.reduce(a)</EM> </P>
<P class=Python><A name=pgfId-36274></A>45 # same as 
add.accumulate(...)[-1]</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-61715></A>The outer ufunc method</H6>
<P class=Body><A name=pgfId-61718></A>The third ufunc method is <EM 
class=Code>outer</EM> , which takes two arrays as arguments and returns the 
"outer ufunc" of the two arguments. Thus the <EM class=Code>outer</EM> method of 
the <EM class=Code>multiply</EM> ufunc, results in the outer product. The outer 
method is only supported for binary methods. </P>
<P class=Python><A name=pgfId-36276></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36277></A>[0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36278></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-36279></A>[0 1 2 3]</P>
<P class=Python><A name=pgfId-36280></A>&gt;&gt;&gt; <EM class=CodeInput>print 
add.outer(a,b)</EM> </P>
<P class=Python><A name=pgfId-36281></A>[[0 1 2 3]</P>
<P class=Python><A name=pgfId-36282></A>[1 2 3 4]</P>
<P class=Python><A name=pgfId-36283></A>[2 3 4 5]</P>
<P class=Python><A name=pgfId-36284></A>[3 4 5 6]</P>
<P class=Python><A name=pgfId-36285></A>[4 5 6 7]]</P>
<P class=Python><A name=pgfId-36286></A>&gt;&gt;&gt; <EM class=CodeInput>print 
multiply.outer(b,a)</EM> </P>
<P class=Python><A name=pgfId-36287></A>[[ 0 0 0 0 0]</P>
<P class=Python><A name=pgfId-36288></A>[ 0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36289></A>[ 0 2 4 6 8]</P>
<P class=Python><A name=pgfId-36290></A>[ 0 3 6 9 12]]</P>
<P class=Python><A name=pgfId-36291></A>&gt;&gt;&gt; <EM class=CodeInput>print 
power.outer(a,b)</EM> </P>
<P class=Python><A name=pgfId-36292></A>[[ 1 0 0 0]</P>
<P class=Python><A name=pgfId-36293></A>[ 1 1 1 1]</P>
<P class=Python><A name=pgfId-36294></A>[ 1 2 4 8]</P>
<P class=Python><A name=pgfId-36295></A>[ 1 3 9 27]</P>
<P class=Python><A name=pgfId-36296></A>[ 1 4 16 64]]</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-61737></A>The reduceat ufunc method</H6>
<P class=Body><A name=pgfId-61738></A>The final ufunc method is the <EM 
class=Code>reduceat</EM> method, which I'd love to explain it, but I don't 
understand it (XXX).</P></DIV></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-61739></A>Ufuncs always return new 
arrays</H6>
<P class=FirstBody><A name=pgfId-36299></A>Except when the 'output' argument are 
used as described above, ufuncs always return new arrays which do not share any 
data with the input array.</P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36300></A>Which are the Ufuncs?</H6>
<P class=Body><A name=pgfId-36301></A>Table 1 lists all the ufuncs. We will 
first discuss the mathematical ufuncs, which perform operations very similar to 
the functions in the <EM class=Code>math</EM> and <EM class=Code>cmath</EM> 
modules, albeit elementwise, on arrays. These come in two forms, unary and 
binary:</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36302></A><A name=marker-59625></A>Unary 
Mathematical Ufuncs (take only one argument) </H6>
<P class=Body><A name=pgfId-36303></A>The following ufuncs apply the predictable 
functions on their single array arguments, one element at a time: <EM 
class=Code>arccos</EM> , <EM class=Code>arccosh</EM> , <EM 
class=Code>arcsin</EM> , <EM class=Code>arcsinh</EM> , <EM 
class=Code>arctan</EM> , <EM class=Code>arctanh</EM> , <EM class=Code>cos</EM> , 
<EM class=Code>cosh</EM> , <EM class=Code>exp</EM> , <EM class=Code>log</EM> , 
<EM class=Code>log10</EM> , <EM class=Code>sin</EM> , <EM class=Code>sinh</EM> , 
<EM class=Code>sqrt</EM> , <EM class=Code>tan</EM> , <EM class=Code>tanh</EM> 
.</P>
<P class=Body><A name=pgfId-36304></A>As an example:</P>
<P class=Python><A name=pgfId-36305></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-36306></A>[0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36307></A>&gt;&gt;&gt; <EM class=CodeInput>print 
cos(x)</EM> </P>
<P class=Python><A name=pgfId-36308></A>[ 1. 0.54030231 -0.41614684 -0.9899925 
-0.65364362]</P>
<P class=Python><A name=pgfId-36309></A>&gt;&gt;&gt; <EM class=CodeInput>print 
arccos(cos(x))</EM> </P>
<P class=Python><A name=pgfId-36310></A>[ 0. 1. 2. 3. 2.28318531]</P>
<P class=Python><A name=pgfId-36311></A># not a bug, but wraparound: 2*pi%4 is 
2.28318531</P>
<P class=Body><A name=pgfId-36312></A>The <EM class=Code>conjugate</EM> ufunc 
takes an array of complex numbers and returns the array with entries which are 
the complex conjugates of the entries in the input array. If it is called with 
real numbers, a copy of the array is returned unchanged.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36313></A>Binary Mathematical Ufuncs</H6>
<P class=Body><A name=pgfId-36314></A>These ufuncs take two arrays as arguments, 
and perform the specified mathematical operation on them, one pair of elements 
at a time: <EM class=Code>add</EM> , <EM class=Code>subtract</EM> , <EM 
class=Code>multiply</EM> , <EM class=Code>divide</EM> , <EM 
class=Code>remainder</EM> , <EM class=Code>power</EM> . </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36315></A><A name=marker-59626></A><A 
name=93991></A>Logical Ufuncs</H6>
<P class=Body><A name=pgfId-36316></A>The ``logical'' ufuncs also perform their 
operations on arrays in elementwise fashion, just like the ``mathematical'' 
ones.</P>
<P class=Body><A name=pgfId-36317></A>Two are special (<EM class=Code> 
maximum</EM> and <EM class=Code>miminum</EM> ) in that they return arrays with 
entries taken from their input arrays:</P>
<P class=Python><A name=pgfId-36318></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-36319></A>[0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36320></A>&gt;&gt;&gt; <EM class=CodeInput>print 
y</EM> </P>
<P class=Python><A name=pgfId-36321></A>[ 2. 2.5 3. 3.5 4. ]</P>
<P class=Python><A name=pgfId-36322></A>&gt;&gt;&gt; <EM class=CodeInput>print 
maximum(x, y)</EM> </P>
<P class=Python><A name=pgfId-36323></A>[ 2. 2.5 3. 3.5 4. ]</P>
<P class=Python><A name=pgfId-36324></A>&gt;&gt;&gt; <EM class=CodeInput>print 
minimum(x, y)</EM> </P>
<P class=Python><A name=pgfId-36325></A>[ 0. 1. 2. 3. 4.]</P>
<P class=Body><A name=pgfId-36326></A>The others all return arrays of 0's or 
1's: <EM class=Code>equal</EM> , <EM class=Code>not_equal</EM> , <EM 
class=Code>greater</EM> , <EM class=Code>greater_equal</EM> , <EM 
class=Code>less</EM> , <EM class=Code>less_equal</EM> , <EM 
class=Code>logical_and</EM> , <EM class=Code>logical_or</EM> , <EM 
class=Code>logical_xor</EM> , <EM class=Code>logical_not</EM> , <EM 
class=Code>bitwise_and</EM> , <EM class=Code>bitwise_or</EM> , <EM 
class=Code>bitwise_xor</EM> , <EM class=Code>bitwise_not</EM> .</P>
<P class=Body><A name=pgfId-36327></A>These are fairly self-explanatory, 
especially with the associated symbols from the standard Python version of the 
same operations in Table 1 above. The <EM class=Code>logical_*</EM> ufuncs 
perform their operations (and, or, etc.) using the truth value of the elements 
in the array (equality to 0 for numbers and the standard truth test for PyObject 
arrays). The <EM class=Code>bitwise_*</EM> ufuncs, on the other hand, can be 
used only with integer arrays (of any word size), and will return integer arrays 
of the larger bit size of the two input arrays:</P>
<P class=Python><A name=pgfId-36328></A>&gt;&gt;&gt; <EM class=CodeInput>x</EM> 
</P>
<P class=Python><A name=pgfId-36329></A>array([7, 7, 0],'1')</P>
<P class=Python><A name=pgfId-36330></A>&gt;&gt;&gt; <EM class=CodeInput>y</EM> 
</P>
<P class=Python><A name=pgfId-36331></A>array([4, 5, 6])</P>
<P class=Python><A name=pgfId-36332></A>&gt;&gt;&gt; <EM 
class=CodeInput>bitwise_and(x,y)</EM> </P>
<P class=Python><A name=pgfId-36333></A>array([4, 5, 0],'i')</P>
<P class=Body><A name=pgfId-36334></A>We've already discussed how to find out 
about the contents of arrays based on the indices in the arrays - that's what 
the various slice mechanisms are for. Often, especially when dealing with the 
result of computations or data analysis, one needs to ``pick out'' parts of 
matrices based on the content of those matrices. For example, it might be useful 
to find out which elements of an array are negative, and which are positive. The 
comparison ufuncs are designed for just this type of operation. Assume an array 
with various positive and negative numbers in it (for the sake of the example 
we'll generate it from scratch): </P>
<P class=Python><A name=pgfId-36335></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36336></A>[[ 0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36337></A>[ 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-36338></A>[10 11 12 13 14]</P>
<P class=Python><A name=pgfId-36339></A>[15 16 17 18 19]</P>
<P class=Python><A name=pgfId-36340></A>[20 21 22 23 24]]</P>
<P class=Python><A name=pgfId-36341></A>&gt;&gt;&gt; <EM class=CodeInput>b = 
sin(a)</EM> </P>
<P class=Python><A name=pgfId-36342></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-36343></A>[[ 0. 0.84147098 0.90929743 0.14112001 
-0.7568025 ]</P>
<P class=Python><A name=pgfId-36344></A>[-0.95892427 -0.2794155 0.6569866 
0.98935825 0.41211849]</P>
<P class=Python><A name=pgfId-36345></A>[-0.54402111 -0.99999021 -0.53657292 
0.42016704 0.99060736]</P>
<P class=Python><A name=pgfId-36346></A>[ 0.65028784 -0.28790332 -0.96139749 
-0.75098725 0.14987721]</P>
<P class=Python><A name=pgfId-36347></A>[ 0.91294525 0.83665564 -0.00885131 
-0.8462204 -0.90557836]]</P>
<P class=Python><A name=pgfId-36348></A>&gt;&gt;&gt; <EM class=CodeInput>print 
less_equal(b, 0)</EM> </P>
<P class=Python><A name=pgfId-36349></A>[[1 0 0 0 1]</P>
<P class=Python><A name=pgfId-36350></A>[1 1 0 0 0]</P>
<P class=Python><A name=pgfId-36351></A>[1 1 1 0 0]</P>
<P class=Python><A name=pgfId-36352></A>[0 1 1 1 0]</P>
<P class=Python><A name=pgfId-36353></A>[0 0 1 1 1]]</P>
<P class=Body><A name=pgfId-36354></A>This last example has 1's where the 
corresponding elements are less than or equal to 0, and 0's everywhere else.</P>
<P class=Python><A name=pgfId-36355></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(greater(greeceBW, .3))</EM> </P>
<P class=Python><A name=pgfId-36356></A><EM class=Emphasis># shows a binary 
image with white where the pixel value was greater than .3</EM> </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36357></A><A name=marker-59630></A>Ufunc 
shorthands</H6>
<P class=Body><A name=pgfId-36358></A><EM class=Code>Numeric</EM> defines a few 
functions which correspond to often-used uses of ufuncs: for example, <EM 
class=Code>add.reduce()</EM> is synonymous with the <EM class=Code>sum()</EM> 
utility function: </P>
<P class=Python><A name=pgfId-36359></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(5) </EM><EM class=Emphasis># [0 1 2 3 4]</EM> </P>
<P class=Python><A name=pgfId-36360></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sum(a) </EM><EM class=Emphasis># 0 + 1 + 2 + 3 + 4</EM> </P>
<P class=Python><A name=pgfId-36361></A>10</P>
<P class=Body><A name=pgfId-36362></A>Similarly, <EM class=Code>cumsum</EM> is 
equivalent to <EM class=Code>add.accumulate</EM> (for ``cumulative sum``), <EM 
class=Code>product</EM> to <EM class=Code>multiply.reduce</EM> , and <EM 
class=Code>cumproduct</EM> to <EM class=Code>multiply.accumulate</EM> .</P>
<P class=Body><A name=pgfId-36363></A>Additional ``utility'' functions which are 
often useful are <EM class=Code>alltrue</EM> and <EM class=Code>sometrue</EM> , 
which are defined as <EM class=Code>logical_and.reduce</EM> and <EM 
class=Code>logical_or.reduce</EM> respectively:</P>
<P class=Python><A name=pgfId-36364></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([0,1,2,3,4])</EM> </P>
<P class=Python><A name=pgfId-36365></A>&gt;&gt;&gt; <EM class=CodeInput>print 
greater(a,0)</EM> </P>
<P class=Python><A name=pgfId-36366></A>[0 1 1 1 1]</P>
<P class=Python><A name=pgfId-36367></A>&gt;&gt;&gt; <EM 
class=CodeInput>alltrue(greater(a,0)) </EM></P>
<P class=Python><A name=pgfId-36368></A>0</P>
<P class=Python><A name=pgfId-36369></A>&gt;&gt;&gt; <EM 
class=CodeInput>sometrue(greater(a,0))</EM> </P>
<P class=Python><A name=pgfId-36370></A>1</P></DIV></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-36371></A>7. <A name=marker-59631></A><A 
name=21398></A>Pseudo Indices</H2>
<P class=ChapterDescription><A name=pgfId-51714></A>Tbis chapter discusses 
pseudo-indices, which allow arrays to have their shapes modified by adding axes, 
sometimes only for the duration of the evaluation of a Python expression.</P>
<P class=Body><A name=pgfId-36372></A>Consider multiplication of a rank-1 array 
by a scalar: </P>
<P class=Python><A name=pgfId-36373></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1,2,3])</EM> </P>
<P class=Python><A name=pgfId-36374></A>&gt;&gt;&gt; <EM class=CodeInput>a * 
2</EM> </P>
<P class=Python><A name=pgfId-36375></A>[2 4 6]</P>
<P class=Body><A name=pgfId-36376></A>This should be trivial to you by now. 
We've just multiplied a rank-1 array by a scalar (which is converted to a rank-0 
array). In other words, the rank-0 array was broadcast to the next rank. This 
works for adding some two rank-1 arrays as well: </P>
<P class=Python><A name=pgfId-36377></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36378></A>[1 2 3]</P>
<P class=Python><A name=pgfId-36379></A>&gt;&gt;&gt; <EM class=CodeInput>a + 
array([4])</EM> </P>
<P class=Python><A name=pgfId-36380></A>[5 6 7]</P>
<P class=Body><A name=pgfId-36381></A>but it won't work if either of the two 
rank-1 arrays have non-matching dimensions which aren't 1 - put another way, 
broadcast only works for dimensions which are either missing (e.g. a lower-rank 
array) or for dimensions of 1. </P>
<P class=Body><A name=pgfId-36382></A>With this in mind, consider a classic 
task, matrix multiplication. Suppose we want to multiply the row vector [10,20] 
by the column vector [1,2,3]. </P>
<P class=Python><A name=pgfId-36383></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([10,20])</EM> </P>
<P class=Python><A name=pgfId-36384></A>&gt;&gt;&gt; <EM class=CodeInput>b = 
array([1,2,3])</EM> </P>
<P class=Python><A name=pgfId-36385></A>&gt;&gt;&gt; <EM class=CodeInput>a * 
b</EM> </P>
<P class=Python><A name=pgfId-36386></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-36387></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-36388></A>ValueError: frames are not aligned 
example </P>
<P class=Body><A name=pgfId-36389></A>This makes sense - we're trying to 
multiply a rank-1 array of shape (2,) with a rank-1 array of shape (3,). This 
violates the laws of broadcast. What we really want to do is make the second 
vector a vector of shape (3,1), so that the first vector can be broadcast 
accross the second axis of the second vector. One way to do this is to use the 
reshape function: </P>
<P class=Python><A name=pgfId-36390></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.shape</EM> </P>
<P class=Python><A name=pgfId-36391></A>(2,)</P>
<P class=Python><A name=pgfId-36392></A>&gt;&gt;&gt; <EM 
class=CodeInput>b.shape</EM> </P>
<P class=Python><A name=pgfId-36393></A>(3,)</P>
<P class=Python><A name=pgfId-36394></A>&gt;&gt;&gt; <EM class=CodeInput>b2 = 
reshape(b, (3,1))</EM> </P>
<P class=Python><A name=pgfId-36395></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b2</EM> </P>
<P class=Python><A name=pgfId-36396></A>[[1]</P>
<P class=Python><A name=pgfId-36397></A>[2]</P>
<P class=Python><A name=pgfId-36398></A>[3]]</P>
<P class=Python><A name=pgfId-36399></A>&gt;&gt;&gt; <EM 
class=CodeInput>b2.shape</EM> </P>
<P class=Python><A name=pgfId-36400></A>(3, 1)</P>
<P class=Python><A name=pgfId-36401></A>&gt;&gt;&gt; <EM class=CodeInput>print a 
* b2</EM> </P>
<P class=Python><A name=pgfId-36402></A>[[10 20]</P>
<P class=Python><A name=pgfId-36403></A>[20 40]</P>
<P class=Python><A name=pgfId-36404></A>[30 60]]</P>
<P class=Body><A name=pgfId-36405></A>This is such a common operation that a 
special feature was added (it turns out to be useful in many other places as 
well) - the <EM class=Code>NewAxis</EM> <A 
name=marker-59833></A>``pseudo-index'', originally developed in the Yorick 
language. <EM class=Code>NewAxis</EM> is an index, just like integers, so it is 
used inside of the slice brackets []. It can be thought of as meaning ``add a 
new axis here,'' in much the same ways as adding a 1 to an array's shape adds an 
axis. Again, examples help clarify the situation: </P>
<P class=Python><A name=pgfId-36406></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-36407></A>[1 2 3]</P>
<P class=Python><A name=pgfId-36408></A>&gt;&gt;&gt; <EM 
class=CodeInput>b.shape</EM> </P>
<P class=Python><A name=pgfId-36409></A>(3,)</P>
<P class=Python><A name=pgfId-36410></A>&gt;&gt;&gt; <EM class=CodeInput>c = 
b[:, NewAxis]</EM> </P>
<P class=Python><A name=pgfId-36411></A>&gt;&gt;&gt; <EM class=CodeInput>print 
c</EM> </P>
<P class=Python><A name=pgfId-36412></A>[[1]</P>
<P class=Python><A name=pgfId-36413></A>[2]</P>
<P class=Python><A name=pgfId-36414></A>[3]]</P>
<P class=Python><A name=pgfId-36415></A>&gt;&gt;&gt; <EM 
class=CodeInput>c.shape</EM> </P>
<P class=Python><A name=pgfId-36416></A>(3,1) </P>
<P class=Body><A name=pgfId-36417></A>Why use such a pseudo-index over the 
reshape function or shape assignments? Often one doesn't really want a new array 
with a new axis, one just wants it for an intermediate computation. Witness the 
array multiplication mentioned above, without and with pseudo-indices: </P>
<P class=Python><A name=pgfId-36418></A>&gt;&gt;&gt; <EM class=CodeInput>without 
= a * reshape(b, (3,1))</EM> </P>
<P class=Python><A name=pgfId-36419></A>&gt;&gt;&gt; <EM class=CodeInput>with = 
a * b[:,NewAxis]</EM> </P>
<P class=Body><A name=pgfId-36420></A>The second is much more readable (once you 
understand how <EM class=Code>NewAxis</EM> works), and it's much closer to the 
intended meaning. Also, it's independent of the dimensions of the array b You 
might counter that using something like <EM class=Code>reshape(b, (-1,1))</EM> 
is also dimension-independent, but 1) would you argue that it's as readable? 2) 
how would you deal with rank-3 or rank-N arrays? The <EM class=Code>NewAxis</EM> 
-based idiom also works nicely with higher rank arrays, and with the <EM 
class=Code>...</EM> ``rubber index'' mentioned earlier. Adding an axis before 
the last axis in an array can be done simply with: </P>
<P class=Python><A name=pgfId-36421></A>&gt;&gt;&gt; <EM 
class=CodeInput>a[...,NewAxis,:]</EM> </P></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-36422></A>8. <A name=marker-59632></A><A 
name=28351></A>Array Functions </H2>
<P class=Body><A name=pgfId-36423></A>Most of the useful manipulations on arrays 
are done with functions. This might be surprising given Python's object-oriented 
framework, and that many of these functions could have been implemented using 
methods instead. Choosing functions means that the same procedures can be 
applied to arbitrary python sequences, not just to arrays. For example, while 
<EM class=Code>transpose([[1,2],[3,4]])</EM> works just fine, <EM 
class=Code>[[1,2],[3,4]].transpose()</EM> can't work. This approach also allows 
uniformity in interface between functions defined in the Numeric Python system, 
whether implemented in C or in Python, and functions defined in extension 
modules. The use of array methods is limited to functionality which depends 
critically on the implementation details of array objects. Array methods are 
discussed in the next chapter. </P>
<P class=Body><A name=pgfId-36424></A>We've already covered two functions which 
operate on arrays, <EM class=Code>reshape</EM> and <EM class=Code>resize</EM> 
.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36425></A><A name=marker-59633></A>take(a, 
indices, axis=0) </H6>
<P class=Body><A name=pgfId-36426></A><EM class=Code>take</EM> is in some ways 
like the slice operations. It selects the elements of the array it gets as first 
argument based on the indices it gets as a second argument. Unlike slicing, 
however, the array returned by <EM class=Code>take</EM> has the same rank as the 
input array. This is again much easier to understand with an illustration: </P>
<P class=Python><A name=pgfId-36427></A>&nbsp;</P>
<P class=Python><A name=pgfId-36428></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36429></A>[[ 0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36430></A>[ 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-36431></A>[10 11 12 13 14]</P>
<P class=Python><A name=pgfId-36432></A>[15 16 17 18 19]]</P>
<P class=Python><A name=pgfId-36433></A>&gt;&gt;&gt; <EM class=CodeInput>print 
take(a, (0,))</EM> # first row </P>
<P class=Python><A name=pgfId-36434></A>[ [0 1 2 3 4]]</P>
<P class=Python><A name=pgfId-36435></A>&gt;&gt;&gt; <EM class=CodeInput>print 
take(a, (0,1))</EM> # first and second row</P>
<P class=Python><A name=pgfId-36436></A>[[0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36437></A>[5 6 7 8 9]]</P>
<P class=Python><A name=pgfId-36438></A>&gt;&gt;&gt; <EM class=CodeInput>print 
take(a, (0,-1))</EM> # first and last row</P>
<P class=Python><A name=pgfId-36439></A>[[ 0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36440></A>[15 16 17 18 19]]</P>
<P class=Body><A name=pgfId-36441></A>The optional third argument specifies the 
axis along which the selection occurs, and the default value (as in the examples 
above) is 0, the first axis. If you want another axis, then you can specify it: 
</P>
<P class=Python><A name=pgfId-36442></A>&gt;&gt;&gt; <EM class=CodeInput>print 
take(a, (0,), 1)</EM> # first column</P>
<P class=Python><A name=pgfId-36443></A>[[ 0]</P>
<P class=Python><A name=pgfId-36444></A>[ 5]</P>
<P class=Python><A name=pgfId-36445></A>[10]</P>
<P class=Python><A name=pgfId-36446></A>[15]]</P>
<P class=Python><A name=pgfId-36447></A>&gt;&gt;&gt; <EM class=CodeInput>print 
take(a, (0,1), 1)</EM> # first and second column</P>
<P class=Python><A name=pgfId-36448></A>[[ 0 1]</P>
<P class=Python><A name=pgfId-36449></A>[ 5 6]</P>
<P class=Python><A name=pgfId-36450></A>[10 11]</P>
<P class=Python><A name=pgfId-36451></A>[15 16]]</P>
<P class=Python><A name=pgfId-36452></A>&gt;&gt;&gt; <EM class=CodeInput>print 
take(a, (0,-1), 1)</EM> # first and last column</P>
<P class=Python><A name=pgfId-36453></A>[[ 0 4]</P>
<P class=Python><A name=pgfId-36454></A>[ 5 9]</P>
<P class=Python><A name=pgfId-36455></A>[10 14]</P>
<P class=Python><A name=pgfId-36456></A>[15 19]]</P>
<P class=Body><A name=pgfId-61744></A>This is considered to be a ``structural'' 
operation, because its result does not depend on the content of the arrays or 
the result of a computation on those contents but uniquely on the structure of 
the array. Like all such structural operations, the default axis is 0 (the first 
rank). I mention it here because later in this tutorial, we will see functions 
which have a default axis of -1. </P>
<P class=Body><A name=pgfId-61745></A>Take is often used to create 
multidimensional arrays with the indices from a rank-1 array. As in the earlier 
examples, the shape of the array returned by <EM class=Code>take()</EM> is a 
combination of the shape of its first argument and the shape of the array that 
elements are "taken" from -- when that array is rank-1, the shape of the 
returned array has the same shape as the index sequence. This, as with many 
other facets of Numeric, is best understood by experiment.</P>
<P class=Python><A name=pgfId-36459></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
arange(10) * 100</EM> </P>
<P class=Python><A name=pgfId-36460></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-36461></A>[ 0 100 200 300 400 500 600 700 800 
900]</P>
<P class=Python><A name=pgfId-36462></A>&gt;&gt;&gt; <EM class=CodeInput>print 
take(x, [[2,4],[1,2]])</EM> </P>
<P class=Python><A name=pgfId-36463></A>[[200 400]</P>
<P class=Python><A name=pgfId-36464></A>[100 200]]</P>
<P class=Body><A name=pgfId-36465></A>A typical example of using <EM 
class=Code>take()</EM> is to replace the grey values in an image according to a 
"translation table". For example, let's consider a brightening of a greyscale 
image. The <EM class=Code>view()</EM> function defined in the NumTut package 
automatically scales the input arrays to use the entire range of grey values, 
except if the input arrays are of typecode <EM class=Code>'b'</EM> unsigned 
bytes -- thus to test this brightening function, we'll first start by converting 
the greyscale floating point array to a greyscale byte array:</P>
<P class=Python><A name=pgfId-36466></A>&gt;&gt;&gt; <EM class=CodeInput>BW = 
(greeceBW*256).astype('b')</EM> </P>
<P class=Python><A name=pgfId-36467></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(BW)</EM> # shows black and white picture</P>
<P class=Body><A name=pgfId-36468></A>We then create a table mapping the 
integers 0-255 to integers 0-255 using a "compressive nonlinearity":</P>
<P class=Python><A name=pgfId-36469></A>&gt;&gt;&gt; <EM class=CodeInput>table = 
(255- arange(256)**2 / 256).astype('b')</EM> </P>
<P class=Python><A name=pgfId-36470></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(table)</EM> # shows the conversion curve</P>
<P class=Body><A name=pgfId-36471></A>To do the "taking" into an array of the 
right kind, we first create a blank image array with the same shape and typecode 
as the original array:</P>
<P class=Python><A name=pgfId-36472></A>&gt;&gt;&gt; <EM class=CodeInput>BW2 = 
zeros(BW.shape, BW.typecode())</EM> </P>
<P class=Body><A name=pgfId-36473></A>and then perform the take() operation</P>
<P class=Python><A name=pgfId-36474></A>&gt;&gt;&gt; <EM 
class=CodeInput>BW2.flat[:] = take(table, BW.flat)</EM> </P>
<P class=Python><A name=pgfId-36475></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(BW2)</EM> </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-78510></A><A name=marker-78558></A><A 
name=marker-78559></A>put (a, indices, values)</H6>
<P class=FirstBody><A name=pgfId-78514></A><EM class=Code>put</EM> is the 
opposite of <EM class=Code>take</EM> . The values of the array <EM 
class=Code>a</EM> at the locations specified in <EM class=Code>indices</EM> are 
set to the corresponding value of <EM class=Code>values</EM> . The array <EM 
class=Code>a </EM>must be a contiguous array. The argument indices can be any 
integer sequence object with values suitable for indexing into the flat form of 
<EM class=Code>a</EM> . The argument <EM class=Code>values</EM> must be any 
sequence of values that can be converted to the typecode of <EM 
class=Code>a</EM> .</P>
<P class=Python><A name=pgfId-78614></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
arange(6)</EM> </P>
<P class=Python><A name=pgfId-78615></A>&gt;&gt;&gt; <EM class=CodeInput>put(x, 
[2,4], [20,40])</EM> </P>
<P class=Python><A name=pgfId-78616></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-78617></A>[ 0 1 20 3 40 5]</P>
<P class=Body><A name=pgfId-78623></A>Note that the target array <EM 
class=Code>a</EM> is not required to be one-dimensional. Since <EM 
class=Code>a</EM> is contiguous and stored in row-major order, the array <EM 
class=Code>indices</EM> can be treated as indexing <EM class=Code>a</EM> 's 
elements in storage order. </P>
<P class=Body><A name=pgfId-78545></A>The routine <EM class=Code>put</EM> is 
thus equivalent to the following (although the loop is in C for speed):</P>
<P class=Python><A name=pgfId-78546></A>ind = array(indices, copy=0)</P>
<P class=Python><A name=pgfId-78550></A>v = array(values, 
copy=0).astype(a.typecode())</P>
<P class=Python><A name=pgfId-78551></A>for i in len(ind): a.flat[i] = 
v[i]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-84177></A>putmask (a, mask, values)</H6>
<P class=FirstBody><A name=pgfId-84185></A>putmask sets those elements of <EM 
class=Code>a</EM> for which <EM class=Code>mask</EM> is true to the 
corresponding <EM class=Code>value</EM> in values. The array a must be 
contiguous. The argument <EM class=Code>mask</EM> must be an integer sequence of 
the same size (but not necessarily the same shape) as <EM class=Code>a</EM> . 
The argument <EM class=Code>values</EM> will be repeated as necessary; in 
particular it can be a scalar. The array <EM class=Code>values</EM> must be 
convertible to the type of <EM class=Code>a</EM> .</P></DIV>
<DIV>
<H6 class=Code><A name=pgfId-84210></A>&gt;&gt;&gt; <EM 
class=CodeInput>x=arange(5) </EM></H6></DIV>
<DIV>
<H6 class=Code><A name=pgfId-84211></A>&gt;&gt;&gt; <EM 
class=CodeInput>putmask(x, [1,0,1,0,1], [10,20,30,40,50])</EM> </H6></DIV>
<DIV>
<H6 class=Code><A name=pgfId-84212></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </H6></DIV>
<DIV>
<H6 class=Code><A name=pgfId-84213></A>[10 1 30 3 50]</H6></DIV>
<DIV>
<H6 class=Code><A name=pgfId-84214></A>&gt;&gt;&gt; <EM class=Code>putmask(x, 
[1,0,1,0,1], [-1,-2])</EM> </H6></DIV>
<DIV>
<H6 class=Code><A name=pgfId-84215></A>&gt;&gt;&gt; print x</H6></DIV>
<DIV>
<H6 class=Code><A name=pgfId-84216></A><EM class=CodeInput>[-1 1 -1 3 -1]</EM> 
</H6>
<P class=Body><A name=pgfId-84204></A>Note how in the last example, the third 
argument was treated as if it was [-1, -2, -1, -2, -1].</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36476></A><A 
name=marker-59634></A>transpose(a, axes=None) </H6>
<P class=Body><A name=pgfId-36477></A><EM class=Code>transpose</EM> takes an 
array and returns a new array which corresponds to a with the order of axes 
specified by the second argument. The default corresponds to flipping the order 
of all the axes (it is equivalent to <EM class=Code>a.shape[::-1]</EM> if a is 
the input array). </P>
<P class=Python><A name=pgfId-36478></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36479></A>[[ 0 1 2 3 4]</P>
<P class=Python><A name=pgfId-36480></A>[ 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-36481></A>[10 11 12 13 14]</P>
<P class=Python><A name=pgfId-36482></A>[15 16 17 18 19]]</P>
<P class=Python><A name=pgfId-36483></A>&gt;&gt;&gt; <EM class=CodeInput>print 
transpose(a)</EM> </P>
<P class=Python><A name=pgfId-36484></A>[[ 0 5 10 15]</P>
<P class=Python><A name=pgfId-36485></A>[ 1 6 11 16]</P>
<P class=Python><A name=pgfId-36486></A>[ 2 7 12 17]</P>
<P class=Python><A name=pgfId-36487></A>[ 3 8 13 18]</P>
<P class=Python><A name=pgfId-36488></A>[ 4 9 14 19]]</P>
<P class=Python><A name=pgfId-36489></A>&gt;&gt;&gt; <EM 
class=CodeInput>greece.shape</EM> # it's a 355x242 RGB picture<BR>(355, 242, 
3)</P>
<P class=Python><A name=pgfId-36490></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(greece)</EM> </P>
<P class=Python><A name=pgfId-36491></A><EM class=Emphasis># picture of greek 
street is shown</EM> </P>
<P class=Python><A name=pgfId-36492></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(transpose(greece, (1,0,2)))</EM> <EM class=Emphasis># swap 
x and y, not color axis!</EM> </P>
<P class=Python><A name=pgfId-36493></A><EM class=Emphasis># picture of greek 
street is shown sideways</EM> </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36494></A><A name=marker-59635></A>repeat(a, 
repeats, axis=0) </H6>
<P class=Body><A name=pgfId-36495></A><EM class=Code>repeat</EM> takes an array 
and returns an array with each element in the input array repeated as often as 
indicated by the corresponding elements in the second array. It operates along 
the specified axis. So, to stretch an array evenly, one needs the repeats array 
to contain as many instances of the integer scaling factor as the size of the 
specified axis:</P>
<P class=Python><A name=pgfId-36496></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(repeat(greece, 2*ones(greece.shape[0])))</EM> # double in 
X</P>
<P class=Python><A name=pgfId-36497></A>&gt;&gt;&gt; <EM 
class=CodeInput>view(repeat(greece, 2*ones(greece.shape[1]), 1))</EM> # double 
in Y</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36498></A><A name=marker-59484></A>choose(a, 
(b0, ..., bn)) </H6>
<P class=Body><A name=pgfId-36499></A>a is an array of integers between 0 and n. 
The resulting array will have the same shape as a, with element selected from 
b0,...,bn as indicating by the value of the corresponding element in a. </P>
<P class=Body><A name=pgfId-36500></A>Assume a is an array <EM class=Code>a</EM> 
that you want to ``clip'' so that no values are greater than 100.0. </P>
<P class=Python><A name=pgfId-36501></A>&gt;&gt;&gt; <EM 
class=CodeInput>choose(greater(a, 100.0), (a, 100.0)) </EM></P>
<P class=Body><A name=pgfId-36502></A>Everywhere that greater(a, 100.0) is false 
(ie. 0) this will ``choose'' the corresponding value in a. Everywhere else it 
will ``choose'' 100.0. </P>
<P class=Body><A name=pgfId-36503></A>This works as well with arrays. Try to 
figure out what the following does: </P>
<P class=Python><A name=pgfId-36504></A>&gt;&gt;&gt; <EM class=CodeInput>ret = 
choose(greater_than(a,b), (c,d)) </EM></P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36512></A><A name=marker-59485></A>ravel(a) 
</H6>
<P class=Body><A name=pgfId-36513></A>returns the argument array <EM 
class=Code>a</EM> as a 1d array. It is equivalent to <EM class=Code>reshape(a, 
(-1,))</EM> or <EM class=Code>a.flat</EM> . Unlike <EM class=Code>a.flat</EM> , 
however, <EM class=Code>ravel</EM> works with non-contiguous arrays.</P>
<P class=Python><A name=pgfId-58221></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-58222></A>[[ 0 1 2 3]</P>
<P class=Python><A name=pgfId-58223></A>[ 5 6 7 8]</P>
<P class=Python><A name=pgfId-58224></A>[10 11 12 13]]</P>
<P class=Python><A name=pgfId-58225></A>&gt;&gt;&gt; <EM 
class=CodeInput>x.iscontiguous()</EM> </P>
<P class=Python><A name=pgfId-58226></A>0</P>
<P class=Python><A name=pgfId-58227></A>&gt;&gt;&gt; <EM 
class=CodeInput>x.flat</EM> </P>
<P class=Python><A name=pgfId-58228></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-58229></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-58230></A>ValueError: flattened indexing only 
available for contiguous array</P>
<P class=Python><A name=pgfId-58231></A>&gt;&gt;&gt; <EM 
class=CodeInput>ravel(x)</EM> </P>
<P class=Python><A name=pgfId-58066></A>array([ 0, 1, 2, 3, 5, 6, 7, 8, 10, 11, 
12, 13])</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58067></A><A name=marker-59636></A>nonzero(a) 
</H6>
<P class=Body><A name=pgfId-58068></A>nonzero() returns an array containing the 
indices of the elements in a that are nonzero. These indices only make sense for 
1d arrays, so the function refuses to act on anything else. As of 1.0a5 this 
function does not work for complex arrays. </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36518></A><A 
name=marker-59637></A>where(condition, x, y) </H6>
<P class=Body><A name=pgfId-36519></A>where(condition,x,y) returns an array 
shaped like condition and has elements of x and y where condition is 
respectively true or false </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36520></A><A 
name=marker-59638></A>compress(condition, a, axis=0) </H6>
<P class=Body><A name=pgfId-36521></A>returns those elements of a corresponding 
to those elements of condition that are nonzero. condition must be the same size 
as the given axis of a. </P>
<P class=Python><A name=pgfId-58079></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-58080></A>[0 1 2 3]</P>
<P class=Python><A name=pgfId-58085></A>&gt;&gt;&gt; <EM class=CodeInput>print 
greater(x, 2)</EM> </P>
<P class=Python><A name=pgfId-58086></A>[0 0 0 1]</P>
<P class=Python><A name=pgfId-58087></A>&gt;&gt;&gt; <EM class=CodeInput>print 
compress(greater(x, 2), x)</EM> </P>
<P class=Python><A name=pgfId-58077></A>[3]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58163></A><A 
name=marker-59639></A>diagonal(a, k=0) </H6>
<P class=Body><A name=pgfId-58164></A>returns the entries along the k th 
diagonal of a (k is an offset from the main diagonal). This is designed for 2d 
arrays. For larger arrays, it will return the diagonal of each 2d sub-array.</P>
<P class=Python><A name=pgfId-58174></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-58175></A>[[ 0 1 2 3 4]</P>
<P class=Python><A name=pgfId-58176></A>[ 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-58177></A>[10 11 12 13 14]</P>
<P class=Python><A name=pgfId-58178></A>[15 16 17 18 19]</P>
<P class=Python><A name=pgfId-58179></A>[20 21 22 23 24]]</P>
<P class=Python><A name=pgfId-58180></A>&gt;&gt;&gt; <EM class=CodeInput>print 
diagonal(x)</EM> </P>
<P class=Python><A name=pgfId-58181></A>[ 0 6 12 18 24]</P>
<P class=Python><A name=pgfId-58182></A>&gt;&gt;&gt; <EM class=CodeInput>print 
diagonal(x, 1)</EM> </P>
<P class=Python><A name=pgfId-58183></A>[ 1 7 13 19]</P>
<P class=Python><A name=pgfId-58184></A>&gt;&gt;&gt; <EM class=CodeInput>print 
diagonal(x, -1)</EM> </P>
<P class=Python><A name=pgfId-58169></A>[ 5 11 17 23]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36523></A><A name=marker-59640></A>trace(a, 
k=0) </H6>
<P class=Body><A name=pgfId-36524></A>returns the sum of the elements in a along 
the k th diagonal. </P>
<P class=Python><A name=pgfId-58119></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-58120></A>[[ 0 1 2 3 4]</P>
<P class=Python><A name=pgfId-58121></A>[ 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-58122></A>[10 11 12 13 14]</P>
<P class=Python><A name=pgfId-58123></A>[15 16 17 18 19]</P>
<P class=Python><A name=pgfId-58124></A>[20 21 22 23 24]]</P>
<P class=Python><A name=pgfId-58125></A>&gt;&gt;&gt; <EM class=CodeInput>print 
trace(x) </EM><EM class=Emphasis># 0 + 6 + 12 + 18 + 24</EM> </P>
<P class=Python><A name=pgfId-58126></A>60</P>
<P class=Python><A name=pgfId-58127></A>&gt;&gt;&gt; <EM class=CodeInput>print 
trace(x, -1) </EM><EM class=Emphasis># 5 + 11 + 17 + 23</EM> </P>
<P class=Python><A name=pgfId-58128></A>56</P>
<P class=Python><A name=pgfId-58129></A>&gt;&gt;&gt; <EM class=CodeInput>print 
trace(x, 1) </EM><EM class=Emphasis># 1 + 7 + 13 + 19</EM> </P>
<P class=Python><A name=pgfId-58117></A>40</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36532></A>searchsorted(a, values) </H6>
<P class=Body><A name=pgfId-36533></A>Called with a rank-1 array sorted in 
ascending order, <EM class=Code>searchsorted()</EM> will return the indices of 
the positions in a where the corresponding values would fit. </P>
<P class=Python><A name=pgfId-65893></A>&gt;&gt;&gt; <EM class=CodeInput>print 
bin_boundaries</EM> </P>
<P class=Python><A name=pgfId-65894></A>[ 0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 
1. ]</P>
<P class=Python><A name=pgfId-65895></A>&gt;&gt;&gt; <EM class=CodeInput>print 
data</EM> </P>
<P class=Python><A name=pgfId-65896></A>[ 0.3029573 0.79585496 0.82714031 
0.77993884 0.55069605 0.76043182</P>
<P class=Python><A name=pgfId-65897></A>0.28511823 0.29987358 0.40286206 
0.68617903]</P>
<P class=Python><A name=pgfId-65898></A>&gt;&gt;&gt; <EM class=CodeInput>print 
searchsorted(bin_boundaries, data)</EM> </P>
<P class=Python><A name=pgfId-66633></A>[4 8 9 8 6 8 3 3 5 7]</P>
<P class=Body><A name=pgfId-66640></A>This can be used for example to write a 
simple histogramming function:</P>
<P class=Python><A name=pgfId-66651></A>&gt;&gt;&gt; <EM class=CodeInput>def 
histogram(a, bins):</EM> </P>
<P class=Python><A name=pgfId-66641></A>... <EM class=CodeInput>n = 
searchsorted(sort(a), bins)</EM> </P>
<P class=Python><A name=pgfId-66642></A>... <EM class=CodeInput>n = 
concatenate([n, [len(a)]])</EM> </P>
<P class=Python><A name=pgfId-66643></A>... <EM class=CodeInput>return 
n[1:]-n[:-1]</EM> </P>
<P class=Python><A name=pgfId-66645></A>...</P>
<P class=Python><A name=pgfId-66671></A>&gt;&gt;&gt; <EM class=CodeInput>print 
histogram([0,0,0,0,0,0,0,.33,.33,.33], arange(0,1.0,.1))</EM> </P>
<P class=Python><A name=pgfId-66647></A>[7 0 0 3 0 0 0 0 0 0]</P>
<P class=Python><A name=pgfId-66689></A>&gt;&gt;&gt; <EM class=CodeInput>print 
histogram(sin(arange(0,10,.2)), arange(-1.2, 1.2, .1))</EM> </P>
<P class=Python><A name=pgfId-66687></A>[0 0 4 2 2 2 0 2 1 2 1 3 1 3 1 3 2 3 2 3 
4 9 0 0]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-66636></A><A name=marker-66635></A>sort(a, 
axis=-1) </H6>
<P class=FirstBody><A name=pgfId-66206></A>This function returns an array 
containing a copy of the data in <EM class=Code>a</EM> , with the same shape as 
<EM class=Code>a</EM> , but with the order of the elements along the specified 
axis sorted. The shape of the returned array is the same as <EM 
class=Code>a</EM> 's. Thus, <EM class=Code>sort(a, 3)</EM> will be an array of 
the same shape as a, where the elements of a have been sorted along the fourth 
axis. </P>
<P class=Python><A name=pgfId-65924></A>&gt;&gt;&gt; <EM class=CodeInput>print 
data</EM> </P>
<P class=Python><A name=pgfId-65925></A>[[5 0 1 9 8]</P>
<P class=Python><A name=pgfId-65926></A>[2 5 8 3 2]</P>
<P class=Python><A name=pgfId-65927></A>[8 0 3 7 0]</P>
<P class=Python><A name=pgfId-65928></A>[9 6 9 5 0]</P>
<P class=Python><A name=pgfId-65929></A>[9 0 9 7 7]]</P>
<P class=Python><A name=pgfId-65930></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sort(data) </EM><EM class=Emphasis># Axis -1 by default</EM> </P>
<P class=Python><A name=pgfId-65931></A>[[0 1 5 8 9]</P>
<P class=Python><A name=pgfId-65932></A>[2 2 3 5 8]</P>
<P class=Python><A name=pgfId-65933></A>[0 0 3 7 8]</P>
<P class=Python><A name=pgfId-65934></A>[0 5 6 9 9]</P>
<P class=Python><A name=pgfId-65935></A>[0 7 7 9 9]]</P>
<P class=Python><A name=pgfId-65936></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sort(data, 0)</EM> </P>
<P class=Python><A name=pgfId-65937></A>[[2 0 1 3 0]</P>
<P class=Python><A name=pgfId-65938></A>[5 0 3 5 0]</P>
<P class=Python><A name=pgfId-65939></A>[8 0 8 7 2]</P>
<P class=Python><A name=pgfId-65940></A>[9 5 9 7 7]</P>
<P class=Python><A name=pgfId-65876></A>[9 6 9 9 8]] </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-65841></A><A name=marker-65840></A>argsort(a, 
axis=-1) </H6>
<P class=Body><A name=pgfId-66005></A><EM class=Code>argsort</EM> will return 
the indices of the elements of a needed to produce <EM class=Code>sort(a)</EM> . 
In other words, for a rank-1 array, <EM class=Code>take(a, argsort(a)) == 
sort(a)</EM> . </P>
<P class=Python><A name=pgfId-66031></A>&gt;&gt;&gt; <EM class=CodeInput>print 
data</EM> </P>
<P class=Python><A name=pgfId-66032></A>[5 0 1 9 8]</P>
<P class=Python><A name=pgfId-66033></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sort(data)</EM> </P>
<P class=Python><A name=pgfId-66034></A>[0 1 5 8 9]</P>
<P class=Python><A name=pgfId-66035></A>&gt;&gt;&gt; <EM class=CodeInput>print 
argsort(data)</EM> </P>
<P class=Python><A name=pgfId-66036></A>[1 2 0 4 3]</P>
<P class=Python><A name=pgfId-66037></A>&gt;&gt;&gt; <EM class=CodeInput>print 
take(data, argsort(data))</EM> </P>
<P class=Python><A name=pgfId-66024></A>[0 1 5 8 9]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-66027></A><A name=marker-66025></A><A 
name=marker-66026></A>argmax(a, axis=-1), argmin(a, axis=-1) </H6>
<P class=Body><A name=pgfId-65827></A>The <EM class=Code>argmax()</EM> function 
returns an array with the arguments of the maximum values of its input array a 
along the given axis. The returned array will have one less dimension than a. 
<EM class=Code>argmin()</EM> is just like <EM class=Code>argmax()</EM> , except 
that it returns the indices of the minima along the given axis. </P>
<P class=Python><A name=pgfId-66056></A>&gt;&gt;&gt; <EM class=CodeInput>print 
data</EM> </P>
<P class=Python><A name=pgfId-66057></A>[[9 6 1 3 0]</P>
<P class=Python><A name=pgfId-66058></A>[0 0 8 9 1]</P>
<P class=Python><A name=pgfId-66059></A>[7 4 5 4 0]</P>
<P class=Python><A name=pgfId-66060></A>[5 2 7 7 1]</P>
<P class=Python><A name=pgfId-66061></A>[9 9 7 9 7]]</P>
<P class=Python><A name=pgfId-66062></A>&gt;&gt;&gt; <EM class=CodeInput>print 
argmax(data)</EM> </P>
<P class=Python><A name=pgfId-66063></A>[0 3 0 2 0]</P>
<P class=Python><A name=pgfId-66064></A>&gt;&gt;&gt; <EM class=CodeInput>print 
argmax(data, 0)</EM> </P>
<P class=Python><A name=pgfId-66065></A>[0 4 1 1 4]</P>
<P class=Python><A name=pgfId-66066></A>&gt;&gt;&gt; <EM class=CodeInput>print 
argmin(data)</EM> </P>
<P class=Python><A name=pgfId-66067></A>[4 0 4 4 2]</P>
<P class=Python><A name=pgfId-66068></A>&gt;&gt;&gt; <EM class=CodeInput>print 
argmin(data, 0)</EM> </P>
<P class=Python><A name=pgfId-36537></A>[1 1 0 0 0]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36538></A><A 
name=marker-59645></A>fromstring(string, typecode) </H6>
<P class=Body><A name=pgfId-36539></A>Will return the array formed by the binary 
data given in string of the specified typecode. This is mainly used for reading 
binary data to and from files, it can also be used to exchange binary data with 
other modules that use python strings as storage (<EM class=Emphasis> e.g.</EM> 
PIL). Note that this representation is dependent on the byte order. To find out 
the byte ordering used, use the <EM class=Code>byteswapped()</EM> method 
described on <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#19367">byteswapped()</A>.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36540></A>dot(m1, m2) </H6>
<P class=Body><A name=pgfId-36541></A>The <EM class=Code>dot()</EM> function 
returns the dot product of <EM class=Code>m1</EM> and <EM class=Code>m2</EM> . 
This is equivalent to matrix multiply for rank-2 arrays (without the transpose). 
Somebody who does more linear algebra really needs to do this function right 
some day! </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36542></A><A 
name=marker-59646></A>matrixmultiply(m1, m2) </H6>
<P class=Body><A name=pgfId-68306></A>The <EM class=Code>matrixmultiply(m1, 
m2)</EM> multiplies matrices or matrices and vectors as matrices rather than 
elementwise. Compare:</P>
<P class=Python><A name=pgfId-68371></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-68372></A>[[0 1 2]</P>
<P class=Python><A name=pgfId-68373></A>[3 4 5]]</P>
<P class=Python><A name=pgfId-68374></A>&gt;&gt;&gt; <EM class=CodeInput>print 
b</EM> </P>
<P class=Python><A name=pgfId-68375></A>[1 2 3]</P>
<P class=Python><A name=pgfId-68376></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a*b</EM> </P>
<P class=Python><A name=pgfId-68377></A>[[ 0 2 6]</P>
<P class=Python><A name=pgfId-68378></A>[ 3 8 15]]</P>
<P class=Python><A name=pgfId-68379></A>&gt;&gt;&gt; <EM class=CodeInput>print 
matrixmultiply(a,b)</EM> </P>
<P class=Python><A name=pgfId-68380></A>[ 8 26]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36545></A><A name=marker-59647></A>clip(m, 
m_min, m_max) </H6>
<P class=Body><A name=pgfId-36546></A>The clip function creates an array with 
the same shape and typecode as m, but where every entry in m that is less than 
m_min is replaced by m_min, and every entry greater than m_max is replaced by 
m_max. Entries within the range [m_min, m_max] are left unchanged. </P>
<P class=Python><A name=pgfId-36547></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(9, Float)</EM> </P>
<P class=Python><A name=pgfId-36548></A>&gt;&gt;&gt; <EM class=CodeInput>clip(a, 
1.5, 7.5)</EM> </P>
<P class=Python><A name=pgfId-36549></A>1.5000 1.5000 2.0000 3.0000 4.0000 
5.0000 6.0000 7.0000 7.5000 </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-66267></A><A 
name=marker-66266></A>indices(shape, typecode=None) </H6>
<P class=FirstBody><A name=pgfId-66268></A>The indices function returns an array 
corresponding to the shape given. The array returned is an array of a new shape 
which is based on the specified shape, but has an added dimension of length the 
number of dimensions in the specified shape. For example, if the shape specified 
by the <EM class=Code>shape</EM> argument is (3,4), then the shape of the array 
returned will be (2,3,4) since the length of (3,4) is 2. The contents of the 
returned arrays are such that the ith subarray (along index 0, the first 
dimension) contains the indices for that axis of the elements in the array. An 
example makes things clearer:</P>
<P class=Python><A name=pgfId-66269></A>&gt;&gt;&gt; <EM class=CodeInput>i = 
indices((4,3))</EM> </P>
<P class=Python><A name=pgfId-66270></A>&gt;&gt;&gt; <EM 
class=CodeInput>i.shape</EM> </P>
<P class=Python><A name=pgfId-66271></A>(2, 4, 3)</P>
<P class=Python><A name=pgfId-66272></A>&gt;&gt;&gt; <EM class=CodeInput>print 
i[0]</EM> </P>
<P class=Python><A name=pgfId-66292></A>[[0 0 0]</P>
<P class=Python><A name=pgfId-66293></A>[1 1 1]</P>
<P class=Python><A name=pgfId-66294></A>[2 2 2]</P>
<P class=Python><A name=pgfId-66276></A>[3 3 3]]</P>
<P class=Python><A name=pgfId-66277></A>&gt;&gt;&gt; <EM class=CodeInput>print 
i[1]</EM> </P>
<P class=Python><A name=pgfId-66299></A>[[0 1 2]</P>
<P class=Python><A name=pgfId-66300></A>[0 1 2]</P>
<P class=Python><A name=pgfId-66301></A>[0 1 2]</P>
<P class=Python><A name=pgfId-66281></A>[0 1 2]]</P>
<P class=Body><A name=pgfId-66282></A>So, <EM class=Code>i[0]</EM> has an array 
of the specified shape, and each element in that array specifies the index of 
that position in the subarray for axis 0. Similarly, each element in the 
subarray in <EM class=Code>i[1]</EM> contains the index of that position in the 
subarray for axis 1. </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58407></A><A 
name=marker-59650></A>swapaxes(a, axis1, axis2) </H6>
<P class=FirstBody><A name=pgfId-58408></A>Returns a new array which shares the 
data of <EM class=Code>a</EM> , but which has the two axes specified by <EM 
class=Code>axis1</EM> and <EM class=Code>axis2</EM> swapped. If <EM 
class=Code>a</EM> is of rank 0 or 1, swapaxes simply returns a new reference to 
<EM class=Code>a</EM> .</P>
<P class=Python><A name=pgfId-58409></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
arange(10)</EM> </P>
<P class=Python><A name=pgfId-58410></A>&gt;&gt;&gt; <EM class=CodeInput>x.shape 
= (5,2,1)</EM> </P>
<P class=Python><A name=pgfId-58411></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-58412></A>[[[0]</P>
<P class=Python><A name=pgfId-58413></A>[1]]</P>
<P class=Python><A name=pgfId-58414></A>[[2]</P>
<P class=Python><A name=pgfId-58415></A>[3]]</P>
<P class=Python><A name=pgfId-58416></A>[[4]</P>
<P class=Python><A name=pgfId-58417></A>[5]]</P>
<P class=Python><A name=pgfId-58418></A>[[6]</P>
<P class=Python><A name=pgfId-58419></A>[7]]</P>
<P class=Python><A name=pgfId-58420></A>[[8]</P>
<P class=Python><A name=pgfId-58421></A>[9]]]</P>
<P class=Python><A name=pgfId-58422></A>&gt;&gt;&gt; <EM class=CodeInput>y = 
swapaxes(x, 0, 2)</EM> </P>
<P class=Python><A name=pgfId-58423></A>&gt;&gt;&gt; <EM class=CodeInput>print 
y.shape</EM> </P>
<P class=Python><A name=pgfId-58424></A>(1, 2, 5)</P>
<P class=Python><A name=pgfId-58425></A>&gt;&gt;&gt; <EM class=CodeInput>print 
y</EM> </P>
<P class=Python><A name=pgfId-58426></A>[ [[0 2 4 6 8]</P>
<P class=Python><A name=pgfId-58427></A>[1 3 5 7 9]]]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58428></A><A 
name=marker-59651></A>concatenate((a0, a1, ... , an), axis=0) </H6>
<P class=FirstBody><A name=pgfId-58429></A>Returns a new array containing copies 
of the data contained in all arrays <EM class=Code>a0 ... an</EM> . The arrays 
ai will be concatenated along the specified axis (0 by default). All arrays ai 
must have the same shape along every axis except for the one given. To 
concatenate arrays along a newly created axis, you can use <EM 
class=Code>array((a0, ..., an))</EM> as long as all arrays have the same shape. 
</P>
<P class=Python><A name=pgfId-58430></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-58431></A>[[ 0 1 2 3]</P>
<P class=Python><A name=pgfId-58432></A>[ 5 6 7 8]</P>
<P class=Python><A name=pgfId-58433></A>[10 11 12 13]]</P>
<P class=Python><A name=pgfId-58434></A>&gt;&gt;&gt; <EM class=CodeInput>print 
concatenate((x,x))</EM> </P>
<P class=Python><A name=pgfId-58435></A>[[ 0 1 2 3]</P>
<P class=Python><A name=pgfId-58436></A>[ 5 6 7 8]</P>
<P class=Python><A name=pgfId-58437></A>[10 11 12 13]</P>
<P class=Python><A name=pgfId-58438></A>[ 0 1 2 3]</P>
<P class=Python><A name=pgfId-58439></A>[ 5 6 7 8]</P>
<P class=Python><A name=pgfId-58440></A>[10 11 12 13]]</P>
<P class=Python><A name=pgfId-58441></A>&gt;&gt;&gt; <EM class=CodeInput>print 
concatenate((x,x), 1)</EM> </P>
<P class=Python><A name=pgfId-58442></A>[[ 0 1 2 3 0 1 2 3]</P>
<P class=Python><A name=pgfId-58443></A>[ 5 6 7 8 5 6 7 8]</P>
<P class=Python><A name=pgfId-58444></A>[10 11 12 13 10 11 12 13]]</P>
<P class=Python><A name=pgfId-58445></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array((x,x)</EM> )</P>
<P class=Python><A name=pgfId-58446></A>[[[ 0 1 2 3]</P>
<P class=Python><A name=pgfId-58447></A>[ 5 6 7 8]</P>
<P class=Python><A name=pgfId-58448></A>[10 11 12 13]]</P>
<P class=Python><A name=pgfId-58449></A>[[ 0 1 2 3]</P>
<P class=Python><A name=pgfId-58450></A>[ 5 6 7 8]</P>
<P class=Python><A name=pgfId-58451></A>[10 11 12 13]]]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58474></A><A 
name=marker-59656></A>innerproduct(a, b) </H6>
<P class=FirstBody><A name=pgfId-68414></A>innerproduct produces the inner 
product of arrays a and b. It is equivalent to matrixmultiply(a, 
transpose(b)).</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-84301></A><A 
name=marker-84312></A>outerproduct(a,b)</H6>
<P class=FirstBody><A name=pgfId-84305></A>outerproduct(a,b) produces the outer 
product of vectors a and b, that is result[i, j] = a[i] * b[j]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-84308></A><A 
name=marker-59658></A>array_repr() </H6>
<P class=FirstBody><A name=pgfId-58478></A>See section on Textual 
Representations of arrays.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58479></A><A 
name=marker-59659></A>array_str() </H6>
<P class=FirstBody><A name=pgfId-58480></A>See section on Textual 
Representations of arrays.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58481></A><A name=marker-59660></A>resize(a, 
new_shape) </H6>
<P class=FirstBody><A name=pgfId-58482></A>The <EM class=Code>resize</EM> 
function takes an array and a shape, and returns a new array with the specified 
shape, and filled with the data in the input array. Unlike the <EM 
class=Code>reshape</EM> function, the new shape does not have to yield the same 
size as the original array. If the new size of is less than that of the input 
array, the returned array contains the appropriate data from the "beginning" of 
the old array. If the new size is greater than that of the input array, the data 
in the input array is repeated as many times as needed to fill the new 
array.</P>
<P class=Python><A name=pgfId-58483></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
arange(10)</EM> </P>
<P class=Python><A name=pgfId-58484></A>&gt;&gt;&gt; <EM class=CodeInput>y = 
resize(x, (4,2)) </EM># note that 4*2 &lt; 10</P>
<P class=Python><A name=pgfId-58485></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-58486></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-58487></A>&gt;&gt;&gt; <EM class=CodeInput>print 
y</EM> </P>
<P class=Python><A name=pgfId-58488></A>[[0 1]</P>
<P class=Python><A name=pgfId-58489></A>[2 3]</P>
<P class=Python><A name=pgfId-58490></A>[4 5]</P>
<P class=Python><A name=pgfId-58491></A>[6 7]]</P>
<P class=Python><A name=pgfId-58492></A>&gt;&gt;&gt; <EM class=CodeInput>print 
resize(array((0,1)), (5,5)) </EM># note that 5*5 &gt; 2</P>
<P class=Python><A name=pgfId-58493></A>[[0 1 0 1 0]</P>
<P class=Python><A name=pgfId-58494></A>[1 0 1 0 1]</P>
<P class=Python><A name=pgfId-58495></A>[0 1 0 1 0]</P>
<P class=Python><A name=pgfId-58496></A>[1 0 1 0 1]</P>
<P class=Python><A name=pgfId-58497></A>[0 1 0 1 0]]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58514></A><A 
name=marker-59662></A>diagonal(a, offset=0, axis1=-2, axis2=-1) </H6>
<P class=FirstBody><A name=pgfId-58515></A>The diagonal function takes an array 
a, and returns an array of rank 1 containing all of the elements of a such that 
the difference between their indices along the specified axes is equal to the 
specified offset. With the default values, this corresponds to all of the 
elements of the diagonal of a along the last two axes. <EM 
class=Emphasis>Currently this is broken for offsets other than -1, 0 and 1, and 
for non-square arrays.</EM> </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58523></A><A name=marker-59666></A>repeat (a, 
counts, axis=0)</H6>
<P class=FirstBody><A name=pgfId-67620></A>The repeat function uses repeated 
copies of a to create a result. The axis argument refers to the axis of x which 
will be replicated. The counts argument tells how many copies of each element to 
make. The length of counts must be the len(shape(a)[axis]). </P>
<P class=Body><A name=pgfId-67681></A>In one dimension this is 
straightforward:</P>
<P class=Python><A name=pgfId-67672></A>&gt;&gt;&gt; y</P>
<P class=Python><A name=pgfId-67673></A>array([0, 1, 2, 3, 4, 5])</P>
<P class=Python><A name=pgfId-67666></A>&gt;&gt;&gt; repeat(y, 
(1,2,0,2,2,3))</P>
<P class=Python><A name=pgfId-67667></A>array([0, 1, 1, 3, 3, 4, 4, 5, 5, 
5])</P>
<P class=Python><A name=pgfId-67658></A>&nbsp;</P>
<P class=Body><A name=pgfId-67657></A>In more than one dimension it sometimes 
gets harder to understand. Consider for example this array x whose shape is 
(2,3).</P>
<P class=Python><A name=pgfId-67626></A>&gt;&gt;&gt; x</P>
<P class=Python><A name=pgfId-67627></A>array([[0, 1, 2],</P>
<P class=Python><A name=pgfId-67628></A>[3, 4, 5]])</P>
<P class=Python><A name=pgfId-67689></A>&nbsp;</P>
<P class=Python><A name=pgfId-67629></A>&gt;&gt;&gt; repeat(x, (2,6))</P>
<P class=Python><A name=pgfId-67630></A>array([[0, 1, 2],</P>
<P class=Python><A name=pgfId-67631></A>[0, 1, 2],</P>
<P class=Python><A name=pgfId-67632></A>[3, 4, 5],</P>
<P class=Python><A name=pgfId-67633></A>[3, 4, 5],</P>
<P class=Python><A name=pgfId-67634></A>[3, 4, 5],</P>
<P class=Python><A name=pgfId-67635></A>[3, 4, 5],</P>
<P class=Python><A name=pgfId-67636></A>[3, 4, 5],</P>
<P class=Python><A name=pgfId-67637></A>[3, 4, 5]])</P>
<P class=Python><A name=pgfId-67690></A>&nbsp;</P>
<P class=Python><A name=pgfId-67642></A>&gt;&gt;&gt; repeat(x, (6,3), 1)</P>
<P class=Python><A name=pgfId-67643></A>array([[0, 0, 0, 0, 0, 0, 1, 1, 1],</P>
<P class=Python><A name=pgfId-67903></A>[2, 2, 2, 2, 2, 2, 3, 3, 3]])</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-67914></A><A name=marker-67940></A>convolve 
(a, v, mode=0)</H6>
<P class=Body><A name=pgfId-67915></A>The convolve function returns the linear 
convolution of two rank 1 arrays. The output is a rank 1 array whose length 
depends on the value of mode which is zero by default. Linear convolution can be 
used to find the response of a linear system to an arbitrary input. If the input 
arrays correspond to the coefficients of a polynomial and mode=2, the output of 
linear convolution corresponds to the coefficients of the product of the 
polynomials. </P>
<P class=Body><A name=pgfId-67916></A>The mode parameter requires a bit of 
explanation. True linear convolution is only defined over infinite sequences. As 
both input arrays must represent finite sequences, the convolve operation 
assumes that the infinite sequences represented by the finite inputs are zero 
outside of their domain of definition. In other words, the sequences are 
zero-padded. If mode is 2, then the non-zero part of the full linear convolution 
is returned, so the output has length len (a)+len (v)-1. Call this output f. If 
mode is 0, then any part of f which was affected by the zero-padding is chopped 
from the result. In other words, let b be the input with smallest length and let 
c be the other input. The output when mode is 0 is the middle len (c)-len (b)+1 
elements of f. When mode is 1, the output is the same size as c and is equal to 
the middle len (c) elements of f.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-67917></A><A 
name=marker-67939></A>cross_correlate (a, v, mode=0)</H6>
<P class=Body><A name=pgfId-67918></A>The cross_correlate function computes the 
cross_correlation between two rank 1 arrays. The output is a rank 1 array 
representing the inner product of a with shifted versions of v. This is very 
similar to convolution. The difference is that convolution reverses the axis of 
one of the input sequences but cross_correlation does not. In fact it is easy to 
verify that convolve (a, v, mode) = cross_correlate (a, v [::-1], mode) 
</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-67907></A><A name=marker-67905></A><A 
name=marker-67906></A>where (condition, x, y) </H6>
<P class=FirstBody><A name=pgfId-67600></A>The where function creates an array 
whose values are those of x at those indices where condition is true, and those 
of y otherwise. The shape of the result is the shape of condition. The type of 
the result is determined by the types of x and y. Either or both of x and y and 
be a scalar, which is then used for any element of condition which is 
true.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58536></A><A 
name=marker-59693></A>identity(n) </H6>
<P class=FirstBody><A name=pgfId-58537></A>The identity function returns an n by 
n array where the diagonal elements are 1, and the off-diagonal elements are 
0.</P>
<P class=Python><A name=pgfId-58538></A>&gt;&gt;&gt; <EM class=CodeInput>print 
identity(5)</EM> </P>
<P class=Python><A name=pgfId-58539></A>[[1 0 0 0 0]</P>
<P class=Python><A name=pgfId-58540></A>[0 1 0 0 0]</P>
<P class=Python><A name=pgfId-58541></A>[0 0 1 0 0]</P>
<P class=Python><A name=pgfId-58542></A>[0 0 0 1 0]</P>
<P class=Python><A name=pgfId-58543></A>[0 0 0 0 1]]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58544></A><A name=marker-59694></A>sum(a, 
index=0) </H6>
<P class=FirstBody><A name=pgfId-58545></A>The sum function is a synonym for the 
reduce method of the add ufunc. It returns the sum of all of the elements in the 
sequence given along the specified axis (first axis by default).</P>
<P class=Python><A name=pgfId-58546></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-58547></A>[[ 0 1 2 3]</P>
<P class=Python><A name=pgfId-58548></A>[ 4 5 6 7]</P>
<P class=Python><A name=pgfId-58549></A>[ 8 9 10 11]</P>
<P class=Python><A name=pgfId-58550></A>[12 13 14 15]</P>
<P class=Python><A name=pgfId-58551></A>[16 17 18 19]]</P>
<P class=Python><A name=pgfId-58552></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sum(x)</EM> </P>
<P class=Python><A name=pgfId-58553></A>[40 45 50 55] # 0+4+8+12+16, 
1+5+9+13+17, 2+6+10+14+18, ...</P>
<P class=Python><A name=pgfId-58554></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sum(x, 1)</EM> </P>
<P class=Python><A name=pgfId-58555></A>[ 6 22 38 54 70] # 0+1+2+3, 4+5+6+7, 
8+9+10+11, ...</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58556></A><A name=marker-59695></A>cumsum(a, 
index=0) </H6>
<P class=FirstBody><A name=pgfId-58557></A>The <EM class=Code>cumsum</EM> 
function is a synonym for the <EM class=Code>accumulate</EM> method of the <EM 
class=Code>add</EM> ufunc.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58558></A><A name=marker-59696></A>product(a, 
index=0) </H6>
<P class=FirstBody><A name=pgfId-58559></A>The <EM class=Code>product</EM> 
function is a synonym for the <EM class=Code>reduce</EM> method of the <EM 
class=Code>multiply</EM> ufunc.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58560></A><A 
name=marker-59697></A>cumproduct(a, index=0) </H6>
<P class=FirstBody><A name=pgfId-58561></A>The <EM class=Code>cumproduct</EM> 
function is a synonym for the <EM class=Code>accumulate</EM> method of the <EM 
class=Code>multiply</EM> ufunc.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58562></A><A name=marker-59698></A>alltrue(a, 
index=0) </H6>
<P class=FirstBody><A name=pgfId-58563></A>The <EM class=Code>alltrue</EM> 
function is a synonym for the <EM class=Code>reduce</EM> method of the <EM 
class=Code>logical_and</EM> ufunc.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-58564></A><A 
name=marker-59699></A>sometrue(a, index=0) </H6>
<P class=FirstBody><A name=pgfId-58565></A>The <EM class=Code>sometrue</EM> 
function is a synonym for the <EM class=Code>reduce</EM> method of the <EM 
class=Code>logical_or</EM> ufunc.</P></DIV></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-36552></A>9. <A name=marker-59710></A><A 
name=42194></A>Array Methods </H2>
<P class=Body><A name=pgfId-36553></A>As we discussed at the beginning of the 
last chapter, there are very few array methods for good reasons, and these all 
depend on the the implementation details. They're worth knowing, though: </P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36554></A><A name=marker-59704></A>itemsize() 
</H6>
<P class=Body><A name=pgfId-36555></A>The itemsize() method applied to an array 
returns the number of bytes used by any one of its elements. </P>
<P class=Python><A name=pgfId-36556></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(10)</EM> </P>
<P class=Python><A name=pgfId-36557></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.itemsize()</EM> </P>
<P class=Python><A name=pgfId-36558></A>4</P>
<P class=Python><A name=pgfId-36559></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1.0])</EM> </P>
<P class=Python><A name=pgfId-36560></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.itemsize()</EM> </P>
<P class=Python><A name=pgfId-36561></A>8</P>
<P class=Python><A name=pgfId-36562></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1], Complex)</EM> </P>
<P class=Python><A name=pgfId-36563></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.itemsize()</EM> </P>
<P class=Python><A name=pgfId-36564></A>16</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36565></A><A 
name=marker-59705></A>iscontiguous() </H6>
<P class=Body><A name=pgfId-36566></A>Calling an array's iscontiguous() method 
returns true if the memory used by A is contiguous. A non-contiguous array can 
be converted to a contiguous one by the copy() method. This is useful for 
interfacing to C routines only, as far as I know. </P>
<P class=Body><A name=pgfId-36567></A>&gt;&gt;&gt; XXX example </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36568></A><A name=marker-59706></A>typecode() 
</H6>
<P class=Body><A name=pgfId-36569></A>The `typecode()' method returns the 
typecode of the array it is applied to. While we've been talking about them as 
Float, Int, etc., they are represented internally as characters, so this is what 
you'll get: </P>
<P class=Python><A name=pgfId-36570></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1,2,3])</EM> </P>
<P class=Python><A name=pgfId-36571></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.typecode()</EM> </P>
<P class=Python><A name=pgfId-36572></A>'l'</P>
<P class=Python><A name=pgfId-36573></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
array([1], Complex)</EM> </P>
<P class=Python><A name=pgfId-36574></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.typecode()</EM> </P>
<P class=Python><A name=pgfId-36575></A>'D'</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36576></A><A name=marker-59707></A><A 
name=19367></A>byteswapped() </H6>
<P class=Body><A name=pgfId-36577></A>The <EM class=Code>byteswapped</EM> method 
performs a byte swapping operation on all the elements in the array.</P>
<P class=Python><A name=pgfId-36578></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36579></A>[1 2 3]</P>
<P class=Python><A name=pgfId-36580></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a.byteswapped()</EM> </P>
<P class=Python><A name=pgfId-36581></A>[16777216 33554432 50331648] </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36582></A><A name=marker-59708></A>tostring() 
</H6>
<P class=Body><A name=pgfId-36583></A>The <EM class=Code>tostring</EM> method 
returns a string representation of the data portion of the array it is applied 
to. </P>
<P class=Python><A name=pgfId-36584></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(65,100)</EM> </P>
<P class=Python><A name=pgfId-36585></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a.tostring()</EM> </P>
<P class=Python><A name=pgfId-36586></A>A B C D E F G H I J K L M N O P Q R S 
T</P>
<P class=Python><A name=pgfId-36587></A>U V W X Y Z [ \ ] ^ _ ` a b c </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36588></A><A name=marker-59709></A>tolist() 
</H6>
<P class=Body><A name=pgfId-36589></A>Calling an array's tolist() method returns 
a hierarchical python list version of the same array:</P>
<P class=Python><A name=pgfId-36590></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36591></A>[[65 66 67 68 69 70 71]</P>
<P class=Python><A name=pgfId-36592></A>[72 73 74 75 76 77 78]</P>
<P class=Python><A name=pgfId-36593></A>[79 80 81 82 83 84 85]</P>
<P class=Python><A name=pgfId-36594></A>[86 87 88 89 90 91 92]</P>
<P class=Python><A name=pgfId-36595></A>[93 94 95 96 97 98 99]]</P>
<P class=Python><A name=pgfId-36596></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a.tolist()</EM> </P>
<P class=Python><A name=pgfId-36597></A>[[65, 66, 67, 68, 69, 70, 71], [72, 73, 
74, 75, 76, 77, 78], [79, 80, 81, 82, 83, 84, 85], [86, 87, 88, 89, 90, 91, 92], 
[93, 94, 95, 96, 97, 98, 99]] </P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-36604></A>10. <A name=marker-59711></A><A 
name=86746></A>Array Attributes </H2>
<P class=Body><A name=pgfId-36605></A>We've already seen a very useful attribute 
of arrays, the shape attribute. There are three more, flat, real and imaginary. 
</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36606></A><EM class=Emphasis>flat</EM> <A 
name=marker-59712></A></H6>
<P class=Body><A name=pgfId-36607></A>Accessing the <EM class=Code>flat</EM> 
attribute of an array returns the flattened, or <EM class=Code>ravel()</EM> 'ed 
version of that array, without having to do a function call. The returner array 
has the same number of elements as the input array, but is of rank-1. One cannot 
set the flat attribute of an array, but one can use the indexing and slicing 
notations to modify the contents of the array:</P>
<P class=Python><A name=pgfId-36608></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36609></A>[[0 1 2]</P>
<P class=Python><A name=pgfId-36610></A>[3 4 5]</P>
<P class=Python><A name=pgfId-36611></A>[6 7 8]]</P>
<P class=Python><A name=pgfId-36612></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a.flat</EM> </P>
<P class=Python><A name=pgfId-36613></A>[0 1 2 3 4 5 6 7 8]</P>
<P class=Python><A name=pgfId-36614></A>&gt;&gt;&gt; <EM class=CodeInput>a.flat 
= arange(9,18)</EM> </P>
<P class=Python><A name=pgfId-36615></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-36616></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-36617></A>AttributeError: Attribute does not exist 
or cannot be set</P>
<P class=Python><A name=pgfId-36618></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.flat[4] = 100</EM> </P>
<P class=Python><A name=pgfId-36619></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36620></A>[[ 0 1 2]</P>
<P class=Python><A name=pgfId-36621></A>[ 3 100 5]</P>
<P class=Python><A name=pgfId-36622></A>[ 6 7 8]]</P>
<P class=Python><A name=pgfId-36623></A>&gt;&gt;&gt; <EM 
class=CodeInput>a.flat[:] = arange(9, 18)</EM> </P>
<P class=Python><A name=pgfId-36624></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-36625></A>[[ 9 10 11]</P>
<P class=Python><A name=pgfId-36626></A>[12 13 14]</P>
<P class=Python><A name=pgfId-36627></A>[15 16 17]]</P>
<P class=Python><A name=pgfId-36628></A>&nbsp;</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36629></A><EM class=Emphasis>real</EM> <A 
name=marker-59713></A>and <EM class=Emphasis>imaginary</EM> <A 
name=marker-59714></A></H6>
<P class=Body><A name=pgfId-36630></A>These attributes exist only for complex 
arrays. They return respectively arrays filled with the real and imaginary parts 
of their elements. <EM class=Code>.imag</EM> is a synonym for <EM 
class=Code>.imaginary</EM> . The arrays returned are not contiguous (except for 
arrays of length 1, which are always contiguous.). <EM class=Code>.real</EM> , 
<EM class=Code>.imag</EM> and <EM class=Code>.imaginary</EM> are modifiable: 
</P>
<P class=Python><A name=pgfId-36631></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-36632></A>[ 0. +1.j 0.84147098+0.54030231j 
0.90929743-0.41614684j]</P>
<P class=Python><A name=pgfId-36633></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x.real</EM> </P>
<P class=Python><A name=pgfId-36634></A>[ 0. 0.84147098 0.90929743]</P>
<P class=Python><A name=pgfId-36635></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x.imag</EM> </P>
<P class=Python><A name=pgfId-36636></A>[ 1. 0.54030231 -0.41614684]</P>
<P class=Python><A name=pgfId-36637></A>&gt;&gt;&gt; <EM class=CodeInput>x.imag 
= arange(3)</EM> </P>
<P class=Python><A name=pgfId-36638></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-36639></A>[ 0. +0.j 0.84147098+1.j 0.90929743+2.j] 
</P>
<P class=Python><A name=pgfId-66468></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
reshape(arange(10), (2,5)) + 0j </EM># make complex array</P>
<P class=Python><A name=pgfId-66469></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-66470></A>[[ 0.+0.j 1.+0.j 2.+0.j 3.+0.j 
4.+0.j]</P>
<P class=Python><A name=pgfId-66471></A>[ 5.+0.j 6.+0.j 7.+0.j 8.+0.j 
9.+0.j]]</P>
<P class=Python><A name=pgfId-66472></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x.real</EM> </P>
<P class=Python><A name=pgfId-66473></A>[[ 0. 1. 2. 3. 4.]</P>
<P class=Python><A name=pgfId-66474></A>[ 5. 6. 7. 8. 9.]]</P>
<P class=Python><A name=pgfId-66475></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x.typecode(), x.real.typecode()</EM> </P>
<P class=Python><A name=pgfId-66476></A>D d</P>
<P class=Python><A name=pgfId-66477></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x.itemsize(), x.imag.itemsize()</EM> </P>
<P class=Python><A name=pgfId-66478></A>16 8</P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-59071></A>11. <A name=92607></A>Special 
Topics</H2>
<P class=ChapterDescription><A name=pgfId-59072></A>This chapter holds 
miscellaneous information which did not neatly fit in any of the other 
chapters.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-67984></A>Subclassing</H6>
<P class=FirstBody><A name=pgfId-68417></A>Subclassing Numeric arrays is not 
possible due to a limitation of Python. The approach taken in the Masked Array 
facility (<A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#48250">Masked 
Arrays</A>) is one answer. UserArray.py, described below, can be subclassed, but 
this is often unsatisfactory unless you put in a similar effort to that in 
MA.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-67992></A><A name=marker-67986></A>Code 
Organization</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-66725></A>Numeric.py and friends</H6>
<P class=FirstBody><A name=pgfId-66726></A><EM class=Code>Numeric.py</EM> is the 
most commonly used interface to the Numeric extensions. It is a Python module 
which imports all of the exported functions and attributes from the <EM 
class=Code>multiarray</EM> module, and then defines some utility functions. As 
some of the functions defined in <EM class=Code>Numeric.py</EM> could someday be 
moved into a supporting C module, the utility functions and the <EM 
class=Code>multiarray</EM> object are documented together, in this section. The 
<EM class=Code>multiarray</EM> objects are the core of Numeric Python - they are 
extension types written in C which are designed to provide both space- and 
time-efficiency when manipulating large arrays of homogeneous data types, with 
special emphasis to numeric data types.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-66711></A>UserArray.py</H6>
<P class=FirstBody><A name=pgfId-66738></A>In the tradition of <EM 
class=Code>UserList.py</EM> and <EM class=Code>UserDict.py</EM> , the <EM 
class=Code>UserArray.py</EM> module defines a class whose instances act in many 
ways like array objects. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-66719></A>Matrix.py</H6>
<P class=FirstBody><A name=pgfId-66782></A>The <EM class=Code>Matrix.py</EM> 
python module defines a class <EM class=Code>Matrix</EM> which is a subclass of 
<EM class=Code>UserArray</EM> . The only differences between <EM 
class=Code>Matrix</EM> instances and <EM class=Code>UserArray</EM> instances is 
that the <EM class=Code>*</EM> operator on <EM class=Code>Matrix</EM> performs a 
matrix multiplication, as opposed to element-wise multiplication, and that the 
power operator <EM class=Code>**</EM> is disallowed for <EM 
class=Code>Matrix</EM> instances.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-66783></A>Precision.py</H6>
<P class=Body><A name=pgfId-66784></A>The Precision.py module contains the code 
which is used to determine the mapping between typecode names and values, by 
building small arrays and looking at the number of bytes they use per 
element.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-66787></A>ArrayPrinter.py</H6>
<P class=Body><A name=pgfId-66788></A>The ArrayPrinter.py module defines the 
functions used for default printing of arrays. See the section on Textual 
Representations of arrays on <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#39358">Textual 
representations of arrays</A>,</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-66808></A>Mlab.py</H6>
<P class=Body><A name=pgfId-66910></A>The Mlab.py module provides some functions 
which are compatible with the functions of the same name in the MATLAB 
programming language. These are:</P>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66920></A>bartlett(M)</H6>
<P class=Body><A name=pgfId-66921></A>returns the M-point Bartlett 
window.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66922></A>blackman(M)</H6>
<P class=Body><A name=pgfId-66923></A>returns the M-point Blackman 
window.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66924></A>corrcoef(x, y=None)</H6>
<P class=Body><A name=pgfId-66925></A>The correlation coefficient</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66926></A>cov(m,y=None)</H6>
<P class=Body><A name=pgfId-66927></A>returns the covariance</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66928></A>cumprod(m)</H6>
<P class=Body><A name=pgfId-66929></A>returns the cumulative product of the 
elments along the first dimension of m.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66930></A>cumsum(m)</H6>
<P class=Body><A name=pgfId-66931></A>returns the cumulative sum of the elements 
along the first dimension of m.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66932></A>diag(v, k=0)</H6>
<P class=Body><A name=pgfId-66933></A>returns the k-th diagonal if v is a matrix 
or returns a matrix with v as the k-th diagonal if v is a vector.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66934></A>diff(x, n=1)</H6>
<P class=Body><A name=pgfId-66935></A>calculates the first-order, discrete 
difference approximation to the derivative.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66936></A>eig(m)</H6>
<P class=Body><A name=pgfId-66937></A>returns the the eigenvalues of m in x and 
the corresponding eigenvectors in the rows of v.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66938></A>eye(N, M=N, k=0, 
typecode=None)</H6>
<P class=Body><A name=pgfId-66939></A>returns a N-by-M matrix where the k-th 
diagonal is all ones, and everything else is zeros.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66940></A>fliplr(m)</H6>
<P class=Body><A name=pgfId-66941></A>returns a 2-D matrix m with the rows 
preserved and columns flipped in the left/right direction. Only works with 2-D 
arrays.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66942></A>flipud(m)</H6>
<P class=Body><A name=pgfId-66943></A>returns a 2-D matrix with the columns 
preserved and rows flipped in the up/down direction. Only works with 2-D 
arrays.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66944></A>hamming(M)</H6>
<P class=Body><A name=pgfId-66945></A>returns the M-point Hamming 
window.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66946></A>hanning(M)</H6>
<P class=Body><A name=pgfId-66947></A>returns the M-point Hanning 
window.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66948></A>kaiser(M, beta)</H6>
<P class=Body><A name=pgfId-66949></A>returns a Kaiser window of length M with 
shape parameter beta. It depends on the cephes module for the modified bessel 
function i0.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66950></A>max(m)</H6>
<P class=Body><A name=pgfId-67178></A>returns the maximum along the first 
dimension of m.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-67179></A>mean(m)</H6>
<P class=Body><A name=pgfId-67180></A>returns the mean along the first dimension 
of m. Note: if m is an integer array, integer division will occur.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66954></A>median(m)</H6>
<P class=Body><A name=pgfId-66955></A>returns a mean of m along the first 
dimension of m.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66956></A>min(m)</H6>
<P class=Body><A name=pgfId-66957></A>returns the minimum along the first 
dimension of m.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66958></A>msort(m)</H6>
<P class=Body><A name=pgfId-66959></A>returns a sort along the first dimension 
of m as in MATLAB.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66960></A>prod(m)</H6>
<P class=Body><A name=pgfId-66961></A>returns the product of the elements along 
the first dimension of m.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66962></A>ptp(m)</H6>
<P class=Body><A name=pgfId-66963></A>returns the maximum - minimum along the 
first dimension of m.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66964></A>rand(d1, ..., dn)</H6>
<P class=Body><A name=pgfId-66965></A>returns a matrix of the given dimensions 
which is initialized to random numbers from a uniform distribution in the range 
[0,1).</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-67153></A>rot90(m,k=1)</H6>
<P class=Body><A name=pgfId-67154></A>returns the matrix found by rotating m by 
k*90 degrees in the counterclockwise direction.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-67155></A>sinc(x)</H6>
<P class=Body><A name=pgfId-66969></A>returns sin(pi*x)/(pi*x) at all points of 
array x.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66970></A>squeeze(a)</H6>
<P class=Body><A name=pgfId-66971></A>removes any ones from the shape of 
a</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66972></A>std(m)</H6>
<P class=Body><A name=pgfId-66973></A>returns the standard deviation along the 
first dimension of m. The result is unbiased meaning division by 
len(m)-1.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66974></A>sum(m)</H6>
<P class=Body><A name=pgfId-66975></A>returns the sum of the elements along the 
first dimension of m.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66976></A>svd(m)</H6>
<P class=Body><A name=pgfId-66977></A>return the singular value decomposition of 
m [u,x,v]</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66978></A>trapz(y,x=None)</H6>
<P class=Body><A name=pgfId-66979></A>integrates y = f(x) using the trapezoidal 
rule.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66980></A>tri(N, M=N, k=0, 
typecode=None)</H6>
<P class=Body><A name=pgfId-66981></A>returns a N-by-M matrix where all the 
diagonals starting from lower left corner up to the k-th are all ones.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66982></A>tril(m,k=0)</H6>
<P class=Body><A name=pgfId-66983></A>returns the elements on and below the k-th 
diagonal of m. k=0 is the main diagonal, k &gt; 0 is above and k &lt; 0 is below 
the main diagonal.</P></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-66984></A>triu(m,k=0)</H6>
<P class=Body><A name=pgfId-66985></A>returns the elements on and above the k-th 
diagonal of m. k=0 is the main diagonal, k &gt; 0 is above and k &lt; 0 is below 
the main diagonal.</P></DIV></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-66811></A>The <A 
name=marker-66810></A>multiarray object</H6>
<P class=FirstBody><A name=pgfId-59077></A>The array objects which Numeric 
Python manipulates is actually a multiarray object, given this name to 
distinguish it from the one-dimensional array object defined in the standard 
array module. From here on, however, the terms array and multiarray will be used 
interchangeably to refer to the new object type. multiarray objects are 
homogeneous multidimensional sequences. Starting from the back, they are 
sequences. This means that they are container (compound) objects, which contain 
references to other objects. They are multidimensional, meaning that unlike 
standard Python sequences which define only a single dimension along which one 
can iterate through the contents, multiarray objects can have up to 40 
dimensions.<A class=footnote 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59080">1</A> 
Finally, they are homogeneous. This means that every object in a multiarray must 
be of the same type. This is done for efficiency reasons -- storing the type of 
the contained objects once in the array means that the process of finding the 
type-specific operation to operate on each element in the array needs to be done 
only once per array, as opposed to once per element. Furthemore, as the main 
purpose of these arrays is to process numbers, the numbers can be stored 
directly, and not as full-fledged Python objects (PyObject *), thus yielding 
memory savings. It is however possible to make arrays of Python objects, which 
relinquish both the space and time efficiencies but allow heterogeneous contents 
(as we shall see, these arrays are still homogeneous from the Numeric 
perspective, they are just arrays of Python object references).</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59085></A><A 
name=marker-59717></A>Typecodes</H6>
<P class=FirstBody><A name=pgfId-59086></A>The kind of number stored in an array 
is described by its typecode. This code is stored internally as a 
single-character Python string, but more descriptive names corresponding to the 
typecodes are made available to the Python programmer in the Precision.py 
module. The typecodes are defined as follows:</P>
<TABLE border=1>
  <CAPTION>
  <H6 class=TableTitle><A name=pgfId-59089></A>Typecode Listing</H6></CAPTION>
  <TBODY>
  <TR>
    <TH>
      <P class=CellHeading><A name=pgfId-59095></A>Variable defined in<BR><EM 
      class=Code>Typecode</EM> module</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-59097></A>Typecode<BR>character</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-59099></A>Description</P></TH></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59101></A><EM class=Code>Char</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59103></A><EM class=Code>'c'</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59105></A>Single-character 
  strings</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59107></A><EM class=Code>PyObject</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59109></A><EM class=Code>'O'</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59111></A>Reference to Python 
  object</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59113></A><EM class=Code>UnsignedInt8</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59115></A><EM class=Code>'b'</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59117></A>Unsigned integer using a single 
      byte.</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59119></A><EM class=Code>Int</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59121></A><EM class=Code>'l'</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59123></A>Python standard integers (i.e. C 
      long integers)</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59125></A><EM class=Code>Float</EM> 
</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59127></A><EM class=Code>'d'</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59129></A>Python standard floating point 
      numbers<BR>(i.e. C double-precision floats)</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59131></A>n/a</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59133></A><EM class=Code>'f'</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59135></A>Single-precision floating point 
      numbers</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59137></A><EM class=Code>Complex</EM> 
    </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59139></A><EM class=Code>'D'</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59141></A>Complex numbers consisting of 
      two double-precision floats</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59143></A>n/a</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59145></A><EM class=Code>'F'</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59147></A>Complex numbers consisting of 
      two single-precision floats</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59149></A><EM class=Code>Int0, Int8, 
      Int16, Int32, Int64, Int128</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59151></A>n/a</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59153></A>These correspond to 
      machine-dependent typecodes: <EM class=Code>Int0</EM> returns the typecode 
      corresponding to the smallest available integer, <EM class=Code>Int8</EM> 
      that corresponding to the smallest available integer with at least 8 bits, 
      <EM class=Code>Int16</EM> that with at least 16 bits, etc. If a typecode 
      is not available (e.g. <EM class=Code>Int64</EM> on a 32-bit machine), the 
      variable is not defined.</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59155></A><EM class=Code>Float0, Float8, 
      Float16, Float32, Float64, Float128</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59157></A>n/a</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59159></A>Same as <EM class=Code>Int0</EM> 
      , <EM class=Code>Int8</EM> etc. except for floating point 
  numbers.</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-59161></A><EM class=Code>Complex0, 
      Complex8, Complex16, Complex32, Complex64, Complex128</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59163></A>n/a</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-59165></A>Same as <EM 
      class=Code>Float0</EM> , etc., except that the number of bits refers to 
      the precision of each of the two (real and imaginary) parts of the complex 
      number.</P></TD></TR></TBODY></TABLE>
<P class=Body><A name=pgfId-66448></A>Note on number fomat: the binary format 
used by Python is that of the underlying C library. [notes about IEEE formats, 
etc?]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59290></A><A name=marker-59724></A>Indexing 
in and out, slicing</H6>
<P class=FirstBody><A name=pgfId-59291></A>Indexing arrays works like indexing 
of other Python sequences, but supports some extensions which are as of yet not 
implemented for other sequence types<A class=footnote 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#pgfId-59294">2</A>. 
The standard [start:stop] notation is supported, with start defaulting to 0 (the 
first index position) and stop defaulting to the length of the sequence, as for 
lists and tuples. In addition, there is an optional stride argument, which 
specifies the stride size between successive indices in the slice. It is 
expressed by a integer following a second : immediately after the usual 
start:stop slice. Thus <EM class=Code>[0:11:2]</EM> will slice the array at 
indices 0, 2, 4, .. 10. The start and stop indices are optional, but the first : 
must be specified for the stride interpretation to occur. Therefore, <EM 
class=Code>[::2]</EM> <A name=marker-59857></A>means slice from beginning to 
end, with a stride of 2 (i.e. skip an index for each stride). If the start index 
is omitted and the stride is negative, the indexing starts from the end of the 
sequence and works towards the beginning of the sequence. If the stop index is 
omitted and the stride is negative, the indexing stops at the beginning of the 
sequence.</P>
<P class=Python><A name=pgfId-59295></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-59296></A>[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16 17 18 19]</P>
<P class=Python><A name=pgfId-59297></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[10]</EM> </P>
<P class=Python><A name=pgfId-59298></A>10</P>
<P class=Python><A name=pgfId-59299></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[:10]</EM> </P>
<P class=Python><A name=pgfId-59300></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P class=Python><A name=pgfId-59301></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[5:15:3]</EM> </P>
<P class=Python><A name=pgfId-59302></A>[ 5 8 11 14]</P>
<P class=Python><A name=pgfId-59303></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[:10:2]</EM> </P>
<P class=Python><A name=pgfId-59304></A>[0 2 4 6 8]</P>
<P class=Python><A name=pgfId-59305></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[10::-2]</EM> </P>
<P class=Python><A name=pgfId-59306></A>[10 8 6 4 2 0]</P>
<P class=Python><A name=pgfId-59307></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[::-1]</EM> </P>
<P class=Python><A name=pgfId-59308></A>[19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 
4 3 2 1 0]</P>
<P class=Body><A name=pgfId-59309></A>It is important to note that the 
out-of-bounds conditions follow the same rules as standard Python indexing, so 
that slices out of bounds are trimmed to the sequence boundaries, but element 
indexing with out-of-bound indices yields an IndexError:</P>
<P class=Python><A name=pgfId-59310></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[:100]</EM> </P>
<P class=Python><A name=pgfId-59311></A>[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16 17 18 19]</P>
<P class=Python><A name=pgfId-59312></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[-200:4]</EM> </P>
<P class=Python><A name=pgfId-59313></A>[0 1 2 3]</P>
<P class=Python><A name=pgfId-59314></A>&gt;&gt;&gt; <EM 
class=CodeInput>x[100]</EM> </P>
<P class=Python><A name=pgfId-59315></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-59316></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-59317></A>IndexError: index out of bounds</P>
<P class=Body><A name=pgfId-59318></A>The second difference between array 
indexing and other sequences is that arrays provide multidimensional indexing. 
An array of rank N can be indexed with up to N indices or slices (or 
combinations thereof. Indices should be integers (with negative integers 
indicating offsets from the end of the dimension, as for other Python 
sequences), and slices can have, as explained above, one or two :'s separating 
integer arguments. These indices and slies must be separated by commas, and 
correspond to sequential dimensions starting from the leftmost (first) index on. 
Thus <EM class=Code>a[3]</EM> means index 3 along dimension 0. <EM 
class=Code>a[3,:,-4]</EM> means the slice of a along three dimensions: index 3 
along the first dimension, the entire range of indices along the second 
dimension, and the 4th from the end index along the third dimension. If the 
array being indexed has more dimensions than are specified in the 
multidimensional slice, those dimensions are assumed to be sliced from beginning 
to end. Thus, if <EM class=Code>a</EM> is a rank 3 array,</P></DIV>
<DIV>
<H6 class=CodeDefinition><A name=pgfId-59319></A><EM class=Code>a[0] == a[0,:] 
== a[0,:,:]</EM> </H6>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59320></A><A 
name=marker-59725></A>Ellipses</H6>
<P class=FirstBody><A name=pgfId-59321></A>A special slice element called 
Ellipses (and written <EM class=Code>...</EM> ) is used to refer to a variable 
number of slices from beginning to end along the current dimension. It is a 
shorthand for a set of such slices, specifically the number of dimensions of the 
array being indexed minus those which are already specified. Only the first 
(leftmost) Ellipses in an multidimensional slice is expanded, while the others 
are single dimensional slices from beginning to end.</P>
<P class=Body><A name=pgfId-59322></A>Thus, if <EM class=Code>a</EM> is a rank-6 
array,</P></DIV></DIV>
<DIV>
<H6 class=Code><A name=pgfId-59323></A><EM class=Code>a[3,:,:,:,-1,:] == 
a[3,...,-1,:] == a[3,...,-1,...]</EM> .</H6>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59324></A><A 
name=marker-59726></A>NewAxis</H6>
<P class=FirstBody><A name=pgfId-59325></A>There is another special symbol which 
can be used inside indexing operations to create new dimensions in the returned 
array. The reference NewAxis, used as one of the comma-separated slice elements, 
does not change the selection of the subset of the array being indexed, but 
changes the shape of the array returned by the indexing operation, so that an 
additional dimension (of length 1) is created, at the dimension position 
corresponding to the location of NewAxis within the indexing sequence. Thus, <EM 
class=Code>a[:,3,NewAxis,-3]</EM> will perform the indexing of a corresponding 
to the slice <EM class=Code>[a:,3,-3]</EM> , but will also modify the shape of a 
so that the new shape of <EM class=Code>a</EM> is <EM class=Code>(a.shape[0], 
a.shape[1], 1, a.shape[2])</EM> . This operation is especially useful in 
conjunction with the broadcasting feature described next, as it replaces a 
lengthy but common operation with a simple notation (in the example above, the 
same effect can be had with</P>
<P class=Body><A name=pgfId-59326></A><EM class=Code>reshape(a[:,3,-1], 
(a.shape[0], a.shape[1], 1, a.shape[2])).</EM> </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59327></A>Set-indexing and <A 
name=marker-59727></A>Broadcasting</H6>
<P class=FirstBody><A name=pgfId-59328></A>The indexing rules described so far 
specify exactly the behavior of get-indexing. For set-indexing, the rules are 
exactly the same, and describe the slice of the array on the left hand side of 
the assignment operator which is the target of the assignment. The only point 
left to mention is the process of assigning from the source (on the right hand 
side of the assignment) to the target (on the left hand side).</P>
<P class=Body><A name=pgfId-59329></A>If both source and target have the same 
shape, then the assignment is done element by element. The typecode of the 
target specifies the casting which can be applied in the case of a typecode 
mismatch between source and target. If the typecode of the source is "lower" 
than that of the target, then an 'up-cast' is performed and no loss in precision 
results. If the typecode of the source is "higher" than that of the target, then 
a downcast is performed, which may lose precision (as discussed in the 
description of the array call, these casts are truncating casts, not rounding 
casts). Complex numbers cannot be cast to non-complex numbers.</P>
<P class=Body><A name=pgfId-59330></A>If the source and the target have 
different shapes, Numeric Python attempts to broadcast the contents of the 
source over the range of the target. This broadcasting occurs for all dimensions 
where the source has dimension 1 or 0 (i.e., is absent). If there exists a 
dimension for which the two arrays have differing lengths, and the length of 
that dimension in the source is not 1, then the assignment fails and an 
exception (ValueError) is raised, notifying the user that the arrays are not 
aligned.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59331></A>Axis specifications</H6>
<P class=FirstBody><A name=pgfId-59332></A>In many of the functions defined in 
this document, indices are used to refer to axes. The numbering scheme is the 
same as that used by indexing in Python: the first (leftmost) axis is axis 0, 
the second axis is axis 1, etc. Axis -1 refers to the last axis, -2 refers to 
the next-to-last axis, etc.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59333></A><A name=marker-59728></A><A 
name=39358></A>Textual representations of arrays</H6>
<P class=FirstBody><A name=pgfId-59334></A>The algorithm used to display arrays 
as text strings is defined in the file ArrayPrinter.py, which defines a function 
array2string (imported into Numeric's namespace) which offers considerable 
control over how arrays are output. The range of options to the array2string 
function will be described first, followed by a description of which options are 
used by default by <EM class=Code>str</EM> and <EM class=Code>repr</EM> .</P>
<P class=Body><A name=pgfId-84285></A>Note that the optional package MA, if 
imported, modifies this process so that very long arrays are not printed; 
rather, a summary of their shape and type are shown. You may wish to import MA 
even if you do not use it otherwise, to get this effect, because without it 
accidentally attempting to print a very long array can take a very long time to 
convert, giving the appearance that the program has hung.</P>
<P class=Python><A name=pgfId-59335></A><A name=marker-59729></A>array2string(a, 
max_line_width = None, precision = None,<BR>suppress_small = None, separator=' 
', array_output=0):</P>
<P class=Body><A name=pgfId-59336></A>The <EM class=Code>array2string</EM> 
function takes an array and returns a textual representation of it. Each 
dimension is indicated by a pair of matching square brackets (<EM class=Code> 
[]</EM> ), within which each subset of the array is output. The orientation of 
the dimensions is as follows: the last (rightmost) dimension is always 
horizontal, so that the frequent rank-1 arrays use a minimum of screen 
real-estate. The next-to-last dimension is displayed vertically if present, and 
any earlier dimension is displayed with additional bracket divisions. For 
example:</P>
<P class=Python><A name=pgfId-59337></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
arange(24)</EM> </P>
<P class=Python><A name=pgfId-59338></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(a)</EM> </P>
<P class=Python><A name=pgfId-59339></A>[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16 17 18 19 20 21 22 23]</P>
<P class=Python><A name=pgfId-59340></A>&gt;&gt;&gt; <EM class=CodeInput>a.shape 
= (2,10)</EM> </P>
<P class=Python><A name=pgfId-59341></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(a)</EM> </P>
<P class=Python><A name=pgfId-59342></A>[[ 0 1 2 3 4 5 6 7 8 9 10 11]</P>
<P class=Python><A name=pgfId-59343></A>[12 13 14 15 16 17 18 19 20 21 22 
23]]</P>
<P class=Python><A name=pgfId-59344></A>&gt;&gt;&gt; <EM class=CodeInput>a.shape 
= (2,3,4)</EM> </P>
<P class=Python><A name=pgfId-59345></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(a)</EM> </P>
<P class=Python><A name=pgfId-59346></A>[[[ 0 1 2 3]</P>
<P class=Python><A name=pgfId-59347></A>[ 4 5 6 7]</P>
<P class=Python><A name=pgfId-59348></A>[ 8 9 10 11]]</P>
<P class=Python><A name=pgfId-59349></A>[[12 13 14 15]</P>
<P class=Python><A name=pgfId-59350></A>[16 17 18 19]</P>
<P class=Python><A name=pgfId-59351></A>[20 21 22 23]]]</P>
<P class=Body><A name=pgfId-59352></A>The <EM class=Code>max_line_width</EM> 
argument specifies the maximum number of characters which the array2string 
routine uses in a single line. If it is set to <EM class=Code>None</EM> , then 
the value of the <EM class=Code>sys.output_line_width</EM> attribute is looked 
up. If it exists, it is used. If not, the default of 77 characters is used.</P>
<P class=Python><A name=pgfId-59353></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x)</EM> </P>
<P class=Python><A name=pgfId-59354></A>[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16 17 18 19 20 21 22 23 24 25</P>
<P class=Python><A name=pgfId-59355></A>26 27 28 29]</P>
<P class=Python><A name=pgfId-59356></A>&gt;&gt;&gt; <EM 
class=CodeInput>sys.output_line_width = 30</EM> </P>
<P class=Python><A name=pgfId-59357></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x)</EM> </P>
<P class=Python><A name=pgfId-59358></A>[ 0 1 2 3 4 5 6 7 8 9</P>
<P class=Python><A name=pgfId-59359></A>10 11 12 13 14 15 16 17</P>
<P class=Python><A name=pgfId-59360></A>18 19 20 21 22 23 24 25</P>
<P class=Python><A name=pgfId-59361></A>26 27 28 29]</P>
<P class=Body><A name=pgfId-59362></A>The <EM class=Code>precision</EM> argument 
specifies the number of digits after the decimal point which are used. If a 
value of <EM class=Code>None</EM> is used, the value of the <EM 
class=Code>sys.float_output_precision</EM> is looked up. If it exists, it is 
used. If not, the default of 8 digits is used.</P>
<P class=Python><A name=pgfId-59363></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
array((10.11111111111123123111, pi))</EM> </P>
<P class=Python><A name=pgfId-59364></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x)</EM> </P>
<P class=Python><A name=pgfId-59365></A>[ 10.11111111 3.14159265]</P>
<P class=Python><A name=pgfId-59366></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x, precision=3)</EM> </P>
<P class=Python><A name=pgfId-59367></A>[ 10.111 3.142]</P>
<P class=Python><A name=pgfId-59368></A>&gt;&gt;&gt; <EM 
class=CodeInput>sys.float_output_precision = 2</EM> </P>
<P class=Python><A name=pgfId-59369></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x)</EM> </P>
<P class=Python><A name=pgfId-59370></A>[ 10.11 3.14]</P>
<P class=Body><A name=pgfId-59371></A>The <EM class=Code>suppress_small</EM> 
argument specifies whether small values should be suppressed (and output as 0). 
If a value of <EM class=Code>None</EM> is used, the value of the <EM 
class=Code>sys.float_output_suppress_small</EM> is looked up. If it exists, it 
is used (all that matters is whether it evaluates to true or false). If not, the 
default of 0 (false) is used. This variable also interacts with the precision 
parameters, as it can be used to suppress the use of exponential notation.</P>
<P class=Python><A name=pgfId-59372></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-59373></A>[ 1.00000000e-005 3.14159265e+000]</P>
<P class=Python><A name=pgfId-59374></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x)</EM> </P>
<P class=Python><A name=pgfId-59375></A>[ 1.00000000e-005 3.14159265e+000]</P>
<P class=Python><A name=pgfId-59376></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x, suppress_small=1)</EM> </P>
<P class=Python><A name=pgfId-59377></A>[ 0.00001 3.14159265]</P>
<P class=Python><A name=pgfId-59378></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x, precision=3)</EM> </P>
<P class=Python><A name=pgfId-59379></A>[ 1.000e-005 3.142e+000]</P>
<P class=Python><A name=pgfId-59380></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x, precision=3, suppress_small=1)</EM> </P>
<P class=Python><A name=pgfId-59381></A>[ 0. 3.142]</P>
<P class=Body><A name=pgfId-59382></A>The <EM class=Code>separator</EM> argument 
is used to specify what character string should be placed between two numbers 
which do not straddle a dimension. The default is a single space.</P>
<P class=Python><A name=pgfId-59383></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x)</EM> </P>
<P class=Python><A name=pgfId-59384></A>[ 0 100 200 300 400 500 600 700 800 900 
100]</P>
<P class=Python><A name=pgfId-59385></A>&gt;&gt;&gt; <EM class=CodeInput>print 
array2string(x, separator = ', ')</EM> </P>
<P class=Python><A name=pgfId-59386></A>[ 0, 100, 200, 300, 400, 500, 600, 700, 
800, 900, 100]</P>
<P class=Body><A name=pgfId-60840></A>Finally, the last attribute, array_output, 
specifies whether to prepend the string "array(" and append either the string 
")" or ", 'X')" where X is a typecode for non-default typecodes (in other words, 
the typecode will only be displayed if it is not that corresponding to Float, 
Complex or Int, which are the standard typecodes associated with floating point 
numbers, complex numbers and integers respectively). The array() is so that an 
eval of the returned string will return an array object (provided a comma 
separator is also used).</P>
<P class=Python><A name=pgfId-59388></A>&gt;&gt;&gt; <EM 
class=CodeInput>array2string(arange(3)) </EM></P>
<P class=Python><A name=pgfId-59389></A>[0 1 2]</P>
<P class=Python><A name=pgfId-59390></A>&gt;&gt;&gt; <EM 
class=CodeInput>eval(array2string(arange(3), array_output=1))</EM> </P>
<P class=Python><A name=pgfId-59391></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-59392></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-59393></A>File "&lt;string&gt;", line 1</P>
<P class=Python><A name=pgfId-59394></A>array([0 1 2])</P>
<P class=Python><A name=pgfId-59395></A>^</P>
<P class=Python><A name=pgfId-59396></A>SyntaxError: invalid syntax</P>
<P class=Python><A name=pgfId-59397></A>&gt;&gt;&gt; <EM 
class=CodeInput>type(eval(array2string(arange(3), array_output=1, 
separator=',')))</EM> </P>
<P class=Python><A name=pgfId-59398></A>&lt;type 'array'&gt; </P>
<P class=Python><A name=pgfId-59399></A>&gt;&gt;&gt; <EM 
class=CodeInput>array2string(arange(3), array_output=1) </EM></P>
<P class=Python><A name=pgfId-59400></A>'array([0, 1, 2])'</P>
<P class=Python><A name=pgfId-59401></A>&gt;&gt;&gt; <EM 
class=CodeInput>array2string(zeros((3,), 'i') + arange(3), array_output=1)</EM> 
</P>
<P class=Python><A name=pgfId-59402></A>"array([0, 1, 2],'i')"</P>
<P class=Body><A name=pgfId-59403></A>The <EM class=Code>str</EM> and <EM 
class=Code>repr</EM> operations on arrays call <EM class=Code>array2string</EM> 
with the <EM class=Code>max_line_width</EM> , <EM class=Code>precision</EM> and 
<EM class=Code>suppress_small</EM> all set to None, meaning that the defaults 
are used, but that modifying the attributes in the <EM class=Code>sys</EM> 
module will affect array printing. str uses the default separator and does not 
use the array() text, while repr uses a comma as a separator and does use the 
array(...) text.</P>
<P class=Python><A name=pgfId-59404></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
arange(3)</EM> </P>
<P class=Python><A name=pgfId-59405></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-59406></A>[0 1 2]</P>
<P class=Python><A name=pgfId-59407></A>&gt;&gt;&gt; <EM 
class=CodeInput>str(x)</EM> </P>
<P class=Python><A name=pgfId-59408></A>'[0 1 2]'</P>
<P class=Python><A name=pgfId-59409></A>&gt;&gt;&gt; <EM 
class=CodeInput>repr(x)</EM> </P>
<P class=Python><A name=pgfId-59410></A>'array([0, 1, 2])' # note the array(...) 
and ,'s</P>
<P class=Python><A name=pgfId-59411></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
arange(0,.01,.001)</EM> </P>
<P class=Python><A name=pgfId-59412></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-59413></A>[ 0. 0.001 0.002 0.003 0.004 0.005 0.006 
0.007 0.008 0.009]</P>
<P class=Python><A name=pgfId-59414></A>&gt;&gt;&gt; <EM class=CodeInput>import 
sys</EM> </P>
<P class=Python><A name=pgfId-59415></A>&gt;&gt;&gt; <EM 
class=CodeInput>sys.float_output_precision = 2</EM> </P>
<P class=Python><A name=pgfId-59416></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-59417></A>[ 0. 0. 0. 0. 0. 0.01 0.01 0.01 0.01 
0.01]</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59418></A>Comparisons</H6>
<P class=FirstBody><A name=pgfId-67224></A>Comparisons of multiarray objects 
results using the normal comparison operators (such as == or &gt;) result in 
exceptions. Python requires that the result of a comparison be a scalar, not the 
vector we would want as the result of elementwise comparison. </P>
<P class=Body><A name=pgfId-84161></A>Therefore, for comparisons you must use 
the routines for comparison describe in <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#93991">Logical 
Ufuncs</A>.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-67223></A><A name=marker-59730></A>Pickling 
and <A name=marker-59731></A>Unpickling -- storing arrays on disk</H6>
<P class=FirstBody><A name=pgfId-68425></A>This documentation has not yet been 
written, but pickling of Numeric arrays is possible.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-59422></A>Dealing with <A 
name=marker-59732></A>floating point exceptions</H6>
<P class=FirstBody><A name=pgfId-59423></A><A name=marker-59733></A>Attempts to 
use NaN's as missing values have proven frustrating and not very portable. 
Consider <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#48250">Masked 
Arrays</A> instead.</P>
<P class=Body><A name=pgfId-84172></A>fpectl should be documented here 
...</P></DIV></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-36640></A>12. <A name=69650></A>Writing a C 
extension to NumPy</H2>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36641></A>Introduction</H6>
<P class=Body><A name=pgfId-36642></A>There are two applications that require 
using the NumPy array type in C extension modules: </P>
<UL>
  <LI class=Bullet><A name=pgfId-36643></A>Access to numerical libraries: 
  Extension modules can be used to make numerical libraries written in C (or 
  languages linkable to C, such as Fortran) accessible to Python programs. The 
  NumPy array type has the advantage of using the same data layout as arrays in 
  C and Fortran. 
  <LI class=Bullet><A name=pgfId-36644></A>Mixed-language numerical code: In 
  most numerical applications, only a small part of the total code is CPU time 
  intensive. Only this part should thus be written in C, the rest can be written 
  in Python. NumPy arrays are important for the interface between these two 
  parts, because they provide equally simple access to their contents from 
  Python and from C. </LI></UL>
<P class=Body><A name=pgfId-36645></A>This document is a tutorial for using 
NumPy arrays in C extensions. </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36646></A>Preparing an extension module for 
NumPy arrays</H6>
<P class=Body><A name=pgfId-36647></A>To make NumPy arrays available to an 
extension module, it must include the header file <EM 
class=Code>arrayobject.h</EM> <A name=marker-59737></A>, after the header file 
Python.h that is obligatory for all extension modules. The file <EM 
class=Code>arrayobject.h</EM> comes with the NumPy distribution; depending on 
where it was installed on your system you might have to tell your compiler how 
to find it. By default <A name=marker-68604></A><A 
name=marker-68605></A>Distutils installed in a subdirectory Numeric in your 
Python include path, and so you should include it this way:</P>
<P class=C-Code><A name=pgfId-68594></A>#include "Numeric/arrayobject.h"</P>
<DIV>
<H6 class=NoteTip><A name=pgfId-68429></A>
<DIV><IMG src="numdoc_files/numdoc-3.gif"> </DIV>&nbsp;</H6>
<P class=Note><A name=pgfId-68455></A>Is your C extension using Numeric blowing 
up? Maybe you didn't call import_array().</P>
<DIV>
<H6 class=NoteBottom><A name=pgfId-68451></A>
<DIV><IMG src="numdoc_files/numdoc-4.gif"> </DIV>&nbsp;</H6>
<P class=Body><A name=pgfId-68428></A>In addition to including <EM 
class=Code>arrayobject.h</EM> , the extension must call <EM 
class=Code>import_array()</EM> in its initialization function, after the call to 
<EM class=Code>Py_InitModule()</EM> . This call makes sure that the module which 
implements the array type has been imported, and initializes a pointer array 
through which the NumPy functions are called. If you forget this call, your 
extension module will crash on the first call to a NumPy function! If you will 
be manipulating ufunc objects, you should also include the file <EM 
class=Code>ufuncobject.h</EM> <A name=marker-59738></A>, also available as part 
of the NumPy distribution in the <EM class=Code>Include</EM> directory and 
usually installed in subdirectory Numeric.</P>
<P class=Body><A name=pgfId-36648></A>All of the rules related to writing 
extension modules for Python apply. The reader unfamiliar with these rules is 
encouraged to read the standard text on the topic, "Extending and Embedding the 
Python Interpreter," available as part of the standard Python documentation 
distribution.</P></DIV></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36649></A>Accessing NumPy arrays from C</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36650></A>Types and Internal Structure</H6>
<P class=Body><A name=pgfId-36651></A>NumPy arrays are defined by the structure 
<EM class=Code>PyArrayObject</EM> <A name=marker-59739></A>, which is an 
extension of the structure <EM class=Code>PyObject</EM> . Pointers to <EM 
class=Code>PyArrayObject</EM> can thus safely be cast to <EM 
class=Code>PyObject</EM> pointers, whereas the inverse is safe only if the 
object is known to be an array. The type structure corresponding to array 
objects is <EM class=Code>PyArray_Type</EM> . The structure <EM 
class=Code>PyArrayObject</EM> has four elements that are needed in order to 
access the array's data from C code: </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-36652></A><EM class=Code>int nd</EM> 
</H6>
<P class=BulletLev2Continuation><A name=pgfId-36653></A>The number of dimensions 
in the array.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-36654></A><EM class=Code>int 
*dimensions</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-36655></A>A pointer to an array of 
<EM class=Code>nd</EM> integers, describing the number of elements along each 
dimension. The sizes are in the conventional order, so that for any array <EM 
class=Code>a</EM> , <BR><EM class=Code>a.shape==(dimensions[0], dimensions[1], 
..., dimensions[nd])</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-36656></A><EM class=Code>int 
*strides</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-36657></A>A pointer to an array of 
<EM class=Code>nd</EM> integers, describing the address offset between two 
successive data elements along each dimension. Note that strides can also be 
negative! Each number gives the number of bytes to add to a pointer to get to 
the next element in that dimension. For example, if <EM class=Code>myptr</EM> 
currently points to element of a rank-5 array at indices <EM 
class=Code>1,0,5,3,2</EM> and you want it to point to element <EM 
class=Code>1,0,5,4,2</EM> then you should add <EM class=Code>strides[3]</EM> to 
the pointer: <EM class=Code>myptr += strides[3]</EM> . This works even if (and 
is especially useful when) the array is not contiguous in memory.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-36658></A><EM class=Code>char 
*data</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-36659></A>A pointer to the first 
data element of the array.</P>
<P class=Body><A name=pgfId-36660></A>The address of a data element can be 
calculated from its indices and the data and strides pointers. For example, 
element <EM class=Code>[i, j]</EM> of a two-dimensional array has the address 
<EM class=Code>data + i*array-&gt;strides[0] + j*array-&gt;strides[1]</EM> . 
Note that the stride offsets are in bytes, not in storage units of the array 
elements. Therefore address calculations must be made in bytes as well, starting 
from the data pointer, which is always a char pointer. To access the element, 
the result of the address calculation must be cast to a pointer of the required 
type. The advantage of this arrangement is that purely structural array 
operations (indexing, extraction of subarrays, etc.) do not have to know the 
type of the array elements. </P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36661></A>Element data types</H6>
<P class=Body><A name=pgfId-36662></A>The type of the array elements is 
indicated by a type number, whose possible values are defined as constants in 
<EM class=Code>arrayobject.h</EM> , as given in Table 3.</P>
<TABLE border=1>
  <CAPTION>
  <H6 class=TableTitle><A name=pgfId-36665></A>C constants corresponding to 
  storage types</H6></CAPTION>
  <TBODY>
  <TR>
    <TH>
      <P class=CellHeading><A name=pgfId-36669></A>Constant</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-36671></A>element data type</P></TH></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36673></A><EM class=Code>PyArray_CHAR</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36675></A><EM class=Code>char</EM> 
  </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36677></A><EM 
      class=Code>PyArray_UBYTE</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36679></A><EM class=Code>unsigned 
      char</EM> </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36681></A><EM 
      class=Code>PyArray_SBYTE</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36683></A><EM class=Code>signed char</EM> 
      </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36685></A><EM 
      class=Code>PyArray_SHORT</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36687></A><EM class=Code>short</EM> 
  </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36689></A><EM class=Code>PyArray_INT</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36691></A><EM class=Code>int</EM> 
  </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36693></A><EM class=Code>PyArray_LONG</EM> 
      </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36695></A><EM class=Code>long</EM> 
  </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36697></A><EM 
      class=Code>PyArray_FLOAT</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36699></A><EM class=Code>float</EM> 
  </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36701></A><EM 
      class=Code>PyArray_DOUBLE</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36703></A><EM class=Code>double</EM> 
    </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36705></A><EM 
      class=Code>PyArray_CFLOAT</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36707></A><EM class=Code>float[2]</EM> 
    </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36709></A><EM 
      class=Code>PyArray_CDOUBLE</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36711></A><EM class=Code>double[2]</EM> 
      </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-36713></A><EM 
      class=Code>PyArray_OBJECT</EM> </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-36715></A><EM class=Code>PyObject *</EM> 
      </P></TD></TR></TBODY></TABLE>
<P class=Body><A name=pgfId-36716></A>The type number is stored in <EM 
class=Code>array-&gt;descr-&gt;type_num</EM> . Note that the names of the 
element type constants refer to the C data types, not the Python data types. A 
Python <EM class=Code>int</EM> is equivalent to a C <EM class=Code>long</EM> , 
and a Python <EM class=Code>float</EM> corresponds to a C <EM 
class=Code>double</EM> . Many of the element types listed above do not have 
corresponding Python scalar types (e.g. <EM class=Code>PyArray_INT</EM> ). 
</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36717></A><A name=marker-59740></A>Contiguous 
arrays</H6>
<P class=Body><A name=pgfId-36718></A>An important special case of a NumPy array 
is the contiguous array. This is an array whose elements occupy a single 
contiguous block of memory and have the same order as a standard C array. In a 
contiguous array, the value of <EM class=Code>array-&gt;strides[i]</EM> is equal 
to the size of a single array element times the product of <EM 
class=Code>array-&gt;dimensions[j]</EM> for <EM class=Code>j</EM> up to <EM 
class=Code>i-1</EM> . Arrays that are created from scratch are always 
contiguous; non-contiguous arrays are the result of indexing and other 
structural array operations. The main advantage of contiguous arrays is easier 
handling in C; the pointer <EM class=Code>array-&gt;data</EM> is cast to the 
required type and then used like a C array, without any reference to the stride 
values. This is particularly important when interfacing to existing libraries in 
C or Fortran, which typically require this standard data layout. A function that 
requires input arrays to be contiguous must call the conversion function <EM 
class=Code>PyArray_ContiguousFromObject()</EM> , described in the section 
"Accepting input data from any sequence type".</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-36719></A><A 
name=marker-59741></A>Zero-dimensional arrays</H6>
<P class=Body><A name=pgfId-36720></A>NumPy permits the creation and use of 
zero-dimensional arrays, which can be useful to treat scalars and 
higher-dimensional arrays in the same way. However, library routines for general 
use should not return zero-demensional arrays, because most Python code is not 
prepared to handle them. Moreover, zero-dimensional arrays can create confusion 
because they behave like ordinary Python scalars in many circumstances but are 
of a different type. A comparison between a Python scalar and a zero-dimensional 
array will always fail, for example, even if the values are the same. NumPy 
provides a conversion function from zero-dimensional arrays to Python scalars, 
which is described in the section "Returning arrays from C functions". 
</P></DIV></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36721></A>A simple example</H6>
<P class=Body><A name=pgfId-36722></A>The following function calculates the sum 
of the diagonal elements of a two-dimensional array, verifying that the array is 
in fact two-dimensional and of type <EM class=Code>PyArray_DOUBLE</EM> . </P>
<P class=C-Code><A name=pgfId-36723></A>static PyObject *</P>
<P class=C-Code><A name=pgfId-36724></A>trace(PyObject *self, PyObject 
*args)</P>
<P class=C-Code><A name=pgfId-36725></A>{</P>
<P class=C-Code><A name=pgfId-36726></A>PyArrayObject *array;</P>
<P class=C-Code><A name=pgfId-36727></A>double sum;</P>
<P class=C-Code><A name=pgfId-36728></A>int i, n;</P>
<P class=C-Code><A name=pgfId-36729></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36730></A>if (!PyArg_ParseTuple(args, "O!",</P>
<P class=C-Code><A name=pgfId-36731></A>&amp;PyArray_Type, &amp;array))</P>
<P class=C-Code><A name=pgfId-36732></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36733></A>if (array-&gt;nd != 2 || 
array-&gt;descr-&gt;type_num != PyArray_DOUBLE) {</P>
<P class=C-Code><A name=pgfId-36734></A>PyErr_SetString(PyExc_ValueError,</P>
<P class=C-Code><A name=pgfId-36735></A>"array must be two-dimensional and of 
type float");</P>
<P class=C-Code><A name=pgfId-36736></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36737></A>}</P>
<P class=C-Code><A name=pgfId-36738></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36739></A>n = array-&gt;dimensions[0];</P>
<P class=C-Code><A name=pgfId-36740></A>if (n &gt; array-&gt;dimensions[1])</P>
<P class=C-Code><A name=pgfId-36741></A>n = array-&gt;dimensions[1];</P>
<P class=C-Code><A name=pgfId-36742></A>sum = 0.;</P>
<P class=C-Code><A name=pgfId-36743></A>for (i = 0; i &lt; n; i++)</P>
<P class=C-Code><A name=pgfId-36744></A>sum += *(double *)(array-&gt;data + 
i*array-&gt;strides[0] + i*array-&gt;strides[1]);</P>
<P class=C-Code><A name=pgfId-36745></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36746></A>return PyFloat_FromDouble(sum);</P>
<P class=C-Code><A name=pgfId-36747></A>}</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36748></A>Accepting input data from any 
sequence type</H6>
<P class=Body><A name=pgfId-36749></A>The example in the last section requires 
its input to be an array of type double. In many circumstances this is 
sufficient, but often, especially in the case of library routines for general 
use, it would be preferable to accept input data from any sequence (lists, 
tuples, etc.) and to convert the element type to double automatically where 
possible. NumPy provides a function that accepts arbitrary sequence objects as 
input and returns an equivalent array of specified type (this is in fact exactly 
what the array constructor <EM class=Code>Numeric.array()</EM> does in Python 
code): </P>
<P class=C-Code><A name=pgfId-36750></A>PyObject *</P>
<P class=C-Code><A name=pgfId-36751></A>PyArray_ContiguousFromObject(PyObject 
*object,</P>
<P class=C-Code><A name=pgfId-36752></A>int type_num,</P>
<P class=C-Code><A name=pgfId-36753></A>int min_dimensions,</P>
<P class=C-Code><A name=pgfId-36754></A>int max_dimensions);</P>
<P class=Body><A name=pgfId-36755></A>The first argument, object, is the 
sequence object from which the data is taken. The second argument, type_num, 
specifies the array element type (see the table in the section "Element data 
types". If you want the function to the select the ``smallest'' type that is 
sufficient to store the data, you can pass the special value <EM 
class=Code>PyArray_NOTYPE</EM> . The remaining two arguments let you specify the 
number of dimensions of the resulting array, which is guaranteed to be no 
smaller than <EM class=Code>min_dimensions</EM> and no larger than <EM 
class=Code>max_dimensions</EM> , except for the case <EM 
class=Code>max_dimensions == 0</EM> , which means that no upper limit is 
imposed.</P>
<P class=Body><A name=pgfId-36756></A>If the input data is not compatible with 
the type or dimension restrictions, an exception is raised. Since the array 
returned by <EM class=Code>PyArray_ContiguousFromObject()</EM> is guaranteed to 
be contiguous, this function also provides a method of converting a 
non-contiguous array to a contiguous one. If the input object is already a 
contiguous array of the specified type, it is passed on directly; there is thus 
no performance or memory penalty for calling the conversion function when it is 
not required. Using this function, the example from the last section becomes 
</P>
<P class=C-Code><A name=pgfId-36757></A>static PyObject *</P>
<P class=C-Code><A name=pgfId-36758></A>trace(PyObject *self, PyObject 
*args)</P>
<P class=C-Code><A name=pgfId-36759></A>{</P>
<P class=C-Code><A name=pgfId-36760></A>PyObject *input;</P>
<P class=C-Code><A name=pgfId-36761></A>PyArrayObject *array;</P>
<P class=C-Code><A name=pgfId-36762></A>double sum;</P>
<P class=C-Code><A name=pgfId-36763></A>int i, n;</P>
<P class=C-Code><A name=pgfId-36764></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36765></A>if (!PyArg_ParseTuple(args, "O", 
&amp;input))</P>
<P class=C-Code><A name=pgfId-36766></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36767></A>array = (PyArrayObject *)</P>
<P class=C-Code><A name=pgfId-36768></A>PyArray_ContiguousFromObject(input, 
PyArray_DOUBLE, 2, 2);</P>
<P class=C-Code><A name=pgfId-36769></A>if (array == NULL)</P>
<P class=C-Code><A name=pgfId-36770></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36771></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36772></A>n = array-&gt;dimensions[0];</P>
<P class=C-Code><A name=pgfId-36773></A>if (n &gt; array-&gt;dimensions[1])</P>
<P class=C-Code><A name=pgfId-36774></A>n = array-&gt;dimensions[1];</P>
<P class=C-Code><A name=pgfId-36775></A>sum = 0.;</P>
<P class=C-Code><A name=pgfId-36776></A>for (i = 0; i &lt; n; i++)</P>
<P class=C-Code><A name=pgfId-36777></A>sum += *(double *)(array-&gt;data + 
i*array-&gt;strides[0] + i*array-&gt;strides[1]);</P>
<P class=C-Code><A name=pgfId-36778></A></P>
<P class=C-Code><A name=pgfId-36779></A>Py_DECREF(array);</P>
<P class=C-Code><A name=pgfId-36780></A>return PyFloat_FromDouble(sum);</P>
<P class=C-Code><A name=pgfId-36781></A>}</P>
<P class=Body><A name=pgfId-36782></A>Note that no explicit error checking is 
necessary in this version, and that the array reference that is returned by <EM 
class=Code>PyArray_ContiguousFromObject()</EM> must be destroyed by calling <EM 
class=Code>Py_DECREF()</EM> . </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36783></A>Creating NumPy arrays</H6>
<P class=Body><A name=pgfId-36784></A>NumPy arrays can be created by calling the 
function </P>
<P class=C-Code><A name=pgfId-36785></A>PyObject *</P>
<P class=C-Code><A name=pgfId-36786></A>PyArray_FromDims(int n_dimensions,</P>
<P class=C-Code><A name=pgfId-36787></A>int dimensions[n_dimensions],</P>
<P class=C-Code><A name=pgfId-36788></A>int type_num);</P>
<P class=Body><A name=pgfId-36789></A>The first argument specifies the number of 
dimensions, the second one the length of each dimension, and the third one the 
element data type (see the table in the section "Element data types". The array 
that is returned is contiguous, but the contents of its data space are 
undefined. There is a second function which permits the creation of an array 
object that uses a given memory block for its data space: </P>
<P class=C-Code><A name=pgfId-36790></A>PyObject *</P>
<P class=C-Code><A name=pgfId-36791></A>PyArray_FromDimsAndData(int 
n_dimensions,</P>
<P class=C-Code><A name=pgfId-36792></A>int dimensions[n_dimensions]</P>
<P class=C-Code><A name=pgfId-36793></A>int item_type</P>
<P class=C-Code><A name=pgfId-36794></A>char *data);</P>
<P class=Body><A name=pgfId-36795></A>The first three arguments are the same as 
for <EM class=Code>PyArray_FromDims()</EM> . The fourth argument is a pointer to 
the memory block that is to be used as the array's data space. It is the 
caller's responsibility to ensure that this memory block is not freed before the 
array object is destroyed. With few exceptions (such as the creation of a 
temporary array object to which no reference is passed to other functions), this 
means that the memory block may never be freed, because the lifetime of Python 
objects are difficult to predict. Nevertheless, this function can be useful in 
special cases, for example for providing Python access to arrays in Fortran 
common blocks. </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36796></A>Returning arrays from C 
functions</H6>
<P class=Body><A name=pgfId-36797></A>Array objects can of course be passed out 
of a C function just like any other object. However, as has been mentioned 
before, care should be taken not to return zero-dimensional arrays unless the 
receiver is known to be prepared to handle them. An equivalent Python scalar 
object should be returned instead. To facilitate this step, NumPy provides a 
special function </P>
<P class=C-Code><A name=pgfId-36798></A>PyObject *</P>
<P class=C-Code><A name=pgfId-36799></A>PyArray_Return(PyArrayObject 
*array);</P>
<P class=Body><A name=pgfId-36800></A>which returns the array unchanged if it 
has one or more dimensions, or the appropriate Python scalar object in case of a 
zero-dimensional array. </P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-36801></A>A less simple example</H6>
<P class=Body><A name=pgfId-36802></A>The function shown below performs a 
matrix-vector multiplication by calling the <EM class=Code>BLAS</EM> function 
<EM class=Code>DGEMV</EM> . It takes three arguments: a scalar prefactor, the 
matrix (a two-dimensional array), and the vector (a one-dimensional array). The 
return value is a one-dimensional array. The input values are checked for 
consistency. In addition to providing an illustration of the functions explained 
above, this example also demonstrates how a Fortran routine can be integrated 
into Python. Unfortunately, mixing Fortran and C code involves machine-specific 
peculiarities. In this example, two assumptions have been made: </P>
<UL>
  <LI class=Bullet><A name=pgfId-36803></A>The Fortran function <EM 
  class=Code>DGEMV</EM> must be called from C as <EM class=Code>dgemv_</EM> . 
  Many Fortran compilers apply this rule, but the C name could also be <EM 
  class=Code>dgemv</EM> or <EM class=Code>DGEMV</EM> (or in principle anything 
  else; there is no fixed standard). 
  <LI class=Bullet><A name=pgfId-36804></A>Fortran <EM class=Code>integer</EM> s 
  are equivalent to C <EM class=Code>long</EM> s, and Fortran double precision 
  numbers are equivalent to C doubles. This works for all systems that I have 
  personally used, but again there is no standard. </LI></UL>
<P class=Body><A name=pgfId-36805></A>Also note that the libraries that this 
function must be linked to are system-dependent; on my Linux system (using <EM 
class=Code>gcc</EM> /<EM class=Code> g77</EM> ), the libraries are <EM 
class=Code>blas</EM> and <EM class=Code>f2c</EM> . So here is the code: </P>
<P class=C-Code><A name=pgfId-36806></A>static PyObject *</P>
<P class=C-Code><A name=pgfId-36807></A>matrix_vector(PyObject *self, PyObject 
*args)</P>
<P class=C-Code><A name=pgfId-36808></A>{</P>
<P class=C-Code><A name=pgfId-36809></A>PyObject *input1, *input2;</P>
<P class=C-Code><A name=pgfId-36810></A>PyArrayObject *matrix, *vector, 
*result;</P>
<P class=C-Code><A name=pgfId-36811></A>int dimensions[1];</P>
<P class=C-Code><A name=pgfId-36812></A>double factor[1];</P>
<P class=C-Code><A name=pgfId-36813></A>double real_zero[1] = {0.};</P>
<P class=C-Code><A name=pgfId-36814></A>long int_one[1] = {1};</P>
<P class=C-Code><A name=pgfId-36815></A>long dim0[1], dim1[1];</P>
<P class=C-Code><A name=pgfId-36816></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36817></A>extern dgemv_(char *trans, long *m, long 
*n,</P>
<P class=C-Code><A name=pgfId-36818></A>double *alpha, double *a, long *lda,</P>
<P class=C-Code><A name=pgfId-36819></A>double *x, long *incx,</P>
<P class=C-Code><A name=pgfId-36820></A>double *beta, double *Y, long 
*incy);</P>
<P class=C-Code><A name=pgfId-36821></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36822></A>if (!PyArg_ParseTuple(args, "dOO", 
factor, &amp;input1, &amp;input2))</P>
<P class=C-Code><A name=pgfId-36823></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36824></A>matrix = (PyArrayObject *)</P>
<P class=C-Code><A name=pgfId-36825></A>PyArray_ContiguousFromObject(input1, 
PyArray_DOUBLE, 2, 2);</P>
<P class=C-Code><A name=pgfId-36826></A>if (matrix == NULL)</P>
<P class=C-Code><A name=pgfId-36827></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36828></A>vector = (PyArrayObject *)</P>
<P class=C-Code><A name=pgfId-36829></A>PyArray_ContiguousFromObject(input2, 
PyArray_DOUBLE, 1, 1);</P>
<P class=C-Code><A name=pgfId-36830></A>if (vector == NULL)</P>
<P class=C-Code><A name=pgfId-36831></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36832></A>if (matrix-&gt;dimensions[1] != 
vector-&gt;dimensions[0]) {</P>
<P class=C-Code><A name=pgfId-36833></A>PyErr_SetString(PyExc_ValueError,</P>
<P class=C-Code><A name=pgfId-36834></A>"array dimensions are not 
compatible");</P>
<P class=C-Code><A name=pgfId-36835></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36836></A>}</P>
<P class=C-Code><A name=pgfId-36837></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36838></A>dimensions[0] = 
matrix-&gt;dimensions[0];</P>
<P class=C-Code><A name=pgfId-36839></A>result = (PyArrayObject 
*)PyArray_FromDims(1, dimensions, PyArray_DOUBLE);</P>
<P class=C-Code><A name=pgfId-36840></A>if (result == NULL)</P>
<P class=C-Code><A name=pgfId-36841></A>return NULL;</P>
<P class=C-Code><A name=pgfId-36842></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36843></A>dim0[0] = 
(long)matrix-&gt;dimensions[0];</P>
<P class=C-Code><A name=pgfId-36844></A>dim1[0] = 
(long)matrix-&gt;dimensions[1];</P>
<P class=C-Code><A name=pgfId-36845></A>dgemv_("T", dim1, dim0, factor, (double 
*)matrix-&gt;data, dim1,</P>
<P class=C-Code><A name=pgfId-36846></A>(double *)vector-&gt;data, int_one,</P>
<P class=C-Code><A name=pgfId-36847></A>real_zero, (double *)result-&gt;data, 
int_one);</P>
<P class=C-Code><A name=pgfId-36848></A>&nbsp;</P>
<P class=C-Code><A name=pgfId-36849></A>return PyArray_Return(result);</P>
<P class=C-Code><A name=pgfId-36850></A>}</P>
<P class=Body><A name=pgfId-36851></A>Note that <EM 
class=Code>PyArray_Return()</EM> is not really necessary in this case, since we 
know that the array being returned is one-dimensional. Nevertheless, it is a 
good habit to always use this function; its performance cost is practically 
zero. </P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-57398></A>13. <A name=36241></A>C API 
Reference</H2>
<P class=ChapterDescription><A name=pgfId-57399></A>This chapter describes the 
API for ArrayObjects and Ufuncs.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-25107></A>ArrayObject C Structure and 
API</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-57404></A>Structures</H6>
<P class=FirstBody><A name=pgfId-32745></A>The <A 
name=marker-59742></A>PyArrayObject is, like all Python types, a kind of 
PyObject. Its definition is:</P>
<P class=C-Code><A name=pgfId-32746></A>typedef struct { </P>
<P class=C-Code><A name=pgfId-32747></A>PyObject_HEAD </P>
<P class=C-Code><A name=pgfId-32748></A>char *data; </P>
<P class=C-Code><A name=pgfId-25145></A>int nd; </P>
<P class=C-Code><A name=pgfId-25147></A>int *dimensions, *strides; </P>
<P class=C-Code><A name=pgfId-25149></A>PyObject *base; </P>
<P class=C-Code><A name=pgfId-25151></A>PyArray_Descr *descr; </P>
<P class=C-Code><A name=pgfId-25153></A>int flags; </P>
<P class=C-Code><A name=pgfId-25155></A>} PyArrayObject; </P>
<P class=Body><A name=pgfId-25137></A>Where <EM class=Code>PyObject_HEAD</EM> is 
the standard <EM class=Code>PyObject</EM> header, and the other fields 
are:</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-32763></A><EM class=Code>char</EM> *<EM 
class=Code> data</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-32764></A>A pointer to the first 
data element of the array.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-25119></A><EM class=Code>int nd</EM> 
</H6>
<P class=BulletLev2Continuation><A name=pgfId-25120></A>The number of dimensions 
in the array.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-25121></A><EM class=Code>int</EM> *<EM 
class=Code> dimensions</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-25122></A>A pointer to an array of 
<EM class=Code>nd</EM> integers, describing the number of elements along each 
dimension. The sizes are in the conventional order, so that for any array <EM 
class=Code>a</EM> , <BR><EM class=Code>a.shape==(dimensions[0], dimensions[1], 
..., dimensions[nd])</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-25123></A><EM class=Code>int</EM> *<EM 
class=Code> strides</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-25124></A>A pointer to an array of 
<EM class=Code>nd</EM> integers, describing the address offset between two 
successive data elements along each dimension. Note that strides can also be 
negative! Each number gives the number of bytes to add to a pointer to get to 
the next element in that dimension. For example, if <EM class=Code>myptr</EM> 
currently points to an element in a rank-5 array at indices <EM 
class=Code>1,0,5,3,2</EM> and you want it to point to element <EM 
class=Code>1,0,5,4,2</EM> then you should add <EM class=Code>strides[3]</EM> to 
the pointer: <EM class=Code>myptr += strides[3]</EM> . This works even if (and 
is especially useful when) the array is not contiguous in memory.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-32771></A><EM class=Code>PyObject</EM> 
*<EM class=Code> base</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-32784></A>Used internally in 
arrays that are created as slices of other arrays. Since the new array shares 
its data area with the old one, the original array's reference count is 
incremented. When the subarray is garbage collected, the base array's reference 
count is decremented.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-32775></A><EM 
class=Code>PyArray_Desc</EM> *<EM class=Code> descr</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-32830></A>See below.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-32831></A><EM class=Code>int flags</EM> 
</H6>
<P class=BulletLev2Continuation><A name=pgfId-32832></A>A bitfield indicating 
whether the array:</P>
<UL>
  <LI class=BulletLev3><A name=pgfId-32835></A>is contiguous (rightmost bit) 
  <LI class=BulletLev3><A name=pgfId-32839></A>owns the dimensions (next bit to 
  the left) (???) 
  <LI class=BulletLev3><A name=pgfId-32840></A>owns the strides (next bit to the 
  left) (???) 
  <LI class=BulletLev3><A name=pgfId-32841></A>owns the data area </LI></UL>
<P class=BulletLev2Continuation><A name=pgfId-32842></A>The ownership bits are 
used by NumPy internally to manage memory allocation and deallocation. They can 
be false if the array is the result of e.g. a slicing operation on an existing 
array.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-55326></A>PyArrayDescr *descr</H6>
<P class=BulletLev2Continuation><A name=pgfId-55329></A>a pointer to a data 
structure that describes the array and has some handy functions. The slots in 
this structure are:</P>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-32848></A>PyArray_VectorUnaryFunc 
*cast[]</H6>
<P class=BulletLevel3Continuation><A name=pgfId-32885></A>an array of function 
pointers which will cast this arraytype to each of the other data 
types.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-32852></A>PyArray_GetItemFunc *getitem 
</H6>
<P class=BulletLevel3Continuation><A name=pgfId-32853></A>a pointer to a 
function which returns a PyObject of the appropriate type given a (char) pointer 
to the data to get.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-32856></A>PyArray_SetItemFunc 
*setitem</H6>
<P class=BulletLevel3Continuation><A name=pgfId-32857></A>a pointer to a 
function which sets the element pointed to by the second argument to converted 
Python Ojbect given as the first argument. </P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-32860></A>int type_num</H6>
<P class=BulletLevel3Continuation><A name=pgfId-32900></A>A number indicating 
the datatype of the array (i.e. a <EM class=Code>PyArray_XXXX</EM> )</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-32863></A>char *one</H6>
<P class=BulletLevel3Continuation><A name=pgfId-32905></A>A pointer to a 
representation of one for this datatype.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-32866></A>char *zero </H6>
<P class=BulletLevel3Continuation><A name=pgfId-32910></A>A pointer to a 
representation of zero for this datatype (especially useful for PyArray_OBJECT 
types)</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-32870></A>char type</H6>
<P class=BulletLevel3Continuation><A name=pgfId-32917></A>A character 
representing the array's typecode (one of <EM class=Code>'cb1silfdFDO'</EM> ). 
</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-34282></A>The ArrayObject API</H6>
<P class=FirstBody><A name=pgfId-34283></A>In the following <EM 
class=Code>op</EM> is a pointer to a <EM class=Code>PyObject</EM> and <EM 
class=Code>arp</EM> is a pointer to a <EM class=Code>PyArrayObject</EM> . 
Routines which return <EM class=Code>PyObject</EM> * return <EM 
class=Code>NULL</EM> to indicate failure (and follow the standard 
exception-setting mechanism). Functions followed by a dagger (|) are functions 
which return PyObjects whose reference count has been increased by one (new 
references). See the Python Extending/Embedding manual for details on 
reference-count management.</P></DIV></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34284></A>int <A 
name=marker-59743></A>PyArray_Check(op) </H6>
<P class=BulletLev2Continuation><A name=pgfId-34285></A>returns <EM 
class=Code>1</EM> if <EM class=Code>op</EM> is a <EM 
class=Code>PyArrayObject</EM> or <EM class=Code>0</EM> if it is not.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34286></A>int <A 
name=marker-59744></A>PyArray_SetNumericOps(d) </H6>
<P class=BulletLev2Continuation><A name=pgfId-34287></A>internally used by <EM 
class=Code>umath</EM> to setup some of its functions.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34288></A>int <A 
name=marker-59745></A>PyArray_INCREF(op)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34289></A>Used for arrays of 
python objects (<EM class=Code> PyArray_OBJECT</EM> ) to increment the reference 
count of every python object in the array <EM class=Code>op</EM> . User code 
does not typically need to call this.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34290></A>int <A 
name=marker-59746></A>PyArray_XDECREF(op)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34291></A>Used for arrays of 
python objects (<EM class=Code> PyArray_OBJECT</EM> ) to decrement the reference 
count of every python object in the array <EM class=Code>op</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34292></A><A 
name=marker-59747></A>PyArrayError</H6>
<P class=BulletLev2Continuation><A name=pgfId-34293></A>Exports the array error 
object. I don't know its use.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34294></A>void <A 
name=marker-59748></A>PyArray_SetStringFunction(op,repr)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34295></A>Sets the function for 
representation of all arrays to <EM class=Code>op </EM>which should be a 
callable <EM class=Code>PyObject</EM> . If <EM class=Code>repr</EM> is non-zero 
then the function corresponding to the <EM class=Code>repr</EM> string 
representationis set, otherwise, that for the <EM class=Code>str</EM> string 
representation is set.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34296></A>PyArray_Descr <A 
name=marker-59749></A>PyArray_DescrFromType(type)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34297></A>returns a <EM 
class=Code>PyArray_Descr</EM> structure for the datatype given by <EM 
class=Code>type</EM> . The input type can be either the enumerated types (<EM 
class=Code> PyArray_Float</EM> , etc.) or a character (<EM class=Code> 
'cb1silfdFDO'</EM> ).</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-55586></A>PyObject *<A 
name=marker-59750></A>PyArray_Cast(arp, type) |</H6>
<P class=BulletLev2Continuation><A name=pgfId-34298></A>returns a pointer to a 
<EM class=Code>PyArrayObject</EM> that is <EM class=Code>arp</EM> cast to the 
array type specified by <EM class=Code>type</EM> . It is just a wrapper around 
the function defined in <EM class=Code>arp-&gt;descr-&gt;cast</EM> that handles 
non-contiguous arrays and arrays of Python objects appropriately.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34299></A>int <A 
name=marker-59751></A>PyArray_CanCastSafely(fromtype,totype)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34300></A>returns <EM 
class=Code>1</EM> if the array with type <EM class=Code>fromtype</EM> can be 
cast to an array of type <EM class=Code>totype</EM> without loss of accuracy, 
otherwise it returns <EM class=Code>0</EM> . It allows conversion of <EM 
class=Code>long</EM> s to <EM class=Code>int</EM> s which is not safe on 64-bit 
machines. The inputs <EM class=Code>fromtype</EM> and <EM class=Code>totype</EM> 
are the enumerated array types (e.g. <EM class=Code>PyArray_SBYTE</EM> 
).</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34301></A>int <A 
name=marker-59752></A>PyArray_ObjectType(op, min_type)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34302></A>returns the typecode to 
use for a call to an array creation function given an input python sequence 
object <EM class=Code>op</EM> and a minimum type value, <EM 
class=Code>min_type</EM> . It looks at the datatypes used in <EM 
class=Code>op</EM> , compares this with <EM class=Code>min_type</EM> and returns 
a consistent type value that can be used to store all of the data in <EM 
class=Code>op</EM> and satisfying at the minimum the precision of <EM 
class=Code>min_type</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34303></A>int <A 
name=marker-59753></A>_PyArray_multiply_list(list,n) </H6>
<P class=BulletLev2Continuation><A name=pgfId-34304></A>is a utility routine to 
multiply an array of <EM class=Code>n</EM> integers pointed to by <EM 
class=Code>list</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34305></A>int <A 
name=marker-59754></A>PyArray_Size(op) </H6>
<P class=BulletLev2Continuation><A name=pgfId-34306></A>is a useful function for 
returning the total number of elements in <EM class=Code>op</EM> if <EM 
class=Code>op</EM> is a <EM class=Code>PyArrayObject</EM> , <EM 
class=Code>0</EM> otherwise.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34307></A>PyObject *<A 
name=marker-59755></A>PyArray_FromDims(nd,dims,type) |</H6>
<P class=BulletLev2Continuation><A name=pgfId-34308></A>returns a pointer to a 
newly constructed <EM class=Code>PyArrayObject</EM> (returned as a <EM 
class=Code>PyObject</EM> ) given the number of dimensions in <EM 
class=Code>nd</EM> , an array <EM class=Code>dims</EM> of <EM class=Code>nd</EM> 
integers specifying the size of the array, and the enumerated type of the array 
in <EM class=Code>type</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34309></A>PyObject *<A 
name=marker-59756></A>PyArray_FromDimsAndData(nd,dims,type,data) |</H6>
<P class=BulletLev2Continuation><A name=pgfId-34310></A>This function should 
only be used to access global data that will never be freed (like FORTRAN common 
blocks). It builds a <EM class=Code>PyArrayObject</EM> in the same way as <EM 
class=Code>PyArray_FromDims</EM> but instead of allocating new memory for the 
array elements it uses the bytes pointed to by <EM class=Code>data</EM> (a <EM 
class=Code>char *</EM> ).</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34311></A>PyObject *<A 
name=marker-59757></A>PyArray_ContiguousFromObject(op,type,min_dim,max_dim) 
|</H6>
<P class=BulletLev2Continuation><A name=pgfId-34312></A>returns a contiguous 
array of type <EM class=Code>type</EM> from the (possibly nested) sequence 
object <EM class=Code>op</EM> . If <EM class=Code>op</EM> is a contiguous <EM 
class=Code>PyArrayObject</EM> then a reference is made; if <EM 
class=Code>op</EM> is a non-contiguous then a copy is performed to get a 
contiguous array; if <EM class=Code>op</EM> is not a <EM 
class=Code>PyArrayObject</EM> then a new <EM class=Code>PyArrayObject</EM> is 
created from the sequence object and returned. The two parameters <EM 
class=Code>min_dim</EM> and <EM class=Code>max_dim</EM> let you specify the 
expected rank of the input sequence. An error will result if the resulting <EM 
class=Code>PyArrayObject</EM> does not have rank bounded by these limits. To 
specify an exact rank requirement set <EM class=Code>min_dim = max_dim</EM> . To 
allow for an arbitrary number of dimensions specify <EM class=Code>min_dim = 
max_dim = 0</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34315></A>PyObject *<A 
name=marker-59758></A>PyArray_CopyFromObject(op,type,min_dim,max_dim) |</H6>
<P class=BulletLev2Continuation><A name=pgfId-34316></A>returns a contiguous 
array similar to <EM class=Code>PyArray_ContiguousFromObject</EM> except that a 
copy of <EM class=Code>op</EM> is performed even if a shared array could have 
been used.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34317></A>PyObject *<A 
name=marker-59759></A>PyArray_FromObject(op,type,min_dim,max_dim) |</H6>
<P class=BulletLev2Continuation><A name=pgfId-55829></A>returns a reference to 
<EM class=Code>op</EM> if <EM class=Code>op</EM> is a <EM 
class=Code>PyArrayObject</EM> and a newly constructed <EM 
class=Code>PyArrayObject</EM> if <EM class=Code>op</EM> is any other (nested) 
sequence object. You must use strides to access the elements of this possibly 
discontiguous array correctly.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-55830></A>PyObject *<A 
name=marker-59760></A>PyArray_Return(apr) </H6>
<P class=BulletLev2Continuation><A name=pgfId-34320></A>returns a pointer to <EM 
class=Code>apr</EM> with some extra code to check for errors and be sure that 
zero-dimensional arrays are returned as scalars. If a scalar is returned instead 
of <EM class=Code>apr</EM> then <EM class=Code>apr</EM> 's reference count is 
decremented, so it is safe to use this function in the form :<BR><EM 
class=Code>return PyArray_Return (apr);</EM> </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34321></A>PyObject *<A 
name=marker-59761></A>PyArray_Reshape(apr,op) |</H6>
<P class=BulletLev2Continuation><A name=pgfId-34322></A>returns a reference to 
<EM class=Code>apr</EM> with a new shape specified by <EM class=Code>op</EM> 
which must be a one dimensional sequence object. One dimension may be specified 
as unknown by giving a value less than zero, its value will be calculated from 
the size of <EM class=Code>apr</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34323></A>PyObject *<A 
name=marker-59762></A>PyArray_Copy(apr) |</H6>
<P class=BulletLev2Continuation><A name=pgfId-34324></A>returns an 
element-for-element copy of <EM class=Code>apr</EM> </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34325></A>PyObject *<A 
name=marker-59763></A>PyArray_Take(a,indices,axis) |</H6>
<P class=BulletLev2Continuation><A name=pgfId-34326></A>the equivalent of <EM 
class=Code>take(a, indices, axis)</EM> which is a method defined in the Numeric 
module that just calls this function. </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-55910></A>int <A 
name=marker-59764></A>PyArray_As1D(*op, char **ptr, int *n, int type)</H6>
<P class=BulletLev2Continuation><A name=pgfId-55911></A>This function replaces 
<EM class=Code>op</EM> with a pointer to a contiguous 1-D <EM 
class=Code>PyArrayObject</EM> (using <EM 
class=Code>PyArray_ContiguousFromObject</EM> ) and sets as output parameters a 
pointer to the first byte of the array in <EM class=Code>ptr</EM> and the number 
of elements in the array in <EM class=Code>n</EM> . It returns <EM 
class=Code>-1</EM> on failure (<EM class=Code> op</EM> is not a 1-D array or 
sequence object that can be cast to type <EM class=Code>type</EM> ) and <EM 
class=Code>0</EM> on success. </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34329></A>int <A 
name=marker-59765></A>PyArray_As2D(*op, char **ptr, int *m, int *n, int type) 
</H6>
<P class=BulletLev2Continuation><A name=pgfId-34330></A>This function replaces 
<EM class=Code>op</EM> with a pointer to a contiguous 2-D <EM 
class=Code>PyArrayObject</EM> (using <EM 
class=Code>PyArray_ContiguousFromObject</EM> ). It returns -1 on failure (op is 
not a 2-D array or nested sequence object that can be cast to type type) and 0 
on success. It also sets as output parameters: an array of pointers in <EM 
class=Code>ptr</EM> which can be used to access the data as a 2-D array so that 
ptr[i][j] is a pointer to the first byte of element [i,j] in the array; <EM 
class=Code>m</EM> and <EM class=Code>n</EM> are set to respectively the number 
of rows and columns of the array. </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34331></A>int <A 
name=marker-59766></A>PyArray_Free(op,ptr) </H6>
<P class=BulletLev2Continuation><A name=pgfId-34280></A>is supposed to free the 
allocated data structures and decrease object references when using <EM 
class=Code>PyArray_As1D</EM> and <EM class=Code>PyArray_As2D</EM> but there are 
suspicions that this code is buggy.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-586></A>Notes</H6>
<P class=Body><A name=pgfId-17649></A>Number formats, overflow issues, NaN/Inf 
representations, fpectl module, how to deal with 'missing' 
values.</P></DIV></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-587></A><A name=marker-59767></A>UfuncObject 
C Structure and API</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-589></A>C Structure</H6>
<P class=FirstBody><A name=pgfId-33025></A>The ufuncobject is a generic function 
object that can be used to perform fast operations over Numeric Arrays with very 
useful broadcasting rules and type conversions performed automatically. The 
ufuncobject and its API make it easy and graceful to add arbitrary functions to 
Python which operate over Numeric arrays. All of the unary and binary operators 
currently available in the Numerical extensions (like sin, cos, +, logical_or, 
etc.) are implemented using this object. The hooks are all in place to make it 
very easy to add any function that takes one or two (double) arguments and 
returns a single (double) argument. It is not difficult to add support routines 
in order to handle arbitrary functions whose total number of input/output 
arguments is less than some maximum number (currently 10).</P>
<P class=C-Code><A name=pgfId-33047></A>typedef struct { </P>
<P class=C-Code><A name=pgfId-33049></A>PyObject_HEAD </P>
<P class=C-Code><A name=pgfId-33051></A>int *ranks, *canonical_ranks; </P>
<P class=C-Code><A name=pgfId-33109></A>int nin, nout, nargs; </P>
<P class=C-Code><A name=pgfId-33110></A>int identity; </P>
<P class=C-Code><A name=pgfId-33111></A>PyUFuncGenericFunction *functions; </P>
<P class=C-Code><A name=pgfId-33059></A>void **data; </P>
<P class=C-Code><A name=pgfId-33061></A>int ntypes, nranks, attributes; </P>
<P class=C-Code><A name=pgfId-33063></A>char *name, *types; </P>
<P class=C-Code><A name=pgfId-33065></A>int check_return; </P>
<P class=C-Code><A name=pgfId-33022></A>} PyUFuncObject;</P>
<P class=Body><A name=pgfId-33134></A>where:</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33140></A>int *ranks</H6>
<P class=BulletLev2Continuation><A name=pgfId-35227></A>unused.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-35249></A>int *canonical_ranks</H6>
<P class=BulletLev2Continuation><A name=pgfId-35250></A>unused</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-35251></A>int nin</H6>
<P class=BulletLev2Continuation><A name=pgfId-33145></A>the number of input 
arguments to function</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33147></A>int nout</H6>
<P class=BulletLev2Continuation><A name=pgfId-33148></A>the number of output 
arguments for the function</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33150></A>int nargs</H6>
<P class=BulletLev2Continuation><A name=pgfId-33151></A>the total number of 
arguments <EM class=Code>= nin + nout</EM> </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33153></A>int identity</H6>
<P class=BulletLev2Continuation><A name=pgfId-35255></A>a flag telling whether 
the identity for this function is <EM class=Code>0</EM> or <EM class=Code>1</EM> 
for use in the <EM class=Code>reduce</EM> method for a zero size array 
input.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33155></A>PyUFuncGenericFunction 
*functions</H6>
<P class=BulletLev2Continuation><A name=pgfId-35267></A>an array of functions 
that perform the innermost looping over the input and output arrays (I think 
this is over a single axis). These functions call the underlying math function 
with the data from the input arguments along this axis and return the outputs of 
the function into the correct place in the output arrayobject (with appropriate 
typecasting). These functions are called by the general looping code. There is 
one function for each of the supported datatypes. Function pointers to do this 
looping for types <EM class=Code>'f'</EM> , <EM class=Code>'d'</EM> , <EM 
class=Code>'F'</EM> , and <EM class=Code>'D'</EM> , are provided in the C-API 
for functions that take one or two arguments and return one argument. Each <EM 
class=Code>PyUFuncGenericFunction</EM> returns <EM class=Code>void</EM> and has 
the following argument list (in order):</P>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-33157></A>args</H6>
<P class=BulletLevel3Continuation><A name=pgfId-35318></A>an array of pointers 
to the data for each of the input and output arguments with input arguments 
first and output arguments immediately following. Each element of <EM 
class=Code>args</EM> is a <EM class=Code>char</EM> * to the first byte in the 
corresponding input or output array.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-35344></A>dimensions</H6>
<P class=BulletLevel3Continuation><A name=pgfId-35348></A>a pointer to a single 
<EM class=Code>int</EM> giving the size of the axis being looped over.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-35351></A>steps</H6>
<P class=BulletLevel3Continuation><A name=pgfId-35371></A>an array of <EM 
class=Code>int</EM> s giving the number of bytes to skip to go to the next 
element of the array for this loop. There is an entry in the array for each of 
the input and output arguments, with input arguments first and output arguments 
immediately following.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-35352></A>func</H6>
<P class=BulletLevel3Continuation><A name=pgfId-35387></A>a pointer to the 
underlying math function to be called at each point in this inner loop. This is 
a <EM class=Code>void</EM> * and must be recast to the required type before 
actually calling the function e.g. to a pointer to a function that takes two <EM 
class=Code>double</EM> s and returns a <EM class=Code>double</EM> ). If you need 
to write your own <EM class=Code>PyUFuncGenericFunction</EM> , it is most 
readable to also have a <EM class=Code>typedef</EM> statement that defines your 
specific underlying function type so the function pointer cast is somewhat 
readable.</P></DIV></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33159></A>void **data</H6>
<P class=BulletLev2Continuation><A name=pgfId-35429></A>a pointer to an array of 
functions (each cast to <EM class=Code>void</EM> *) that compute the actual 
mathematical function for each set of inputs and outputs. There should be a 
function in the array for each supported data type. This function will be called 
from the <EM class=Code>PyUFuncGenericFunction</EM> for the corresponding 
type.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-35336></A>int ntypes</H6>
<P class=BulletLev2Continuation><A name=pgfId-35460></A>the number of datatypes 
supported by this function. For datatypes that are not directly supported, a 
coercion will be performed if possible safely, otherwise an error will be 
reported.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33161></A>int nranks</H6>
<P class=BulletLev2Continuation><A name=pgfId-33162></A>unused.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33163></A>int attributes</H6>
<P class=BulletLev2Continuation><A name=pgfId-35470></A>unused.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33165></A>char *name</H6>
<P class=BulletLev2Continuation><A name=pgfId-35481></A>the name of this 
function (not the same as the dictionary label for this function object, but it 
is usually set to the same string). It is printed when <EM 
class=Code>__repr__</EM> is called for this object, defaults to <EM 
class=Code>"?"</EM> if set to <EM class=Code>NULL</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33167></A>char *types</H6>
<P class=BulletLev2Continuation><A name=pgfId-35503></A>an array of supported 
types for this function object. I'm not sure why but each supported datatype 
(<EM class=Code> PyArray_FLOAT</EM> , etc.) is entered as many times as there 
are arguments for this function. (<EM class=Code> nargs</EM> )</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-33169></A>int check_return</H6>
<P class=BulletLev2Continuation><A name=pgfId-35528></A>Usually best to set to 
1. If this is non-zero then returned matrices will be cleaned up so that rank-0 
arrays will be returned as python scalars. Also, if non-zero, then any math 
error that sets the <EM class=Code>errno</EM> global variable will cause an 
appropriate Python exception to be raised.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-590></A>UfuncObject C API</H6>
<P class=FirstBody><A name=pgfId-34384></A>There are currently 15 pointers in 
the C-API array for the ufuncobject which is loaded by <EM 
class=Code>import_ufunc()</EM> . The macros implemented by this API, available 
by including the file <EM class=Code>ufuncobject.h</EM> ,' are given below. The 
only function normally called by user code is the ufuncobject creation function 
<EM class=Code>PyUFunc_FromFuncAndData</EM> . Some of the other functions can be 
used as elements of an array to be passed to this creation 
function.</P></DIV></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34392></A>int <A 
name=marker-59768></A>PyUFunc_Check(op)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34554></A>returns <EM 
class=Code>1</EM> if op is a ufunc object otherwise returns <EM 
class=Code>0</EM> .</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34555></A>PyObject *<A 
name=marker-59769></A>PyUFunc_FromFuncAndData(functions, data, types, ntypes, 
nin, nout, identity, name, check_return)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34561></A>returns the ufunc object 
given its parameters. This is the most important function call. It requires 
defining three arrays to be passed as parameters: <EM class=Code>functions</EM> 
, <EM class=Code>data</EM> , and <EM class=Code>types</EM> . The arguments to be 
passed are:</P>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34402></A>functions</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34570></A>an array of functions 
of type <EM class=Code>PyUFuncGenericFunction</EM> , there should be one 
function for each supported datatype. The functions should be in order so that 
datatypes listed toward the beginning of the array could be cast as datatypes 
listed toward the end.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34406></A>data</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34577></A>an array of pointers 
to void* the same size as the functions array and in the same datatype order. 
Each element of this array is the actual underlying math function (recast to a 
<EM class=Code>void</EM> *) that will be called from one of the <EM 
class=Code>PyUFuncGenericFunctions</EM> . It will operate on each element of the 
input NumPy <EM class=Code>arrayobject</EM> (s) and return its 
element-by-element result in the output NumPy arrayobject(s). There is one 
function call for each datatype supported, (though functions can be repeated if 
you handle the typecasting appropriately with the <EM 
class=Code>PyUFuncGenericFunction</EM> ).</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34415></A>types</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34594></A>an array of<EM 
class=Code> PyArray_Type</EM> s. The size of this array should be (<EM 
class=Code> nin+nout</EM> ) times the size of one of the previous two arrays. 
There should be <EM class=Code>nin+nout</EM> copies of <EM 
class=Code>PyArray_XXXXX</EM> for each datatype explicitly supported. (Remember 
datatypes not explicitly supported will still be accepted as input arguments to 
the ufunc if they can be cast safely to a supported type.) </P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34422></A>ntypes</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34607></A>the number of 
supported types for this ufunc.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34424></A>nin</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34610></A>the number of input 
arguments</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34426></A>nout</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34427></A>the number of output 
arguments</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34429></A>identity</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34615></A><EM 
class=Code>PyUFunc_One</EM> , <EM class=Code>PyUFunc_Zero</EM> , or <EM 
class=Code>PyUFunc_None</EM> , depending on the desired value for the identity. 
This is only relevant for functions that take two input arguments and return one 
output argument. If not relevant use <EM class=Code>PyUFunc_None</EM> 
.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34434></A>name</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34435></A>the name of this <EM 
class=Code>ufuncobject</EM> for use in the <EM class=Code>__repr__</EM> 
method.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34437></A>check_return</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34626></A>the desired value for 
check_return for this ufuncobject.</P></DIV></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34631></A>int <A 
name=marker-59770></A>PyUFunc_GenericFunction(self,args,mps)</H6>
<P class=BulletLev2Continuation><A name=pgfId-34668></A>allows calling the ufunc 
from user C routine. It returns 0 on success and -1 on any failures. This is the 
core of what happens when a ufunc is called from Python. Its arguments are:</P>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34446></A>self</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34675></A>the ufunc object to be 
called. INPUT</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34447></A>args</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34676></A>a Python tuple object 
containing the input arguments to the ufunc (should be Python sequence objects). 
INPUT</P></DIV>
<DIV>
<H6 class=CodeBulletLevel3><A name=pgfId-34449></A>mps</H6>
<P class=BulletLevel3Continuation><A name=pgfId-34679></A>an array of pointers 
to PyArrayObjects for the input and output arguments to this function. The input 
NumPy arrays are elements <EM class=Code>mps[0]...mps[self-&gt;nin-1]</EM> . The 
output NumPy arrays are elements <EM 
class=Code>mps[self-&gt;nin]...mps[self-&gt;nargs-1]</EM> . OUTPUT</P>
<P class=FirstBody><A name=pgfId-34455></A>The following are all functions of 
type <EM class=Code>PyUFuncGenericFunction</EM> and are suitable for use in the 
<EM class=Code>functions</EM> argument passed to <EM 
class=Code>PyUFunc_FromFuncAndData</EM> :</P></DIV></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34458></A>PyUFunc_f_f_As_d_d</H6>
<P class=BulletLev2Continuation><A name=pgfId-34792></A>for a unary function 
that takes a <EM class=Code>double</EM> input and returns a <EM 
class=Code>double</EM> output as a ufunc that takes <EM 
class=Code>PyArray_FLOAT</EM> input and returns <EM 
class=Code>PyArray_FLOAT</EM> output. </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-56074></A>PyUFunc_d_d</H6>
<P class=BulletLev2Continuation><A name=pgfId-56075></A>for a using a unary 
function that takes a <EM class=Code>double</EM> input and returns a <EM 
class=Code>double</EM> output as a ufunc that takes <EM 
class=Code>PyArray_DOUBLE</EM> input and returns <EM 
class=Code>PyArray_DOUBLE</EM> output.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34466></A>PyUFunc_F_F_As_D_D</H6>
<P class=BulletLev2Continuation><A name=pgfId-34790></A>for a unary function 
that takes a <EM class=Code>Py_complex</EM> input and returns a <EM 
class=Code>Py_complex</EM> output as a ufunc that takes <EM 
class=Code>PyArray_CFLOAT</EM> input and returns <EM 
class=Code>PyArray_CFLOAT</EM> output.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34470></A>PyUFunc_D_D</H6>
<P class=BulletLev2Continuation><A name=pgfId-34789></A>for a unary function 
that takes a <EM class=Code>Py_complex</EM> input and returns a <EM 
class=Code>Py_complex</EM> output as a ufunc that takes <EM 
class=Code>PyArray_CFLOAT</EM> input and returns <EM 
class=Code>PyArray_CFLOAT</EM> output.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34474></A>PyUFunc_O_O</H6>
<P class=BulletLev2Continuation><A name=pgfId-34786></A>for a unary function 
that takes a <EM class=Code>Py_Object</EM> * input and returns a <EM 
class=Code>Py_Object</EM> * output as a ufunc that takes <EM 
class=Code>PyArray_OBJECT</EM> input and returns <EM 
class=Code>PyArray_OBJECT</EM> output</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34731></A>PyUFunc_ff_f_As_dd_d</H6>
<P class=BulletLev2Continuation><A name=pgfId-34785></A>for a binary function 
that takes two <EM class=Code>double</EM> inputs and returns one <EM 
class=Code>double</EM> output as a ufunc that takes <EM 
class=Code>PyArray_FLOAT</EM> input and returns <EM 
class=Code>PyArray_FLOAT</EM> output.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34482></A>PyUFunc_dd_d</H6>
<P class=BulletLev2Continuation><A name=pgfId-34784></A>for a binary function 
that takes two <EM class=Code>double</EM> inputs and returns one <EM 
class=Code>double</EM> output as a ufunc that takes <EM 
class=Code>PyArray_DOUBLE</EM> input and returns <EM 
class=Code>PyArray_DOUBLE</EM> output.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34486></A>PyUFunc_FF_F_As_DD_D</H6>
<P class=BulletLev2Continuation><A name=pgfId-34783></A>for a binary function 
that takes two <EM class=Code>Py_complex</EM> inputs and returns a <EM 
class=Code>Py_complex</EM> output as a ufunc that takes <EM 
class=Code>PyArray_CFLOAT</EM> input and returns <EM 
class=Code>PyArray_CFLOAT</EM> output.</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34490></A>PyUFunc_DD_D</H6>
<P class=BulletLev2Continuation><A name=pgfId-34782></A>for a binary function 
that takes two <EM class=Code>Py_complex</EM> inputs and returns a <EM 
class=Code>Py_complex</EM> output as a ufunc that takes <EM 
class=Code>PyArray_CFLOAT</EM> input and returns <EM 
class=Code>PyArray_CFLOAT</EM> output </P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-56204></A><EM 
class=Code>PyUFunc_OO_O</EM> </H6>
<P class=BulletLev2Continuation><A name=pgfId-56200></A>for a unary function 
that takes two <EM class=Code>Py_Object</EM> * input and returns a <EM 
class=Code>Py_Object</EM> *<EM class=Code> </EM>output as a ufunc that takes <EM 
class=Code>PyArray_OBJECT</EM> input and returns <EM 
class=Code>PyArray_OBJECT</EM> output</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34498></A>PyUFunc_O_O_method</H6>
<P class=BulletLev2Continuation><A name=pgfId-34775></A>for a unary function 
that takes a <EM class=Code>Py_Object</EM> * input and returns a <EM 
class=Code>Py_Object *</EM> output and is pointed to by a Python method as a 
ufunc that takes PyArray_OBJECT input and returns PyArray_OBJECT 
output</P></DIV>
<DIV>
<H6 class=CodeBulletLevel2><A name=pgfId-34503></A>PyArrayMap</H6>
<P class=BulletLev2Continuation><A name=pgfId-34774></A>an exported API that was 
apparently considered but never implemented probably because the functionality 
is already available with Python's <EM class=Code>map</EM> function. 
</P></DIV></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-57323></A>14. <A name=92539></A>Glossary</H2>
<P class=Body><A name=pgfId-57324></A>This section will define a few of the 
technical words used throughout this document. [Please let us know of any 
additions to this list which you feel would be helpful -- the authors]</P>
<P class=Definition><A name=pgfId-57325></A><A name=marker-59791></A>typecode: a 
single character describing the format of the data stored in an array. For 
example, 'b' refers to unsigned byte-sized integers (0-255).</P>
<P class=Definition><A name=pgfId-57326></A><A name=marker-59792></A>ufunc / <A 
name=marker-59793></A>universal function: a ufunc is a callable object which 
performs operations on all of the elements of its arguments, which can be lists, 
tuples, or arrays. Many ufuncs are defined in the <EM class=Code>umath</EM> 
module.</P>
<P class=Definition><A name=pgfId-57327></A><A name=marker-59794></A>array / <A 
name=marker-59795></A>multiarray: an array refers to the Python object type 
defined by the NumPy extensions to store and manipulate numbers efficiently.</P>
<P class=Definition><A name=pgfId-57328></A><A name=marker-59796></A>UserArray: 
The UserArray module defines a UserArray class which should be subclassed by 
users wishing to have classes which behave similarly to the array object 
type.</P>
<P class=Definition><A name=pgfId-57329></A><A name=marker-59797></A>Matrix: The 
Matrix module defines a subclass Matrix of the UserArray class which is 
specialized for linear algebra matrices. Most notably, it overrides the 
multiplication operator on Matrix instances to perform matrix multiplication 
instead of element-wise multiplication.</P>
<P class=Definition><A name=pgfId-57330></A><A name=marker-59798></A>rank: the 
rank of an array is the number of dimensions it has, or the number of integers 
in its shape tuple.</P>
<P class=Definition><A name=pgfId-57331></A><A name=marker-59799></A>shape: 
array objects have an attribute called shape which is necessarily a tuple. An 
array with an empty tuple shape is treated like a scalar (it holds one 
element).</P>
<P class=Body><A name=pgfId-57345></A>&nbsp;</P></DIV>
<DIV>
<H2 class=ChapterSet><A name=pgfId-304408></A>
<DIV><IMG src="numdoc_files/numdoc-8.gif"> </DIV>Part II: <A 
name=90799></A>Optional Packages
<DIV><IMG src="numdoc_files/numdoc-9.gif"> </DIV></H2>
<P class=ChapterDescription><A name=pgfId-304409></A>This part contains 
descriptions of the packages that are included with the distribution but which 
are not necessary for using Numeric arrays. The packages are for the most part 
in the Packages subdirectory of the source distribution, and can be installed 
anywhere in the Python module search path. Each has its own "setup.py" to use to 
build and install the package.<BR><BR>For historical reasons, some of these 
packages are currently installed inside the Numeric package rather than on their 
own. We hope to remedy this in the future.</P>
<P class=FirstBody><A name=pgfId-305577></A>The subdirectory Packages contains 
directories, each of which contains its own installation script setup.py. As 
with the main directory, these packages are generally compiled and installed 
using the command </P>
<P class=Body><A name=pgfId-305578></A>python setup.py install</P>
<P class=Body><A name=pgfId-305579></A>The Makefile in the main directory will 
do this for all the packages provided. </P>
<P class=Body><A name=pgfId-305580></A>In addition, many people make available 
libraries that use Numeric. At the moment a centralized reference for these does 
not exist, but they are usually announced on the discussion list; also check the 
project web page.<A name=13771></A></P>
<TABLE border=1>
  <CAPTION>
  <H6 class=TableTitle><A name=pgfId-305588></A>Descriptions of the Optional 
  Packages</H6></CAPTION>
  <TBODY>
  <TR>
    <TH>
      <P class=CellHeading><A name=pgfId-305594></A>Package Name</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-305596></A>Description</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-305598></A>Reference</P></TH></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-305600></A>FFT</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305602></A>Fast Fourier Transforms</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305607></A><A class=XRef 
      href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#FFT">FFT 
      Reference</A></P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-305609></A>LinearAlgebra</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305611></A>Basic linear algebra</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305615></A><A class=XRef 
      href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#32826">LinearAlgebra 
      Reference</A></P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-305618></A>RandomArray</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305620></A>Arrays of random 
numbers.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305624></A><A class=XRef 
      href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#40886">RandomArray 
      Reference</A></P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-305627></A>RNG</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305629></A>Generators for independent 
      streams of random numbers from various distributions and arrays of 
      same.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305633></A><A class=XRef 
      href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#71863">Independent 
      Random Streams</A></P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-305636></A>MA</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305638></A>Masked arrays, that is, arrays 
      that have missing or invalid entries.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305643></A><A class=XRef 
      href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#48250">Masked 
      Arrays</A></P></TD></TR></TBODY></TABLE>
<DIV>
<H6 class=FM1Heading><A name=pgfId-304744></A><A name=66303></A>License and 
disclaimer for packages MA and RNG</H6>
<P class=FirstBody><A name=pgfId-304767></A>Package MA was written by Paul 
Dubois, LLNL. Package RNG was written by Konrad Hinsen after modifying an 
earlier package UNRG by Paul Dubois and Fred Fritsch.</P>
<P class=Body><A name=pgfId-304757></A>Copyright (c) 1999, 2000. The Regents of 
the University of California. All rights reserved. </P>
<P class=Body><A name=pgfId-304724></A>Permission to use, copy, modify, and 
distribute this software for any purpose without fee is hereby granted, provided 
that this entire notice is included in all copies of any software which is or 
includes a copy or modification of this software and in all copies of the 
supporting documentation for such software.</P>
<P class=Body><A name=pgfId-304725></A>This work was produced at the University 
of California, Lawrence Livermore National Laboratory under contract no. 
W-7405-ENG-48 between the U.S. Department of Energy and The Regents of the 
University of California for the operation of UC LLNL. </P>
<P class=Body><A name=pgfId-304726></A>DISCLAIMER</P>
<P class=Body><A name=pgfId-304727></A>This software was prepared as an account 
of work sponsored by an agency of the United States Government. Neither the 
United States Government nor the University of California nor any of their 
employees, makes any warranty, express or implied, or assumes any liability or 
responsibility for the accuracy, completeness, or usefulness of any information, 
apparatus, product, or process disclosed, or represents that its use would not 
infringe privately-owned rights. Reference herein to any specific commercial 
products, process, or service by trade name, trademark, manufacturer, or 
otherwise, does not necessarily constitute or imply its endorsement, 
recommendation, or favoring by the United States Government or the University of 
California. The views and opinions of authors expressed herein do not 
necessarily state or reflect those of the United States Government or the 
University of California, and shall not be used for advertising or product 
endorsement purposes.</P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-304711></A>15. <A name=FFT></A>FFT 
Reference</H2>
<P class=ChapterDescription><A name=pgfId-302951></A>The <A 
name=marker-302950></A>FFT.py module provides a simple interface to the FFTPACK 
FORTRAN library, which is a powerful standard library for doing fast Fourier 
transforms of real and complex data sets, or the C fftpack library, which is 
algorithmically based on FFTPACK and provides a compatible interface. On some 
platforms, optimized version of one of these libraries may be available, and can 
be used to provide optimal performance (see <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#41147">Compilation 
Notes</A>).</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-302955></A>Python Interface</H6>
<P class=FirstBody><A name=pgfId-302956></A>The Python user imports the FFT 
module, which provides a set of utility functions which provide access to the 
most commonly used FFT routines, and allows the specification of which axes 
(dimensions) of the input arrays are to be used for the FFT's. These routines 
are:</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-302958></A><A 
name=marker-302957></A>fft(data, n=None, axis=-1) </H6>
<P class=FirstBody><A name=pgfId-302959></A>Performs a n-point discrete Fourier 
transform of the array data. <EM class=Code>n</EM> defaults to the size of data. 
It is most efficient for n a power of two. If n is larger than <EM 
class=Code>data</EM> , then <EM class=Code>data</EM> will be zero-padded to make 
up the difference. If n is smaller than data, then <EM class=Code>data</EM> will 
be aliased to reduce its size. This also stores a cache of working memory for 
different sizes of fft's, so you could theoretically run into memory problems if 
you call this too many times with too many different n's.</P>
<P class=Body><A name=pgfId-302960></A>The FFT is performed along the axis 
indicated by the <EM class=Code>axis</EM> argument, which defaults to be the 
last dimension of <EM class=Code>data</EM> .</P>
<P class=Body><A name=pgfId-302961></A>The format of the returned array is a 
complex array of the same shape as <EM class=Code>data</EM> , where the first 
element in the result array contains the DC (steady-state) value of the FFT, and 
where each successive ...XXX</P>
<P class=Body><A name=pgfId-302962></A>Example of use:</P>
<P class=Python><A name=pgfId-302963></A>&gt;&gt;&gt; <EM class=CodeInput>print 
fft(array((1,0,1,0,1,0,1,0))+ 10).real</EM> </P>
<P class=Python><A name=pgfId-302964></A>[ 84. 0. 0. 0. 4. 0. 0. 0.]</P>
<P class=Python><A name=pgfId-302965></A>&gt;&gt;&gt; <EM class=CodeInput>print 
fft(array((0,1,0,1,0,1,0,1))+ 10).real</EM> </P>
<P class=Python><A name=pgfId-302966></A>[ 84. 0. 0. 0. -4. 0. 0. 0.]</P>
<P class=Python><A name=pgfId-302967></A>&gt;&gt;&gt; <EM class=CodeInput>print 
fft(array((0,1,0,0,0,1,0,0))+ 10).real</EM> </P>
<P class=Python><A name=pgfId-302968></A>[ 82. 0. 0. 0. -2. 0. 0. 0.]</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-302970></A><A 
name=marker-302969></A>inverse_fft(data, n=None, axis=-1) </H6>
<P class=FirstBody><A name=pgfId-302971></A>Will return the <EM 
class=Code>n</EM> point inverse discrete Fourier transform of <EM 
class=Code>data</EM> . <EM class=Code>n</EM> defaults to the length of <EM 
class=Code>data</EM> . This is most efficient for <EM class=Code>n</EM> a power 
of two. If <EM class=Code>n</EM> is larger than <EM class=Code>data</EM> , then 
<EM class=Code>data</EM> will be zero-padded to make up the difference. If <EM 
class=Code>n</EM> is smaller than <EM class=Code>data</EM> , then <EM 
class=Code>data</EM> will be aliased to reduce its size. This also stores a 
cache of working memory for different sizes of FFT's, so you could theoretically 
run into memory problems if you call this too many times with too many different 
<EM class=Code>n</EM> 's. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-302973></A><A 
name=marker-302972></A>real_fft(data, n=None, axis=-1) </H6>
<P class=FirstBody><A name=pgfId-302974></A>Will return the <EM 
class=Code>n</EM> point discrete Fourier transform of the real valued array <EM 
class=Code>data</EM> . <EM class=Code>n</EM> defaults to the length of <EM 
class=Code>data</EM> . This is most efficient for <EM class=Code>n</EM> a power 
of two. The returned array will be one half of the symmetric complex transform 
of the real array. </P>
<P class=Python><A name=pgfId-302975></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
cos(arange(30.0)/30.0*2*pi)</EM> </P>
<P class=Python><A name=pgfId-302976></A>&gt;&gt;&gt; <EM class=CodeInput>print 
real_fft(x)</EM> </P>
<P class=Python><A name=pgfId-302977></A>[ -1. +0.j 13.69406641+2.91076367j</P>
<P class=Python><A name=pgfId-302978></A>-0.91354546-0.40673664j 
-0.80901699-0.58778525j</P>
<P class=Python><A name=pgfId-302979></A>-0.66913061-0.74314483j -0.5 
-0.8660254j</P>
<P class=Python><A name=pgfId-302980></A>-0.30901699-0.95105652j 
-0.10452846-0.9945219j</P>
<P class=Python><A name=pgfId-302981></A>0.10452846-0.9945219j 
0.30901699-0.95105652j</P>
<P class=Python><A name=pgfId-302982></A>0.5 -0.8660254j 
0.66913061-0.74314483j</P>
<P class=Python><A name=pgfId-302983></A>0.80901699-0.58778525j 
0.91354546-0.40673664j</P>
<P class=Python><A name=pgfId-302984></A>0.9781476 -0.20791169j 1. +0.j 
]</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-302986></A><A 
name=marker-302985></A>inverse_real_fft(data, n=None, axis=-1) </H6>
<P class=FirstBody><A name=pgfId-302987></A>Will return the inverse FFT of the 
real valued array <EM class=Code>data</EM> .</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-302988></A>fft2d(data, s=None, axes=(-2,-1)) 
</H6>
<P class=FirstBody><A name=pgfId-302989></A>Will return the 2-dimensional FFT of 
the array <EM class=Code>data</EM> .</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-302990></A>real_fft2d(data, s=None, 
axes=(-2,-1)) </H6>
<P class=FirstBody><A name=pgfId-302991></A>Will return the 2d FFT of the real 
valued array <EM class=Code>data</EM> . </P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-302992></A>C API</H6>
<P class=FirstBody><A name=pgfId-302993></A>The interface to the FFTPACK library 
is performed via the fftpackmodule module, which is responsible for making sure 
that the arrays sent to the FFTPACK routines are in the right format (contiguous 
memory locations, right numerical storage format, etc). It provides interfaces 
to the following FFTPACK routines, which are also the names of the Python 
functions:</P>
<UL>
  <LI class=BulletLev2><A name=pgfId-302994></A><EM class=Code>cffti(i)</EM> 
  <LI class=BulletLev2><A name=pgfId-302995></A><EM class=Code>cfftf(data, 
  savearea)</EM> 
  <LI class=BulletLev2><A name=pgfId-302996></A><EM class=Code>cfftb(data, 
  savearea)</EM> 
  <LI class=BulletLev2><A name=pgfId-302997></A><EM class=Code>rffti(i)</EM> 
  <LI class=BulletLev2><A name=pgfId-302998></A><EM class=Code>rfftf(data, 
  savearea)</EM> 
  <LI class=BulletLev2><A name=pgfId-302999></A><EM class=Code>rfftb(data, 
  savearea)</EM> </LI></UL>
<P class=Body><A name=pgfId-303000></A>The routines which start with <EM 
class=Code>c</EM> expect arrays of complex numbers, the routines which start 
with <EM class=Code>r</EM> expect real numbers only. The routines which end with 
<EM class=Code>i</EM> are the initalization functions, those which end with <EM 
class=Code>f</EM> perform the forward FFTs and those which end with <EM 
class=Code>b</EM> perform the backwards FFTs.</P>
<P class=Body><A name=pgfId-303001></A>The initialization functions require a 
single integer argument corresponding to the size of the dataset, and returns a 
work array. The forward and backwards FFTs require two array arguments -- the 
first is the data array, the second is the work array returned by the 
initialization function. They return arrays corresponding to the coefficients of 
the FFT, with the first element in the returned array corresponding to the DC 
component, the second one to the first fundamental, etc.The length of the 
returned array is 1 + half the length of the input array in the case of real 
FFTs, and the same size as the input array in the case of complex data.</P>
<P class=Python><A name=pgfId-303002></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
cos(arange(30.0)/30.0*2*pi)</EM> </P>
<P class=Python><A name=pgfId-303003></A>&gt;&gt;&gt; <EM class=CodeInput>w = 
rffti(30)</EM> </P>
<P class=Python><A name=pgfId-303004></A>&gt;&gt;&gt; <EM class=CodeInput>f = 
rfftf(x, w)</EM> </P>
<P class=Python><A name=pgfId-303005></A>&gt;&gt;&gt; <EM 
class=CodeInput>f[0]</EM> </P>
<P class=Python><A name=pgfId-303006></A>(-1+0j)</P>
<P class=Python><A name=pgfId-303007></A>&gt;&gt;&gt; <EM 
class=CodeInput>f[1]</EM> </P>
<P class=Python><A name=pgfId-303008></A>(13.6940664103+2.91076367145j)</P>
<P class=Python><A name=pgfId-303009></A>&gt;&gt;&gt; <EM 
class=CodeInput>f[2]</EM> </P>
<P class=Python><A 
name=pgfId-303010></A>(-0.913545457643-0.406736643076j)</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-303012></A><A name=41147></A>Compilation 
Notes</H6>
<P class=FirstBody><A name=pgfId-303013></A>On some platforms, precompiled 
optimized versions of the FFTPACK library are preinstalled on the operating 
system, and the compilation procedure needs to be modified to force the 
fftpackmodule file to be linked against those rather than the fftpacklite.c file 
which is shipped with NumPy.</P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-303015></A>16. <A name=32826></A>LinearAlgebra 
Reference</H2>
<P class=ChapterDescription><A name=pgfId-303016></A>The LinearAlgebra.py module 
provides a simple interface to the low-level linear algebra routines provided by 
either the LAPACK FORTRAN library or the compatible lapack_lite C library.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-303017></A>Python Interface</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303019></A><A 
name=marker-303018></A>solve_linear_equations(a, b) </H6>
<P class=FirstBody><A name=pgfId-303020></A>This function solves a system of 
linear equations with a square non-singular matrix a and a right-hand-side 
vector b. Several right-hand-side vectors can be treated simultaneously by 
making b a two-dimensional array (i.e. a sequence of vectors). The function 
inverse(a) calculates the inverse of the square non-singular matrix a by calling 
solve_linear_equations(a, b) with a suitable b. </P>
<P class=FirstBody><A name=pgfId-303021></A>&nbsp;</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303023></A><A 
name=marker-303022></A>inverse(a) </H6>
<P class=FirstBody><A name=pgfId-303024></A>This function returns the inverse of 
the specified matrix a which must be square and non-singular. To within floating 
point precision, it should always be true that:</P>
<P class=Python><A name=pgfId-303025></A>matrixmultiply(a, inverse(a)) == 
identity(len(a))</P>
<P class=Body><A name=pgfId-303026></A>To test this claim, one can do e.g.:</P>
<P class=Python><A name=pgfId-303027></A>&gt;&gt;&gt; <EM class=CodeInput>a = 
reshape(arange(25.0), (5,5)) + identity(5)</EM> </P>
<P class=Python><A name=pgfId-303028></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-303029></A>[[ 1. 1. 2. 3. 4.]</P>
<P class=Python><A name=pgfId-303030></A>[ 5. 7. 7. 8. 9.]</P>
<P class=Python><A name=pgfId-303031></A>[ 10. 11. 13. 13. 14.]</P>
<P class=Python><A name=pgfId-303032></A>[ 15. 16. 17. 19. 19.]</P>
<P class=Python><A name=pgfId-303033></A>[ 20. 21. 22. 23. 25.]]</P>
<P class=Python><A name=pgfId-303034></A>&gt;&gt;&gt; <EM class=CodeInput>inv_a 
= inverse(a)</EM> </P>
<P class=Python><A name=pgfId-303035></A>&gt;&gt;&gt; <EM class=CodeInput>print 
inv_a</EM> </P>
<P class=Python><A name=pgfId-303036></A>[[ 0.20634921 -0.52380952 -0.25396825 
0.01587302 0.28571429]</P>
<P class=Python><A name=pgfId-303037></A>[-0.5026455 0.63492063 -0.22751323 
-0.08994709 0.04761905]</P>
<P class=Python><A name=pgfId-303038></A>[-0.21164021 -0.20634921 0.7989418 
-0.1957672 -0.19047619]</P>
<P class=Python><A name=pgfId-303039></A>[ 0.07936508 -0.04761905 -0.17460317 
0.6984127 -0.42857143]</P>
<P class=Python><A name=pgfId-303040></A>[ 0.37037037 0.11111111 -0.14814815 
-0.40740741 0.33333333]]</P>
<P class=Python><A name=pgfId-303041></A>&gt;&gt;&gt; <EM class=CodeInput># 
Verify the inverse by printing the largest absolute element</EM> </P>
<P class=Python><A name=pgfId-303042></A>... <EM class=CodeInput># of a * a^{-1} 
- identity(5)</EM> </P>
<P class=Python><A name=pgfId-303043></A>... <EM class=CodeInput>print 
"Inversion error:", \</EM> </P>
<P class=Python><A name=pgfId-303044></A>... <EM 
class=CodeInput>maximum.reduce(fabs(ravel(dot(a, inv_a)-identity(5))))</EM> </P>
<P class=Python><A name=pgfId-303045></A>Inversion error: 
2.6645352591e-015</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303047></A><A 
name=marker-303046></A>eigenvalues(a) </H6>
<P class=FirstBody><A name=pgfId-303048></A>This function returns the 
eigenvalues of the square matrix a. </P>
<P class=Python><A name=pgfId-303049></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-303050></A>[[ 1. 0. 0. 0. 0.]</P>
<P class=Python><A name=pgfId-303051></A>[ 0. 2. 0. 0. 1.]</P>
<P class=Python><A name=pgfId-303052></A>[ 0. 0. 3. 0. 0.]</P>
<P class=Python><A name=pgfId-303053></A>[ 0. 0. 0. 4. 0.]</P>
<P class=Python><A name=pgfId-303054></A>[ 0. 0. 0. 0. 1.]]</P>
<P class=Python><A name=pgfId-303055></A>&gt;&gt;&gt; <EM class=CodeInput>print 
eigenvalues(a)</EM> </P>
<P class=Python><A name=pgfId-303056></A>[ 1. 2. 3. 4. 1.]</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303058></A><A 
name=marker-303057></A>eigenvectors(a) </H6>
<P class=FirstBody><A name=pgfId-303059></A>This function returns both the 
eigenvalues and the eigenvectors, the latter as a two-dimensional array (i.e. a 
sequence of vectors).</P>
<P class=Python><A name=pgfId-303060></A>&gt;&gt;&gt; <EM class=CodeInput>print 
a</EM> </P>
<P class=Python><A name=pgfId-303061></A>[[ 1. 0. 0. 0. 0.]</P>
<P class=Python><A name=pgfId-303062></A>[ 0. 2. 0. 0. 1.]</P>
<P class=Python><A name=pgfId-303063></A>[ 0. 0. 3. 0. 0.]</P>
<P class=Python><A name=pgfId-303064></A>[ 0. 0. 0. 4. 0.]</P>
<P class=Python><A name=pgfId-303065></A>[ 0. 0. 0. 0. 1.]]</P>
<P class=Python><A name=pgfId-303066></A>&gt;&gt;&gt; <EM 
class=CodeInput>evalues, evectors = eigenvectors(a)</EM> </P>
<P class=Python><A name=pgfId-303067></A>&gt;&gt;&gt; <EM class=CodeInput>print 
evalues</EM> </P>
<P class=Python><A name=pgfId-303068></A>[ 1. 2. 3. 4. 1.]</P>
<P class=Python><A name=pgfId-303069></A>&gt;&gt;&gt; <EM class=CodeInput>print 
evectors</EM> </P>
<P class=Python><A name=pgfId-303070></A>[[ 1. 0. 0. 0. 0. ]</P>
<P class=Python><A name=pgfId-303071></A>[ 0. 1. 0. 0. 0. ]</P>
<P class=Python><A name=pgfId-303072></A>[ 0. 0. 1. 0. 0. ]</P>
<P class=Python><A name=pgfId-303073></A>[ 0. 0. 0. 1. 0. ]</P>
<P class=Python><A name=pgfId-303074></A>[ 0. -0.70710678 0. 0. 
0.70710678]]</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303076></A><A 
name=marker-303075></A>singular_value_decomposition(a, full_matrices=0) </H6>
<P class=FirstBody><A name=pgfId-303077></A>This function returns three arrays 
V, S, and WT whose matrix product is the original matrix a. V and WT are unitary 
matrices (rank-2 arrays), whereas S is the vector (rank-1 array) of diagonal 
elements of the singular-value matrix. This function is mainly used to check 
whether (and in what way) a matrix is ill-conditioned.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303079></A><A 
name=marker-303078></A>generalized_inverse(a, rcond=1e-10) </H6>
<P class=FirstBody><A name=pgfId-303080></A>This function returns the 
generalized inverse (also known as pseudo-inverse or Moore-Penrose-inverse) of 
the matrix a. It has numerous applications related to linear equations and 
least-squares problems.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303082></A><A 
name=marker-303081></A>determinant(a) </H6>
<P class=FirstBody><A name=pgfId-303083></A>This function returns the 
determinant of the square matrix a.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303085></A><A 
name=marker-303084></A>linear_least_squares(a, b, rcond=e-10) </H6>
<P class=FirstBody><A name=pgfId-303086></A>This function returns the 
least-squares solution of an overdetermined system of linear equations. An 
optional third argument indicates the cutoff for the range of singular values 
(defaults to 10-10). There are four return values: the least-squares solution 
itself, the sum of the squared residuals (i.e. the quantity minimized by the 
solution), the rank of the matrix a, and the singular values of a in descending 
order.</P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-303088></A>Compilation Notes</H6>
<P class=Body><A name=pgfId-303089></A>On some platforms, precompiled optimized 
versions of the LAPACK library are preinstalled on the operating system, and the 
setup procedure needs to be modified to force the lapackmodule.c file to be 
linked against those rather than the lapack_lite library.</P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-303091></A>17. <A name=40886></A>RandomArray 
Reference</H2>
<P class=ChapterDescription><A name=pgfId-303093></A>The <A 
name=marker-303092></A>RandomArray.py module (in conjunction with the 
ranlibmodule.c file) provides a high-level interface to the ranlib module, which 
provides a good quality C implementation of a random-number generator.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-303094></A>Python Interface</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303096></A><A 
name=marker-303095></A>seed(x=0, y=0) </H6>
<P class=FirstBody><A name=pgfId-303097></A>The <EM class=Code>seed()</EM> 
function takes two integers and sets the two seeds of the random number 
generator to those values. If the default values of 0 are used for both x and y, 
then a seed is generated from the current time, providing a pseudo-random 
seed.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303099></A><A 
name=marker-303098></A>get_seed() </H6>
<P class=FirstBody><A name=pgfId-303100></A>The <EM class=Code>get_seed()</EM> 
function returns the two seeds used by the current random-number generator. It 
is most often used to find out what seeds the seed() function chose at the last 
iteration. [thread-safety issue?]</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303102></A><A 
name=marker-303101></A>random(shape=<EM class=Emphasis> ReturnFloat</EM> ) </H6>
<P class=FirstBody><A name=pgfId-303103></A>The <EM class=Code>random()</EM> 
function takes a shape, and returns an array of double-precision floatings point 
numbers between 0.0 and 1.0. Neither 0.0 nor 1.0 is ever returned by this 
function. If no argument is specified, the function returns a single floating 
point number (not an array). The array is filled from the generator following 
the canonical array organization (see discussion of the <EM 
class=Code>.flat</EM> attribute)</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303105></A><A 
name=marker-303104></A>uniform(minimum, maximum, shape=ReturnFloat) </H6>
<P class=FirstBody><A name=pgfId-303106></A>The <EM class=Code>uniform()</EM> 
function returns an array of the specified shape and containing double-precision 
floating point random numbers strictly between minimum and maximum. If no shape 
is specified, a single number is returned.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303108></A><A 
name=marker-303107></A>randint(minimum, maximum, shape=ReturnFloat) </H6>
<P class=FirstBody><A name=pgfId-303109></A>The <EM class=Code>randint()</EM> 
function returns an array of the specified shape and containing random 
(standard) integers greater than or equal to <EM class=Code>minimum</EM> and 
strictly less than <EM class=Code>maximum</EM> . If no shape is specified, a 
single number is returned.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-303111></A><A 
name=marker-303110></A>permutation(n) </H6>
<P class=FirstBody><A name=pgfId-303112></A>The <EM 
class=Code>permutation()</EM> function returns an array of the integers between 
<EM class=Code>0</EM> and <EM class=Code>n-1</EM> , in an array of shape <EM 
class=Code>(n,)</EM> , and with its elements randomly permuted.</P>
<P class=Body><A name=pgfId-303113></A>An example use of the RandomArray module 
(exact output will be different each time!):</P>
<P class=Python><A name=pgfId-303114></A>&gt;&gt;&gt; <EM class=CodeInput>from 
RandomArray import *</EM> </P>
<P class=Python><A name=pgfId-303115></A>&gt;&gt;&gt; <EM class=CodeInput>seed() 
</EM># Set seed based on current time</P>
<P class=Python><A name=pgfId-303116></A>&gt;&gt;&gt; <EM class=CodeInput>print 
get_seed() </EM># Find out what seeds were used</P>
<P class=Python><A name=pgfId-303117></A>(897800491, 192000)</P>
<P class=Python><A name=pgfId-303118></A>&gt;&gt;&gt; <EM class=CodeInput>print 
random()</EM> </P>
<P class=Python><A name=pgfId-303119></A>0.0528018975065</P>
<P class=Python><A name=pgfId-303120></A>&gt;&gt;&gt; <EM class=CodeInput>print 
random((5,2))</EM> </P>
<P class=Python><A name=pgfId-303121></A>[[ 0.14833829 0.99031458]</P>
<P class=Python><A name=pgfId-303122></A>[ 0.7526806 0.09601787]</P>
<P class=Python><A name=pgfId-303123></A>[ 0.1895229 0.97674777]</P>
<P class=Python><A name=pgfId-303124></A>[ 0.46134511 0.25420982]</P>
<P class=Python><A name=pgfId-303125></A>[ 0.66132009 0.24864472]]</P>
<P class=Python><A name=pgfId-303126></A>&gt;&gt;&gt; <EM class=CodeInput>print 
uniform(-1,1,(10,))</EM> </P>
<P class=Python><A name=pgfId-303127></A>[ 0.72168852 -0.75374185 -0.73590945 
0.50488248 -0.74462822 0.09293685</P>
<P class=Python><A name=pgfId-303128></A>-0.65898308 0.9718067 -0.03252475 
0.99611011]</P>
<P class=Python><A name=pgfId-303129></A>&gt;&gt;&gt; <EM class=CodeInput>print 
randint(0,100, (12,))</EM> </P>
<P class=Python><A name=pgfId-303130></A>[28 5 96 19 1 32 69 40 56 69 53 44]</P>
<P class=Python><A name=pgfId-303131></A>&gt;&gt;&gt; <EM class=CodeInput>print 
permutation(10)</EM> </P>
<P class=Python><A name=pgfId-303132></A>[4 2 8 9 1 7 3 6 5 0]</P>
<P class=Python><A name=pgfId-303133></A>&gt;&gt;&gt; <EM 
class=CodeInput>seed(897800491, 192000) </EM># resetting the same seeds</P>
<P class=Python><A name=pgfId-303134></A>&gt;&gt;&gt; <EM class=CodeInput>print 
random() </EM># yields the same numbers</P>
<P class=Python><A name=pgfId-303135></A>0.0528018975065</P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-305397></A>Floating point random arrays</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305398></A>standard_normal 
(shape=ReturnFloat) </H6>
<P class=FirstBody><A name=pgfId-305399></A>The standard_normal () function 
returns an array of the specified shape that contains double precision floating 
point numbers normally (Gaussian) distributed with mean zero and variance and 
standard deviation one. If no shape is specified, a single number is returned. 
</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305400></A>normal (mean, stddev, 
shape=ReturnFloat) </H6>
<P class=Body><A name=pgfId-305401></A>The normal () function returns an array 
of the specified shape that contains double precision floating point numbers 
normally distributed with the specified mean and standard deviation. If no shape 
is specified, a single number is returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305402></A>multivariate_normal (mean, 
covariance) or <BR>multivariate_normal (mean, covariance, leadingAxesShape) 
</H6>
<P class=Body><A name=pgfId-305403></A>The multivariate_normal () function takes 
a one dimensional array argument mean and a two dimensional array argument 
covariance. Suppose the shape of mean is (n,). Then the shape of covariance must 
be (n,n). The multivariate_normal () function returns a double precision 
floating point array. The effect of the leadingAxesShape parameter is: </P>
<UL>
  <LI class=Bullet><A name=pgfId-305404></A>If no leadingAxesShape is specified, 
  then an array with shape (n,) is returned containing a vector of numbers with 
  a multivariate normal distribution with the specified mean and covariance. 
  <LI class=Bullet><A name=pgfId-305405></A>If leadingAxesShape is specified, 
  then an array of such vectors is returned. The shape of the output is 
  leadingAxesShape.append ((n,)). The leading indices into the output array 
  select a multivariate normal from the array. The final index selects one 
  number from within the multivariate normal. </LI></UL>
<P class=Body><A name=pgfId-305406></A>In either case, the behavior of 
multivariate_normal () is undefined if covariance is not symmetric and positive 
definite. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305407></A>exponential (mean, 
shape=ReturnFloat) </H6>
<P class=Body><A name=pgfId-305408></A>The exponential () function returns an 
array of the specified shape that contains double precision floating point 
numbers exponentially distributed with the specified mean. If no shape is 
specified, a single number is returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305409></A>beta (a, b, shape=ReturnFloat) 
</H6>
<P class=Body><A name=pgfId-305410></A>The beta () function returns an array of 
the specified shape that contains double precision floating point numbers beta 
distributed with alpha parameter a and beta parameter b. If no shape is 
specified, a single number is returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305411></A>gamma (a, r, shape=ReturnFloat) 
</H6>
<P class=Body><A name=pgfId-305412></A>The gamma () function returns an array of 
the specified shape that contains double precision floating point numbers beta 
distributed with location parameter a and distribution shape parameter r. If no 
shape is specified, a single number is returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305413></A>chi_square (df, shape=ReturnFloat) 
</H6>
<P class=Body><A name=pgfId-305414></A>The chi_square() function returns an 
array of the specified shape that contains double precision floating point 
numbers with the chi square distribution with df degrees of freedom. If no shape 
is specified, a single number is returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305415></A>noncentral_chi_square (df, nonc, 
shape=ReturnFloat) </H6>
<P class=Body><A name=pgfId-305416></A>The noncentral_chi_square() function 
returns an array of the specified shape that contains double precision floating 
point numbers with the chi square distribution with df degrees of freedom and 
noncentrality parameter nconc. If no shape is specified, a single number is 
returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305417></A>F (dfn, dfd, shape=ReturnFloat) 
</H6>
<P class=Body><A name=pgfId-305418></A>The F () function returns an array of the 
specified shape that contains double precision floating point numbers with the F 
distribution with dfn degrees of freedom in the numerator and dfd degrees of 
freedom in the denominator. If no shape is specified, a single number is 
returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305419></A>noncentral_F (dfn, dfd, nconc, 
shape=ReturnFloat) </H6>
<P class=Body><A name=pgfId-305420></A>The noncentral_F () function returns an 
array of the specified shape that contains double precision floating point 
numbers with the F distribution with dfn degrees of freedom in the numerator, 
dfd degrees of freedom in the denominator, and noncentrality parameter nconc. If 
no shape is specified, a single number is returned. </P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-305421></A>Integer random arrays</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305422></A>binomial (trials, prob, 
shape=ReturnInt) </H6>
<P class=Body><A name=pgfId-305423></A>The binomial () function returns an array 
with the specified shape that contains integer numbers with the binomial 
distribution with trials trials and event probability prob. In other words, each 
value in the returned array is the number of times an event with probability 
prob occurred within trials repeated trials. If no shape is specified, a single 
number is returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305424></A>negative_binomial (trials, prob, 
shape=ReturnInt)</H6>
<P class=Body><A name=pgfId-305425></A>The negative_binomial () function returns 
an array with the specified shape that contains integer numbers with the 
negative binomial distribution with trials trials and event probability prob. If 
no shape is specified, a single number is returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305426></A>poisson (mean, shape=ReturnInt) 
</H6>
<P class=Body><A name=pgfId-305427></A>The poisson () function returns an array 
with the specified shape that contains integer numbers with the Poisson 
distribution with the specified mean. If no shape is specified, a single number 
is returned. </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305428></A>multinomial (trials, probs) or 
multinomial (trials, probs, leadingAxesShape) </H6>
<P class=Body><A name=pgfId-305429></A>The multinomial () function returns an 
array with that contains integer numbers with the multinomial distribution with 
trials trials and event probabilities given in probs. probs must be a one 
dimensional array. There are len(probs)+1 events. probs[i] is the probability of 
the i-th event for 0&lt;=i&lt;len(probs). The probability of event len(probs) is 
1.-Numeric.sum(prob). </P>
<P class=Body><A name=pgfId-305430></A>The first form returns an integer array 
of shape (len(probs)+1,) containing one multinomially distributed vector. The 
second form returns an array of shape (m, n, ..., len(probs)+1) where (m, n, 
...) is leadingAxesShape. In this case, each output[i,j,...,:] is an integer 
array of shape (len(prob)+1,) containing one multinomially distributed vector.. 
</P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-305431></A>Examples</H6>
<P class=Body><A name=pgfId-305432></A>Most of the functions in this package 
take zero or more distribution specific parameters plus an optional shape 
parameter. The shape parameter gives the shape of the output array: </P>
<P class=Python><A name=pgfId-305433></A><EM class=HTML-Typewriter>&gt;&gt;&gt; 
</EM><EM class=CodeInput>from RandomArray import *</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>print 
standard_normal()</EM> <BR><EM class=HTML-Typewriter>-0.435568600893</EM> 
<BR><EM class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>print 
standard_normal(5)</EM> <BR><EM class=HTML-Typewriter>[-1.36134553 0.78617644 
-0.45038718 0.18508556 0.05941355]</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>print 
standard_normal((5,2))</EM> <BR><EM class=HTML-Typewriter>[[ 1.33448863 
-0.10125473]</EM> <BR><EM class=HTML-Typewriter>[ 0.66838062 0.24691346]</EM> 
<BR><EM class=HTML-Typewriter>[-0.95092064 0.94168913]</EM> <BR><EM 
class=HTML-Typewriter>[-0.23919107 1.89288616]</EM> <BR><EM 
class=HTML-Typewriter>[ 0.87651485 0.96400219]]</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>print normal(7., 4., 
(5,2)) #mean=7, std. dev.=4 <BR></EM><EM class=HTML-Typewriter>[[ 2.66997623 
11.65832615]</EM> <BR><EM class=HTML-Typewriter>[ 6.73916003 6.58162862]</EM> 
<BR><EM class=HTML-Typewriter>[ 8.47180378 4.30354905]</EM> <BR><EM 
class=HTML-Typewriter>[ 1.35531998 -2.80886841]</EM> <BR><EM 
class=HTML-Typewriter>[ 7.07408469 11.39024973]]</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>print 
exponential(10., 5) #mean=10 <BR></EM><EM class=HTML-Typewriter>[ 18.03347754 
7.11702306 9.8587961 32.49231603 28.55408891]</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>print beta(3.1, 9.1, 
5) # alpha=3.1, beta=9.1 <BR></EM><EM class=HTML-Typewriter>[ 0.1175056 
0.17504358 0.3517828 0.06965593 0.43898219]</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>print chi_square(7, 
5)</EM> <EM class=HTML-Typewriter></EM><EM class=CodeInput># 7 degrees of 
freedom (dfs) <BR></EM><EM class=HTML-Typewriter>[ 11.99046516 3.00741053 
4.72235727 6.17056274 8.50756836]</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>print 
noncentral_chi_square(7, 3, 5) # 7 dfs, noncentrality 3</EM> <BR><EM 
class=HTML-Typewriter>[ 18.28332138 4.07550335 16.0425396 9.51192093 
9.80156231]</EM> <BR><EM class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM 
class=CodeInput>F(5, 7, 5) # 5 and 7 dfs</EM> <BR><EM 
class=HTML-Typewriter>array([ 0.24693671, 3.76726145, 0.66883826, 0.59169068, 
1.90763224])</EM> <BR><EM class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM 
class=CodeInput>noncentral_F(5, 7, 3., 5) # 5 and 7 dfs, noncentrality 3</EM> 
<BR><EM class=HTML-Typewriter>array([ 1.17992553, 0.7500126 , 0.77389943, 
9.26798989, 1.35719634])</EM> <BR><EM class=HTML-Typewriter>&gt;&gt;&gt; 
</EM><EM class=CodeInput>binomial(32, .5, 5) # 32 trials, prob of an event = .5 
<BR></EM><EM class=HTML-Typewriter>array([12, 20, 21, 19, 17])</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM 
class=CodeInput>negative_binomial(32, .5, 5) # 32 trials: prob of an event = 
.5</EM> <BR><EM class=HTML-Typewriter>array([21, 38, 29, 32, 36])</EM> </P>
<P class=Body><A name=pgfId-305434></A>Two functions that return generate 
multivariate random numbers (that is, random vectors with some known 
relationship between the elements of each vector, defined by the distribution). 
They are multivariate_normal () and multinomial (). For these two functions, the 
lengths of the leading axes of the output may be specified. The length of the 
last axis is determined by the length of some other parameter. </P>
<P class=Python><A name=pgfId-305435></A><EM class=HTML-Typewriter>&gt;&gt;&gt; 
</EM><EM class=CodeInput>multivariate_normal([1,2], [[1,2],[2,1]], [2,3])</EM> 
<BR><EM class=HTML-Typewriter>array([[[ 0.14157988, 1.46232224],</EM> <BR><EM 
class=HTML-Typewriter>[-1.11820295, -0.82796288],</EM> <BR><EM 
class=HTML-Typewriter>[ 1.35251635, -0.2575901 ]],</EM> <BR><EM 
class=HTML-Typewriter>[[-0.61142141, 1.0230465 ],</EM> <BR><EM 
class=HTML-Typewriter>[-1.08280948, -0.55567217],</EM> <BR><EM 
class=HTML-Typewriter>[ 2.49873002, 3.28136372]]])</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>x = 
multivariate_normal([10,100], [[1,2],[2,1]], 10000)</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>x_mean = 
sum(x)/10000</EM> <BR><EM class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM 
class=CodeInput>print x_mean</EM> <BR><EM class=HTML-Typewriter>[ 9.98599893 
100.00032416]</EM> <BR><EM class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM 
class=CodeInput>x_minus_mean = x - x_mean</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>cov = 
matrixmultiply(transpose(x_minus_mean), x_minus_mean) / 9999.</EM> <BR><EM 
class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM class=CodeInput>cov</EM> <BR><EM 
class=HTML-Typewriter>array([[ 2.01737122, 1.00474408],</EM> <BR><EM 
class=HTML-Typewriter>[ 1.00474408, 2.0009806 ]])</EM> </P>
<P class=Body><A name=pgfId-305436></A>The a priori probabilities for a 
multinomial distribution must sum to one. The prior probability argument to 
multinomial () doesn't give the prior probability of the last event: it is 
computed to be one minus the sum of the others. </P>
<P class=Python><A name=pgfId-305437></A><EM class=HTML-Typewriter>&gt;&gt;&gt; 
</EM><EM class=CodeInput>multinomial(16, [.1, .4, .2]) # prior probabilities 
[.1, .4, .2, .3] <BR></EM><EM class=HTML-Typewriter>array([2, 7, 1, 6])</EM> 
<BR><EM class=HTML-Typewriter>&gt;&gt;&gt; </EM><EM 
class=CodeInput>multinomial(16, [.1, .4, .2], [2,3]) # output shape [2,3,4]</EM> 
<BR><EM class=HTML-Typewriter>array([[[ 1, 9, 1, 5],</EM> <BR><EM 
class=HTML-Typewriter>[ 0, 10, 3, 3],</EM> <BR><EM class=HTML-Typewriter>[ 4, 9, 
3, 0]],</EM> <BR><EM class=HTML-Typewriter>[[ 1, 6, 1, 8],</EM> <BR><EM 
class=HTML-Typewriter>[ 3, 4, 5, 4],</EM> <BR><EM class=HTML-Typewriter>[ 1, 5, 
2, 8]]])</EM> </P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-290702></A>18. <A name=46054></A><A 
name=71863></A>Independent Random Streams</H2>
<P class=ChapterDescription><A name=pgfId-304418></A>The RNG package provides 
any number of independent random number generators tied to a distribution. 
Distributions include exponential, normal, and log-normal distributions, but 
adding others is not difficult. Contributions of code for other distributions 
are welcome! </P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-304780></A>Background</H6>
<P class=Body><A name=pgfId-304786></A>RNG was written by Konrad Hinsen based on 
the package URNG by Paul Dubois and Fred Fritsch of LLNL. This package has been 
released for unlimited redistribution. Please see <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#66303">License and 
disclaimer for packages MA and RNG</A>.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-304419></A>Usage</H6>
<P class=Body><A name=pgfId-304420></A>Package RNG installs two modules: 
RNG.RNG, and RNG.ranf. The former is a C extension that does the generation. The 
latter is an easy-to-use interface for a single uniform distribution.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-304559></A>Module RNG</H6>
<P class=Body><A name=pgfId-304558></A>Module RNG defines the function:</P>
<P class=Body><A name=pgfId-304421></A>CreateGenerator(s, 
distribution=UniformDistribution(0., 1.)) </P>
<P class=Body><A name=pgfId-304422></A>creates a new random number generator 
with a distribution. The random numbers produced by the generator sample the 
distribution and are independent of other generators created earlier or later. 
Its first argument, an integer, determines the initial state: </P>
<UL>
  <LI class=Bullet><A name=pgfId-304423></A>0 ; Use the default initial seed 
  value. 
  <LI class=Bullet><A name=pgfId-304462></A>&lt;0: ; Set a random value for the 
  seed from the system clock. 
  <LI class=Bullet><A name=pgfId-304463></A>&gt;0 ; Set seed directly (32 bits 
  only). </LI></UL>
<P class=Body><A name=pgfId-304424></A>The default distribution is a uniform 
distribution on [0., 1.); other distributions are obtained by supplying a second 
argument which must be a distribution. Currently RNG defines the following 
distribution types: </P>
<UL>
  <LI class=Bullet><A name=pgfId-304425></A>UniformDistribution(a, b) -- a 
  uniform distribution of numbers in the interval [a, b) 
  <LI class=Bullet><A name=pgfId-304482></A>NormalDistribution(mu, sigma) -- a 
  normal distribution with mean mu and standard deviation sigma 
  <LI class=Bullet><A name=pgfId-304483></A>ExponentialDistribution(l) -- an 
  exponential distribution of positive numbers with decay constant l. 
  <LI class=Bullet><A name=pgfId-304484></A>LogNormalDistribution(mean, std) -- 
  a log normal distribution with given mean and standard deviation. </LI></UL>
<DIV>
<H6 class=FM3Heading><A name=pgfId-304635></A>Generator objects</H6>
<P class=FirstBody><A name=pgfId-304639></A>Once a generator is created, it 
contains these methods:</P>
<UL>
  <LI class=Bullet><A name=pgfId-304644></A>sample(n) will return an array of n 
  samples from the generator. 
  <LI class=Bullet><A name=pgfId-304654></A>ranf() will return one sample from 
  the generator. </LI></UL></DIV></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-304493></A>Module ranf</H6>
<P class=FirstBody><A name=pgfId-304568></A>Module ranf, whose main function 
ranf() is equivalent to the old ranf generator on Cray 1 computers, defines 
these facilities.</P>
<P class=FirstBody><A name=pgfId-304497></A>Attribute standard_generator is an 
instance of RNG.UniformDistribution(0., 1.).</P>
<P class=Body><A name=pgfId-304534></A>ranf(): returns a random number from the 
standard_generator.</P>
<P class=Body><A name=pgfId-304545></A>random_sample(*n) returns a Numeric array 
of samples from the standard_generator.</P>
<P class=Python><A name=pgfId-304508></A>random_sample(n) = array of n random 
numbers;</P>
<P class=Python><A name=pgfId-304509></A>random_sample(n1, n2, ...)= array of 
shape (n1, n2, ..)</P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-304426></A>Examples</H6>
<P class=Body><A name=pgfId-304427></A>The test routine Demo/RNGdemo.py 
illustrates some common usage of both RNG and Numeric.</P>
<P class=Body><A name=pgfId-304428></A>The test routine RNGtest2.py combines RNG 
with Konrad Hinsen's Statistics package to do a test of the log normal 
distribution.</P>
<P class=Body><A name=pgfId-304616></A>Here is one function from RNGdemo.py, 
showing a test of a normal distribution.</P>
<P class=Python><A name=pgfId-304574></A>from Numeric import *</P>
<P class=Python><A name=pgfId-304579></A>import RNG</P>
<P class=Python><A name=pgfId-304580></A>&nbsp;</P>
<P class=Python><A name=pgfId-304581></A>def test_normal (mean, std, 
n=10000):</P>
<P class=Python><A name=pgfId-304582></A>dist = RNG.NormalDistribution(mean, 
std)</P>
<P class=Python><A name=pgfId-304583></A>rng = RNG.CreateGenerator(0, dist)</P>
<P class=Python><A name=pgfId-304584></A>values = rng.sample(n)</P>
<P class=Python><A name=pgfId-304585></A>m = sum(values)/n</P>
<P class=Python><A name=pgfId-304586></A>s = sqrt(sum((values-m)**2)/n)</P>
<P class=Python><A name=pgfId-304587></A>return (m, s)</P>
<P class=Body><A name=pgfId-304172></A>&nbsp;</P></DIV></DIV>
<DIV>
<H2 class=Chapter><A name=pgfId-303698></A>19. <A name=48250></A>Masked Arrays<A 
name=marker-308206></A></H2>
<P class=ChapterDescription><A name=pgfId-303702></A><A 
name=marker-308207></A>Masked arrays are arrays that may have missing or invalid 
entries. Module MA provides a work-alike replacement for Numeric that supports 
data arrays with masks.</P>
<DIV>
<H6 class=FM1Heading><A name=pgfId-296294></A>What is a <A 
name="masked array"></A>masked array?</H6>
<P class=BodyAfterHead><A name=pgfId-305401></A>Masked arrays are arrays that 
may have missing or invalid entries. Module MA provides a work-alike replacement 
for Numeric that supports data arrays with masks. A mask is either None or an 
array of ones and zeros, that determines for each element of the masked array 
whether or not it contains an invalid entry. The package assures that invalid 
entries are not used in calculations. </P>
<P class=Body><A name=pgfId-296293></A>A particular element is said to be masked 
(<A name=marker-305508></A>invalid) if the mask is not None and the 
corresponding element of the mask is 1; otherwise it is unmasked (valid). </P>
<P class=Body><A name=pgfId-304710></A>This package was written by <A 
name=marker-305509></A>Paul F. Dubois at Lawrence Livermore National Laboratory. 
Please see the legal notice in the software and on <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#66303">License and 
disclaimer for packages MA and RNG</A>.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-304772></A><A 
name=marker-305507></A>Installing and using MA</H6>
<P class=BodyAfterHead><A name=pgfId-296302></A>MA is one of the optional 
Packages and installing it requires a separate step as explained in the Numeric 
README. To install just the MA package using Distutils, in the MA top directory 
enter:</P>
<P class=C-Code><A name=pgfId-305192></A>python setup.py install</P>
<P class=FirstBody><A name=pgfId-304662></A>Use MA as a replacement for 
Numeric:</P>
<P class=Python><A name=pgfId-304660></A>from MA import *</P>
<P class=Python><A name=pgfId-305467></A>x = array([1, 2, 3])</P>
<P class=Body><A name=pgfId-304661></A>To create an array with the second 
element invalid, we would do:</P>
<P class=Python><A name=pgfId-305471></A>y = array([1, 2, 3], mask = [0, 1, 
0])</P>
<P class=Body><A name=pgfId-305491></A>To create a masked array where all values 
"near" 1.e20 are invalid, we can do:</P>
<P class=Python><A name=pgfId-305495></A>z = <A 
name=marker-305506></A>masked_values ([1.0, 1.e20, 3.0, 4.0], 1.e20)</P>
<P class=Body><A name=pgfId-305502></A>For a complete discussion of creation 
methods for masked arrays please see <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#73354">Constructing 
masked arrays</A>.</P>
<P class=Body><A name=pgfId-305470></A>The Numeric module is an attribute in MA, 
so to execute a method foo from Numeric, you can reference it as 
Numeric.foo(...).</P>
<P class=Body><A name=pgfId-304673></A>Usually people use both MA and Numeric 
this way, but of course you can always fully-qualify the names:</P>
<P class=Python><A name=pgfId-304674></A>import MA</P>
<P class=Python><A name=pgfId-304685></A>x = MA.array([1, 2, 3])</P>
<P class=Body><A name=pgfId-305234></A>The principal feature of module MA is 
class MA, the class whose instances are returned by the array constructors and 
most functions in module MA. We will discuss this class first, and later cover 
the attributes and functions in module MA. For now suffice it to say that among 
the attributes of the module are the constants from module Numeric including 
those for declaring typecodes, NewAxis, and the mathematical constants such as 
pi and e. An additional typecode, MaskType, is the typecode used for 
masks.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-296950></A>Class MA</H6>
<P class=Body><A name=pgfId-304137></A>In Module MA, an array is an instance of 
class MA, which is defined in the module MA. An instance of class MA can be 
thought of as containing the following parts:</P>
<UL>
  <LI class=Bullet><A name=pgfId-304138></A>An array of data, of any shape; 
  <LI class=Bullet><A name=pgfId-304139></A>A mask of ones and zeros of the same 
  shape as the data; and, 
  <LI class=Bullet><A name=pgfId-304140></A>A "fill value" -- this is a value 
  that may be used to replace the invalid entries in order to return a plain 
  Numeric array. The chief method that does this is the method filled discussed 
  below. </LI></UL>
<P class=Body><A name=pgfId-304141></A>We will use the terms "invalid value" and 
"invalid entry" to refer to the data value at a place corresponding to a mask 
value of 1. It should be emphasized that the invalid values are <EM 
class=Emphasis>never</EM> used in any computation, and that the fill value is 
not used for <EM class=Emphasis>any</EM> computational purpose. When an instance 
x of class MA is converted to its string representation, it is the result 
returned by filled (x) that is converted to a string.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305213></A>Attributes of masked arrays</H6>
<P class=FirstBody><A name=pgfId-305939></A>flat: (deprecated) returns the 
masked array as one-dimensional. This is provided for compatibility with 
Numeric. ravel (x) is preferred.</P>
<P class=Body><A name=pgfId-305943></A>real: returns the real part of the array 
if complex.</P>
<P class=Body><A name=pgfId-305944></A>imaginary: returns the imaginary part of 
the array if complex.</P>
<P class=FirstBody><A name=pgfId-305250></A>shape: The shape of a masked array 
can be accessed or changed by using the special attribute shape, as with 
Numerical arrays.</P>
<P class=Body><A name=pgfId-305520></A>shared_data: This read-only flag if true 
indicates that the masked array shared a reference with the original data used 
to construct it at the time of construction. Changes to the original array will 
affect the masked array. (This is not the default behavior; see <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#72295">Copying or 
not?</A>.) This flag is informational only.</P>
<P class=Body><A name=pgfId-305536></A><A name=MA></A>shared_mask: This 
read-only flag if true indicates that the masked array currently shares a 
reference to the mask used to create it. Unlike shared_data, this flag may 
change as the result of modifying the array contents, as the mask uses copy on 
write semantics if it is shared.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305217></A>Methods on masked arrays. </H6>
<TABLE border=1>
  <CAPTION>
  <H6 class=TableTitle><A name=pgfId-298191></A>Methods on masked arrays; 
  attributes, constructors and operations discussed separately.<A 
  name=36299></A></H6></CAPTION>
  <TBODY>
  <TR>
    <TH>
      <P class=CellHeading><A name=pgfId-298197></A>Method</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-298199></A>Description</P></TH>
    <TH>
      <P class=CellHeading><A name=pgfId-298201></A>Sample syntax</P></TH></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298203></A>astype (typecode)</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298205></A>return self as array of given 
      type.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298207></A>y = x.astype 
(Float32)</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-306731></A>compressed ()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306733></A>return an array of the valid 
      elements. Result is one-dimensional.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306735></A>y = x.compressed()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-306685></A>filled (fill_value=None)</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306687></A>filled(self, 
      self.fill_value()); see description of module method filled.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306689></A>y = x.filled()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298209></A>fill_value ()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298211></A>Get the current fill 
    value.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298213></A>v = x.fill_value ()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-306721></A>filled (value = None)</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306723></A>Same as filled(self, value); 
      see <A class=XRef 
      href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#35793">The 
      filled function</A>.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306725></A>numar = x.filled ()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298221></A>get_shape () </P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298223></A>Return the tuple giving the 
      current shape. Same as shape attribute.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298225></A>s = x.get_shape ()</P>
      <P class=CellBody><A name=pgfId-298301></A>s = x.shape </P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298227></A>ids ()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298229></A>Return the ids of the data and 
      mask areas</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298231></A>id1, id2 = x.ids ()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298233></A>is_contiguous ()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298235></A>Is the data area contiguous? 
      See Numeric manual.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298237></A>if x.is_contiguous ()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298239></A>mask ()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298241></A>Return the data mask, or 
      None.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298243></A>m = x.mask ()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-306691></A>put (values)</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306693></A>Set the value at each 
      non-masked entry to the corresponding entry in values. The mask is 
      unchanged. See also module method put.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306695></A>x.put (values)</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-306700></A>putmask (values)</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306702></A>Eliminate any masked values by 
      setting the value at each masked entry to the corresponding entry in 
      values. Set the mask to None.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-306704></A>x.putmask(values)</P>
      <P class=CellBody><A name=pgfId-306719></A>assert getmask(x) is 
  None</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298245></A>raw_data ()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298247></A>A reference to the non-filled 
      data; portions may be meaningless. Expert use only.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298249></A>d = x.raw_data ()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-305255></A>savespace (v)</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305257></A>Set the spacesaver attribute to 
      v.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305259></A>x.savespace (1)</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298251></A>set_fill_value ()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298253></A>Set the fill value to v. Omit v 
      to restore default.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298255></A>x.set_fill_value 
  (1.e21)</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298263></A>set_shape (args...)</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298265></A>shape (n, m, ...) sets the 
      shape.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298267></A>x.set_shape (3, 12)</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298269></A>size (axis)</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298271></A>Number of elements in array, or 
      in a particular axis.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298273></A>totalsize = x.size ()</P>
      <P class=CellBody><A name=pgfId-298303></A>col_len = x.size (1)</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-305261></A>spacesaver()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305263></A>Query the spacesave 
flag.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305265></A>flag = x.spacesaver()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-305551></A>unshare_mask()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305553></A>If shared_mask is currently 
      true, replaces the reference to it with a copy.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305555></A>x.unshare_mask()</P></TD></TR>
  <TR>
    <TD>
      <P class=CellBody><A name=pgfId-298275></A>typecode ()</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-298277></A>Return the type of the data. 
      See module Precision.</P></TD>
    <TD>
      <P class=CellBody><A name=pgfId-305953></A>z = 
  x.typecode()</P></TD></TR></TBODY></TABLE></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-298181></A><A name=73354></A>Constructing 
masked arrays</H6>
<OL>
  <LI class=Numbered1><A name=pgfId-305574></A><A name=marker-305800></A>array 
  (data, typecode = None, copy = 1, savespace = 0, mask = None, fill_value = 
  None) creates a masked array with the given data and mask. The name array is 
  simply an alias for the class name, MA. This constructor sets the data area of 
  the resulting masked array to filled (data, value = fill_value, copy = copy, 
  savespace = savespace), the mask to make_mask (mask, savespace), and the fill 
  value is set to fill_value. The class name MA may also be used instead of the 
  name array. 
  <LI class=Numbered><A name=pgfId-305587></A><A 
  name=marker-305801></A>masked_array (data, mask = None, fill_value = None) is 
  an easier to use version of array, for the common case of typecode = None, 
  copy = 0. When data is newly-created this function can be used to make it a 
  masked array without copying the data if data is already a Numeric array. 
  <LI class=Numbered><A name=pgfId-303765></A><A 
  name=marker-304072></A>masked_values (data, value, rtol=1.e-5, atol=1.e-8, 
  typecode = None, copy = 1, savespace = 0) constructs a masked array whose mask 
  is set at those places where <BR>abs (data - value) &lt; atol + rtol * abs 
  (data). <BR>That is a careful way of saying that those elements of the data 
  that have value = value (to within a tolerance) are to be treated as invalid. 
  <LI class=Numbered><A name=pgfId-305796></A><A 
  name=marker-305802></A>masked_object (data, value, copy=1, savespace=0) 
  creates a masked array with those entries marked invalid that are equal to 
  value. Again, copy and savespace are passed on to the Numeric array 
  constructor. 
  <LI class=Numbered><A name=pgfId-307728></A><A 
  name=marker-307732></A>masked_where (condition, data) creates a masked array 
  whose shape is that of condition, whose values are those of data, and which is 
  masked where elements of condition are true. 
  <LI class=Numbered><A name=pgfId-307764></A><A 
  name=marker-307789></A>masked_greater (data, value) is equivalent to 
  masked_where (greater(data, value), data)). Similarly, <A 
  name=marker-307793></A>masked_greater_equal, <A 
  name=marker-307797></A>masked_equal, <A 
  name=marker-307801></A>masked_not_equal, <A 
  name=marker-307805></A>masked_less, <A 
  name=marker-307809></A>masked_less_equal are called in the same way with the 
  obvious meanings. Note that for floating point data, <A 
  name=marker-307810></A>masked_values is preferable in most cases. </LI></OL>
<P class=Body><A name=pgfId-305283></A>On entry to any of these constructors, 
data must be any object which the Numeric package can accept to create an array 
(with the desired typecode, if specified). The mask if given must be None or any 
object that can be turned into a Numeric array of integer type (it will be 
converted to typecode MaskType, if necessary), have the same shape as data, and 
contain only values of 0 or 1.</P>
<P class=Body><A name=pgfId-306531></A>If the mask is not None but its shape 
does not match that of data, an exception will be thrown, unless one of the two 
is of length 1, in which case the scalar will be resized (using Numeric.resize) 
to match the other.</P>
<P class=Body><A name=pgfId-306530></A>See <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#72295">Figure , 
Copying or not?</A> for a discussion of whether or not the resulting array 
shares its data or its mask with the arguments given to these 
constructors.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-304244></A><A name=35793></A>The <A 
name=marker-305344></A>filled function</H6>
<DIV>
<H6 class=NoteTip><A name=pgfId-305619></A>
<DIV><IMG src="numdoc_files/numdoc-10.gif"> </DIV>&nbsp;</H6>
<P class=Note><A name=pgfId-305623></A>Be sure to read this: filled is very 
important. It converts its argument to a plain Numeric array.</P>
<DIV>
<H6 class=NoteBottom><A name=pgfId-305627></A>
<DIV><IMG src="numdoc_files/numdoc-11.gif"> </DIV>&nbsp;</H6>
<P class=FirstBody><A name=pgfId-304255></A>filled (x, value = None, copy=0) 
returns x with any invalid locations replaced by a fill value. filled is 
guaranteed to return a plain Numeric array. The argument x does not have to be a 
masked array or even an array, just something that Numeric can turn into 
one.</P>
<UL>
  <LI class=Bullet><A name=pgfId-305156></A>If x is not a masked array, and not 
  a Numeric array, Numeric.array (x) is returned. 
  <LI class=Bullet><A name=pgfId-305647></A>If x is a Numeric array, and copy is 
  zero, then x is returned. If copy is nonzero, a copy of the array is returned. 

  <LI class=Bullet><A name=pgfId-305648></A>If x is a masked array, but the mask 
  is None, then its data array or a copy of it is returned depending on the 
  value of copy. 
  <LI class=Bullet><A name=pgfId-305649></A>If x is a masked array with an 
  actual mask, then an array formed by replacing the invalid entries with value, 
  or fill_value (x) if value is None, is returned. If the fill value used is of 
  a different type or precision than x, the result may be of a different type or 
  precision than x. </LI></UL>
<P class=FirstBody><A name=pgfId-305154></A>The function filled plays a central 
role in our design. It is the "exit" back to Numeric, and is used whenever the 
invalid values must be replaced before an operation. For example, adding two 
masked arrays a and b is roughly:</P>
<P class=Python><A name=pgfId-304389></A>masked_array(filled(a, 0)+filled(b, 0), 
mask_or(getmask(a), getmask(b))</P>
<P class=Body><A name=pgfId-304394></A>That is, fill the invalid entries a and b 
with zeros, add them up, and declare any entry of the result invalid if either a 
or b was invalid at that spot. The functions getmask and mask_or are discussed 
later.</P>
<P class=Body><A name=pgfId-305057></A>filled (x) also can be used to simply be 
certain that some expression is a Numerical array at little cost. If its 
argument is a Numeric array already, it is returned without copying.</P>
<P class=Body><A name=pgfId-305142></A><A name=marker-305346></A>fill_value (x), 
and the method x.fill_value() of the same name on masked arrays, returns a value 
suitable for filling x based on its type. If x is a masked array, then 
x.fill_value () results. The returned value for a given type can be changed by 
assigning to these names in module MA: They should be set to scalars or one 
element arrays. </P>
<P class=Python><A name=pgfId-305143></A><A 
name=marker-305365></A>default_real_fill_value = Numeric.array([1.0e20], 
Float32)</P>
<P class=Python><A name=pgfId-305144></A><A 
name=marker-305348></A>default_complex_fill_value = Numeric.array([1.0e20 + 
0.0j], Complex32)</P>
<P class=Python><A name=pgfId-305145></A><A 
name=marker-305349></A>default_character_fill_value = masked</P>
<P class=Python><A name=pgfId-306195></A><A 
name=marker-305350></A>default_integer_fill_value = 
Numeric.array([0]).astype(UnsignedInt8)</P>
<P class=Python><A name=pgfId-305148></A><A 
name=marker-305352></A>default_object_fill_value = masked</P>
<P class=Body><A name=pgfId-305671></A>The variable <A 
name=marker-306591></A>masked is a module variable of MA and is discussed in <A 
class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#16219">Working with 
Masks</A>. Calling filled with a fill_value of masked sometimes produces a 
useful printed representation of a masked array. The function fill_value works 
on any kind of object.</P></DIV></DIV></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-304372></A><A name=16219></A>Working with 
Masks<A name=marker-305353></A></H6>
<P class=FirstBody><A name=pgfId-306564></A>Each of the following is defined in 
module MA:</P>
<P class=FirstBody><A name=pgfId-304996></A><A name=marker-305354></A>is_mask 
(m) is true if m is of a type and precision that would be allowed as the mask 
field of a masked array (that is, it is an array of integers with Numeric's 
typecode MaskType, or it is None). To be a legal mask, m should contain only 
zeros or ones, but this is not checked.</P>
<P class=Body><A name=pgfId-305010></A><A name=marker-305355></A>make_mask (m, 
copy=0, flag=0) returns an object whose entries are equal to m and for which 
is_mask would return true. If m is already a mask or None, it returns m or a 
copy of it. Otherwise it will attempt to make a mask, so it will accept any 
sequence of integers of for m. If flag is true, make_mask returns None if its 
return value otherwise would contain no true elements. To make a legal mask, m 
should contain only zeros or ones, but this is not checked.</P>
<P class=Body><A name=pgfId-305014></A><A name=marker-305356></A>getmask (x) 
returns x.<A name=marker-305366></A>mask(), the mask of x, if x is a masked 
array, and None otherwise. Note that getmask may return None if x is a masked 
array but has a mask of None.</P>
<P class=Body><A name=pgfId-304965></A><A name=marker-305367></A>getmaskarray 
(x) returns x.mask() if x is a masked array and has a mask that is not None; 
otherwise it returns a zero mask array of the same shape as x. Unlike getmask, 
getmaskarray always returns an Numeric array of typecode MaskType.</P>
<P class=Body><A name=pgfId-304917></A><A name=marker-305370></A>mask_or (m1, 
m2) returns an object which when used as a mask behaves like the element-wise 
"logical or" of m1 and m2, where m1 and m2 are either masks or None (e.g., they 
are the results of calling getmask). A None is treated as everywhere false. If 
both m1 and m2 are None, it returns None. If just one of them is None, it 
returns the other. If m1 and m2 refer to the same object, a reference to that 
object is returned.</P>
<P class=Body><A name=pgfId-306560></A>masked is a module constant equal to an 
instance of a class that prints as the word `masked' and which will throw an 
exception of type MAError if any attempt is made to do arithmetic upon it. This 
constant is returned when an indexing operation results in a scalar result at a 
masked location.</P>
<P class=Body><A name=pgfId-304946></A><A name=marker-305371></A>set_fill_value 
(a, fill_value) is the same as a.set_fill_value (fill_value) if a is a masked 
array; otherwise it does nothing.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305173></A><A name=72295></A>Copying or 
not?</H6>
<P class=FirstBody><A name=pgfId-305179></A>Depending on the arguments results 
of constructors may or may not contain a separate copy of the data or mask 
arguments. The easiest way to think about this is as follows: the given field, 
be it data or a mask, is required to be a Numerical array, possibly with a given 
typecode, and a mask's shape must match that of the data. If the copy argument 
is zero, and the candidate array otherwise qualifies, a reference will be made 
instead of a copy. If for any reason the data is unsuitable as is, an attempt 
will be made to make a copy that is suitable. Should that fail, an exception 
will be thrown. Thus, a copy=0 argument is more of a hope than a command.</P>
<P class=Body><A name=pgfId-305700></A>Since the default behavior for masks is 
to use a reference if possible, rather than a copy, which produces a sizeable 
time and space savings, it is especially important not to modify something you 
used as a mask argument to a masked array creation routine, if it was a Numeric 
array of typecode MaskType.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305435></A>Behaviors</H6>
<P class=FirstBody><A name=pgfId-305439></A>A masked array defines the 
conversion operators str (x), repr (x), float (x), and int (x) by applying the 
corresponding operator to the Numeric array filled (x)</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-304210></A><A name=marker-304071></A><A 
name=40659></A>Indexing and Slicing</H6>
<P class=Body><A name=pgfId-304211></A>Indexing and slicing differ from Numeric: 
while generally the same, they return a copy, not a reference, when used in an 
expression that produces a non-scalar result. Consider this example:</P>
<P class=Python><A name=pgfId-304212></A>from Numeric import *</P>
<P class=Python><A name=pgfId-304213></A>x = array([1.,2.,3.])</P>
<P class=Python><A name=pgfId-304214></A>y = x[1:]</P>
<P class=Python><A name=pgfId-304215></A>y[0] = 9.</P>
<P class=Python><A name=pgfId-304216></A>print x</P>
<P class=Body><A name=pgfId-304217></A>This will print [1., 9., 3.] since x[1:] 
returns a reference to a portion of x. Doing the same operation using MA, </P>
<P class=Python><A name=pgfId-304218></A>from MA import *</P>
<P class=Python><A name=pgfId-304219></A>x = array([1.,2.,3.])</P>
<P class=Python><A name=pgfId-304220></A>y = x[1:]</P>
<P class=Python><A name=pgfId-304221></A>y[0] = 9.</P>
<P class=Python><A name=pgfId-304222></A>print x</P>
<P class=Body><A name=pgfId-304223></A>will print [1., 2., 3.], while y will be 
a separate array whose present value would be [9., 3.]. While sentiment on the 
correct semantics here is divided amongst the Numeric community as a whole, it 
is not divided amongst the author's community, on whose behalf this package is 
written.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306592></A>Indexing that produces a scalar 
result</H6>
<P class=FirstBody><A name=pgfId-306598></A>If indexing into a masked array with 
one or more indices produces a scalar result, then a scalar value is returned 
rather than a one-element masked array. This raises the issue of what to return 
if that location is masked. The answer is that the module constant masked, 
discussed above, is returned.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-304229></A>Assignment to elements and 
slices</H6>
<P class=FirstBody><A name=pgfId-304233></A>Assignment of a normal value to a 
single element or slice of a masked array has the effect of clearing the mask in 
those locations. In this way previously invalid elements become valid. The value 
being assigned is filled first, so that you are guaranteed that all the elements 
on the left-hand side are now valid. </P>
<P class=Body><A name=pgfId-305698></A>Assignment of None to a single element or 
slice of a masked array has the effect of setting the mask in those locations, 
and the locations become invalid.</P>
<P class=Body><A name=pgfId-305699></A>Since these operations change the mask, 
the result afterwards will no longer share a mask, since masks have 
copy-on-write semantics.</P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-297249></A>Module MA: Attributes</H6>
<P class=FirstBody><A name=pgfId-305713></A>Constants e, pi, NewAxis from 
Numeric, and the constants from module Precision that define nice names for the 
typecodes. </P>
<P class=Body><A name=pgfId-306942></A>The special variable <A 
name=marker-306618></A>masked is discussed in <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#42703">The constant 
masked</A>. </P>
<P class=Body><A name=pgfId-306941></A>The module Numeric is an element of MA, 
so after from MA import *, you can refer to the functions in Numeric such as 
Numeric.ones.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-305706></A>Module MA: Functions</H6>
<P class=BodyAfterHead><A name=pgfId-298310></A>Each of the operations discussed 
below returns an instance of <A name=marker-306622></A>class MA, having 
performed the desired operation element-wise. In most cases the array arguments 
can be masked arrays or Numeric arrays or something that Numeric can turn into a 
Numeric array, such as a list of real numbers.</P>
<P class=Body><A name=pgfId-305885></A>Where Numeric has a function of the same 
name, the behavior of the one in MA is the same, except that it "respects" the 
mask.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-298306></A>Unary functions</H6>
<P class=BodyAfterHead><A name=pgfId-298311></A>The result of a unary operation 
will be masked wherever the original operand was masked. It may also be masked 
if the argument is not in the domain of the function. Functions available are: 
</P>
<P class=Body><A name=pgfId-298322></A><A name=marker-307861></A>sqrt, <A 
name=marker-307862></A>log, <A name=marker-307863></A>log10, <A 
name=marker-307864></A>exp, <A name=marker-307865></A>conjugate, <A 
name=marker-307866></A>sin, <A name=marker-307867></A>cos, <A 
name=marker-307868></A>tan, <A name=marker-307869></A>arcsin, <A 
name=marker-307870></A>arccos, <A name=marker-307871></A>arctan, <A 
name=marker-307872></A>sinh, <A name=marker-307873></A>cosh, <A 
name=marker-307874></A>tanh, <A name=marker-307875></A>absolute, <A 
name=marker-307876></A>fabs, <A name=marker-307877></A>negative (also as 
operator -x), <A name=marker-307878></A>nonzero, <A 
name=marker-307879></A>around, <A name=marker-307880></A>floor</P>
<P class=Body><A name=pgfId-306090></A><A name=marker-307881></A>fabs (x) is the 
absolute value of x as a Float32 array. The other functions have their standard 
meaning.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-298312></A>Binary functions</H6>
<P class=BodyAfterHead><A name=pgfId-298333></A>Binary functions return a result 
that is masked wherever either of the operands were masked; it may also be 
masked where the arguments are not in the domain of the function.</P>
<P class=BodyAfterHead><A name=pgfId-297747></A><A name=marker-307882></A>add 
(also as operator +), <A name=marker-307883></A>subtract (also as operator -), 
<A name=marker-307884></A>multiply (also as operator *), <A 
name=marker-307885></A>divide (also as operator /), <A 
name=marker-307886></A>power (also as operator **), <A 
name=marker-307887></A>remainder, <A name=marker-307888></A>fmod, <A 
name=marker-307889></A>hypot, <A name=marker-307890></A>arctan2, <A 
name=marker-307891></A>bitwise_and, <A name=marker-307892></A>bitwise_or, <A 
name=marker-307893></A>bitwise_xor.</P>
<DIV>
<H6 class=FM3Heading><A name=pgfId-298340></A>Comparison operators</H6>
<DIV>
<H6 class=NoteTip><A name=pgfId-298344></A>
<DIV><IMG src="numdoc_files/numdoc-10.gif"> </DIV>&nbsp;</H6>
<P class=Note><A name=pgfId-304038></A>Due to limitations in Python, it is not 
meaningful to compare arrays using the symbolic comparison operators such as 
"&lt;". Unfortunately, you can do it; the result just won't mean anything.</P>
<DIV>
<H6 class=NoteBottom><A name=pgfId-304013></A>
<DIV><IMG src="numdoc_files/numdoc-11.gif"> </DIV>&nbsp;</H6>
<P class=Body><A name=pgfId-298345></A>To compare arrays, use the following 
binary functions. Each of them returns a masked array of 1's and 0's.</P>
<P class=Body><A name=pgfId-304047></A><A name=marker-307894></A>equal, <A 
name=marker-307895></A>not_equal, <A name=marker-307896></A>less_equal, <A 
name=marker-307897></A>greater_equal, <A name=marker-307898></A>less, <A 
name=marker-307899></A>greater</P>
<P class=Body><A name=pgfId-305376></A>Note that as in Numeric, you can use a 
scalar for one argument and an array for the other. </P></DIV></DIV></DIV>
<DIV>
<H6 class=FM3Heading><A name=pgfId-298353></A>Logical operators</H6>
<P class=BodyAfterHead><A name=pgfId-298357></A>Arrays of logical values can be 
manipulated with:</P>
<P class=Body><A name=pgfId-298358></A><A name=marker-307900></A>l<A 
name=marker-308197></A>ogical_not (unary), <A name=marker-307901></A>logical_or, 
<A name=marker-307902></A>logical_and, <A 
name=marker-307903></A>logical_xor.</P>
<P class=Body><A name=pgfId-298359></A><A name=marker-307904></A>alltrue (x) 
returns 1 if all elements of x are true. Masked elements are treated as 
true.</P>
<P class=Body><A name=pgfId-298360></A><A name=marker-307905></A>sometrue (x) 
returns 1 if any element of x is true. Masked elements are treated as 
false.</P></DIV></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-298365></A><A name=14948></A>Special array 
operators</H6>
<P class=FirstBody><A name=pgfId-305827></A><A name=marker-305831></A>isarray 
(x), <A name=marker-305832></A>isMA (x) return true if x is a masked array.</P>
<P class=Body><A name=pgfId-298407></A><A name=marker-307906></A>rank (x) is the 
number of dimensions in x. </P>
<P class=Body><A name=pgfId-305842></A><A name=marker-307907></A>shape (x) 
returns the shape of x, a tuple of array extents.</P>
<P class=Body><A name=pgfId-305846></A><A name=marker-307908></A>resize (x, 
new_shape) returns a new array with specified shape.</P>
<P class=Body><A name=pgfId-305865></A><A name=marker-307909></A>reshape (x, 
new_shape) returns a copy of x with the given new shape. </P>
<P class=Body><A name=pgfId-305869></A><A name=marker-307910></A>ravel (x) 
returns x as one-dimensional.</P>
<P class=Body><A name=pgfId-305877></A><A name=marker-307911></A>concatenate 
(arrays, axis=0) concatenates the arrays along the specified axis.</P>
<P class=Body><A name=pgfId-305850></A><A name=marker-307912></A>identity (n) 
returns the identity matrix of shape n by n.</P>
<P class=Body><A name=pgfId-305854></A><A name=marker-307913></A>indices 
(dimensions, typecode = None) returns an array representing a grid of indices 
with row-only and column-only variation.</P>
<P class=Body><A name=pgfId-298408></A><A name=marker-307914></A>len (x) is 
defined to be the length of the first dimension of x. This definition, peculiar 
from the array point of view, is required by the way Python implements slicing. 
Use size (x) for the total length of x.</P>
<P class=Body><A name=pgfId-298465></A><A name=marker-307915></A>size (x, axis = 
None) is the total size of x, or the length of a particular dimension axis whose 
index is given. When axis is given the dimension of the result is one less than 
the dimension of x.</P>
<P class=Body><A name=pgfId-298461></A><A name=marker-307916></A>count (x, axis 
= None) counts the number of (non-masked) elements in the array, or in the array 
along a certain axis.When axis is given the dimension of the result is one less 
than the dimension of x.</P>
<P class=Body><A name=pgfId-305809></A><A name=marker-305810></A>arange, <A 
name=marker-305817></A><A name=marker-305818></A>arrayrange, <A 
name=marker-305822></A>ones, and <A name=marker-305826></A>zeros are the same as 
in Numeric, but return masked arrays.</P>
<P class=Body><A name=pgfId-298470></A><A name=marker-307917></A>sum, and <A 
name=marker-307918></A>product are called the same way as count; the difference 
is that the result is the sum, product, or average respectively of the unmasked 
element.</P>
<P class=Body><A name=pgfId-307970></A><A name=marker-308029></A>average (x, 
axis=0, weights=None) computes the average value of the non-masked elements of x 
along the selected axis. If weights is given, it must match the size and shape 
of x, and the value returned is:</P>
<P class=CBlockIndent><A name=pgfId-308000></A><IMG align=baseline 
src="numdoc_files/numdoc-12.gif"> &nbsp;</P>
<P class=Body><A name=pgfId-308008></A>In computing these sums, elements that 
correspond to those that are masked in x or weights are ignored.</P>
<P class=Body><A name=pgfId-298369></A><A name=marker-307920></A>allclose (x, y, 
fill_value = 1, rtol = 1.e-5, atol = 1.e-8) tests whether or not arrays x and y 
are equal subject to the given relative and absolute tolerances. If fill_value 
is 1, masked values are considered equal, otherwise they are considered 
different. The formula used for elements where both x and y have a valid value 
is:</P></DIV></DIV>
<DIV>
<H6 class=Code><A name=pgfId-298386></A>| x - y | &lt; atol + rtol * | y |</H6>
<P class=Body><A name=pgfId-298393></A>This means essentially that both elements 
are small compared to atol or their difference divided by their value is small 
compared to rtol.</P>
<P class=Body><A name=pgfId-298403></A><A name=marker-307921></A>allequal (x, y, 
fill_value = 1) is similar to allclose, except that exact equality is 
demanded.</P>
<P class=Body><A name=pgfId-305881></A><A name=marker-307922></A>take (a, 
indices, axis=0) returns a selection of items from a. See the documentation in 
the Numeric manual.</P>
<P class=Body><A name=pgfId-307667></A><A name=marker-307923></A>transpose (a, 
axes=None) performs a reordering of the axes depending on the tuple of indices 
<EM class=Code>axes</EM> ; the default is to reverse the order of the axes.</P>
<P class=Body><A name=pgfId-306637></A><A name=marker-307924></A>put (a, 
indices, values) is the opposite of <EM class=Code>take</EM> . The values of the 
array <EM class=Code>a</EM> at the locations specified in <EM 
class=Code>indices</EM> are set to the corresponding value of <EM 
class=Code>values</EM> . The array <EM class=Code>a </EM>must be a contiguous 
array. The argument indices can be any integer sequence object with values 
suitable for indexing into the flat form of <EM class=Code>a</EM> . The argument 
v must be any sequence of values that can be converted to the typecode of <EM 
class=Code>a</EM> .</P>
<P class=Python><A name=pgfId-306639></A>&gt;&gt;&gt; <EM class=CodeInput>x = 
arange(6)</EM> </P>
<P class=Python><A name=pgfId-306640></A>&gt;&gt;&gt; <EM class=CodeInput>put(x, 
[2,4], [20,40])</EM> </P>
<P class=Python><A name=pgfId-306641></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-306642></A>[ 0 1 20 3 40 5 ]</P>
<P class=Body><A name=pgfId-306666></A>Note that the target array <EM 
class=Code>a</EM> is not required to be one-dimensional. Since it is contiguous 
and stored in row-major order, the array <EM class=Code>indices</EM> can be 
treated as indexing <EM class=Code>a</EM> 's elements in storage order. </P>
<P class=Body><A name=pgfId-306676></A>The wrinkle on this for masked arrays is 
that if the locations being set by put are masked, the mask is cleared in those 
locations.</P>
<P class=Body><A name=pgfId-307940></A><A name=marker-307939></A>choose 
(condition, t) has a result shaped like condition. t must be a tuple of two 
arrays t1 and t2. Each element of the result is the corresponding element of t1 
where condition is true, and the corresponding element of t2 where condition is 
false. The result is masked where condition is masked or where the selected 
element is masked. </P>
<P class=Body><A name=pgfId-307942></A>If one element of t is the special 
element <A name=marker-307941></A>masked (<A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#42703">See The 
constant masked.</A>), the type of the result will be the type of the other 
array. Otherwise, the type of the result is computed using the standard coercion 
rules.</P>
<P class=Body><A name=pgfId-305858></A><A name=marker-307860></A>where 
(condition, x, y) returns an array that is filled (x) where condition is true, 
filled (y) where the condition is false, and masked where any of the three 
arguments is masked. It is implemented using choose.</P>
<P class=Body><A name=pgfId-305886></A><A name=marker-307925></A>innerproduct 
(a, b) and dot (a, b) work as in Numeric, but missing values don't contribute. 
The result is always a masked array, possibly of length one, because of the 
possibility that one or more entries in it may be invalid since all the data 
contributing to that entry was invalid.</P>
<P class=Body><A name=pgfId-307701></A><A name=marker-307926></A>outerproduct 
(a, b) produces a masked array such that result[i, j] = a[i] * b[j]. The result 
will be masked where a[i] or b[j] is masked.</P>
<P class=Body><A name=pgfId-305887></A><A name=marker-307928></A>compress 
(condition, x, dimension=-1) compresses out only those valid values where 
condition is true.</P>
<P class=Body><A name=pgfId-305907></A><A name=marker-307929></A>maximum (x, y = 
None) and <A name=marker-307930></A>minimum (x, y = None) compute the minimum 
and maximum valid values of x if y is None; with two arguments, they return the 
element-wise larger or smaller of valid values, and mask the result where either 
x or y is masked.</P>
<P class=Body><A name=pgfId-305914></A><A name=marker-307931></A>sort (x, 
axis=-1, value = None) returns the array x sorted along the given axis, with 
masked values treated as if they have a sort value of value but they are masked 
in the result.</P>
<P class=Body><A name=pgfId-305918></A><A name=marker-307932></A>argsort (x, 
axis = -1, fill_value = None) is unusual in that it returns a Numeric array, 
equal to <BR>Numeric.argsort (filled (x, fill_value), axis); this is an array of 
indices for sorting along a given axis.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305726></A>Controlling the size of the string 
representations</H6>
<P class=FirstBody><A name=pgfId-305730></A>The functions <A 
name=marker-307933></A>get_print_limit () and <A 
name=marker-307934></A>set_print_limit (n=0) query and set the limit for 
converting arrays using str() or repr (). If an array is printed that is larger 
than this, the values are not printed; rather you are informed of the type and 
size of the array. If n is zero, the standard Numeric conversion functions are 
used.</P>
<P class=Body><A name=pgfId-306167></A>When imported, MA sets this limit to 300, 
and the limit is also made to apply to standard Numeric arrays as 
well.</P></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-304172></A>Helper classes</H6>
<P class=FirstBody><A name=pgfId-305725></A>This section discusses other classes 
defined in module MA.</P>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306892></A>MAError</H6>
<P class=FirstBody><A name=pgfId-306893></A>Class <A 
name=marker-307935></A>MAError inherits from Exception, used to raise exceptions 
in the MA module. Other exceptions are possible, such as errors from the 
underlying Numeric module.</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306894></A><A name=42703></A>The constant <A 
name=marker-307936></A>masked</H6>
<P class=Body><A name=pgfId-306895></A>A constant named masked, in Module MA, 
serves several purposes.</P>
<OL>
  <LI class=Numbered1><A name=pgfId-306896></A>When a indexing operation on an 
  MA instance returns a scalar result, but the location indexed was masked, then 
  masked is returned. For example, given a one-dimensional array x such that 
  x.mask(3) is 1, then x[3] is masked. 
  <LI class=Numbered><A name=pgfId-306897></A>When masked is assigned to 
  elements of an array via indexing or slicing, those elements become masked. So 
  after x[3] = masked, x[3] is masked. 
  <LI class=Numbered><A name=pgfId-306898></A>masked.display() is a string that 
  may be used to indicate those elements of an array that are masked when the 
  array is converted to a string, as happens with the print statement. 
  <LI class=Numbered><A name=pgfId-306899></A><A 
  name=marker-307957></A>masked.set_display (string) can be used to change the 
  value; the default is `--'. 
  <LI class=Numbered><A name=pgfId-306900></A>masked.enable(flag) can be used to 
  enable (flag = 1, default) the use of the display string. If disabled 
  (flag=0), the conversion to string becomes equivalent to str(self.filled()). 
  <LI class=Numbered><A name=pgfId-306901></A>masked.enabled() returns the state 
  of the display-enabling flag. 
  <LI class=Numbered><A name=pgfId-306902></A>Most operations on masked will 
  result in an exception being raised. </LI></OL>
<DIV>
<H6 class=FM3Heading><A name=pgfId-306903></A>Example of masked behavior</H6>
<P class=Python><A name=pgfId-306904></A>&gt;&gt;&gt; <EM class=CodeInput>from 
MA import *</EM> </P>
<P class=Python><A name=pgfId-306905></A>&gt;&gt;&gt; <EM 
class=CodeInput>x=arange(10)</EM> </P>
<P class=Python><A name=pgfId-306906></A>&gt;&gt;&gt; <EM class=CodeInput>x[3] = 
masked</EM> </P>
<P class=Python><A name=pgfId-306907></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-306908></A>[0 ,1 ,2 ,-- ,4 ,5 ,6 ,7 ,8 ,9 ,]</P>
<P class=Python><A name=pgfId-306909></A>&gt;&gt;&gt; <EM class=CodeInput>print 
repr(x)</EM> </P>
<P class=Python><A name=pgfId-306910></A>*** Masked array, mask present ***</P>
<P class=Python><A name=pgfId-306911></A>Data:</P>
<P class=Python><A name=pgfId-306912></A>[0 ,1 ,2 ,-- ,4 ,5 ,6 ,7 ,8 ,9 ,]</P>
<P class=Python><A name=pgfId-306913></A>Mask (fill value [0,])</P>
<P class=Python><A name=pgfId-306914></A>[0,0,0,1,0,0,0,0,0,0,]</P>
<P class=Python><A name=pgfId-306915></A>&nbsp;</P>
<P class=Python><A name=pgfId-306916></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[3]</EM> </P>
<P class=Python><A name=pgfId-306917></A>--</P>
<P class=Python><A name=pgfId-306918></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x[3] + 1.0</EM> </P>
<P class=Python><A name=pgfId-306919></A>Traceback (innermost last):</P>
<P class=Python><A name=pgfId-306920></A>File "&lt;stdin&gt;", line 1, in ?</P>
<P class=Python><A name=pgfId-306921></A>File 
"/pcmdi/dubois/prerelease/linux/lib/python1.5/site-packages/MA/__init__.py", 
line 62, in nope</P>
<P class=Python><A name=pgfId-306922></A>raise MAError, 'Cannot do requested 
operation with a masked value.'</P>
<P class=Python><A name=pgfId-306923></A>MA.MAError: Cannot do requested 
operation with a masked value.</P></DIV></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305737></A>Class masked_unary_function</H6>
<P class=FirstBody><A name=pgfId-305741></A>Given a unary array function f (x), 
<A name=marker-305745></A>masked_unary_function (f, fill = 0, domain = None) is 
a function which when applied to an argument x returns f applied to the array 
filled (x, fill), with a mask equal to <BR>mask_or (getmask (x), domain (x)). 
</P>
<P class=Body><A name=pgfId-305744></A>The argument domain therefore should be a 
callable object that returns true where x is not in the domain of f. The 
following domains are also supplied as members of module MA:</P>
<UL>
  <LI class=Bullet><A name=pgfId-305749></A>domain_check_interval (a, b) (x) = 
  true where x &lt; a or y &gt; b. 
  <LI class=Bullet><A name=pgfId-305753></A>domain_tan (eps) (x) is true where 
  abs (cos (x)) &lt; eps, that is, a domain suitable for the tangent function. 
  <LI class=Bullet><A name=pgfId-305754></A>domain_greater (v) (x) is true where 
  x &lt;= v. 
  <LI class=Bullet><A name=pgfId-305755></A>domain_greater_equal (v) (x) is true 
  where x &lt; v. </LI></UL></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-305759></A>Class masked_binary_function</H6>
<P class=BodyAfterHead><A name=pgfId-305766></A>Given a binary array function f 
(x, y), masked_binary_function (f, fillx=0, filly=0, domain=None) defines a 
function whose value at x is f (filled (x, fillx), filled (y, filly)) with a 
resulting mask of mask_or (getmask (x), getmask (y), mask_or'd again with those 
locations where domain (x, y) is true. The values fillx and filly must be chosen 
so that (fillx, filly) is in the domain of f. </P>
<P class=Body><A name=pgfId-305771></A>In addition, an instance of 
masked_binary_function has two methods defined upon it:</P>
<UL>
  <LI class=Bullet><A name=pgfId-305772></A>reduce (target, axis = 0) 
  <LI class=Bullet><A name=pgfId-305776></A>accumulate (target, axis = 0) 
</LI></UL>
<P class=Body><A name=pgfId-305780></A>These methods perform reduction and 
accumulation as discussed in the section <A class=XRef 
href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#87042">Ufuncs have 
special methods</A>.</P>
<P class=Body><A name=pgfId-305787></A>The following domains are available for 
use as the domain argument:</P>
<UL>
  <LI class=Bullet><A name=pgfId-305788></A>domain_safe_divide () (x, y) is true 
  where absolute(x)*1.e-35 &gt; absolute (y). As the comments in the code say, 
  "better ideas welcome". This domain is used for the divide operator. 
</LI></UL></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306950></A>ActiveAttributes</H6>
<P class=FirstBody><A name=pgfId-306954></A>MA contains a subpackage, 
MA.activeattr, which defines the class ActiveAttributes. Class MA inherits from 
ActiveAttributes. </P>
<P class=Body><A name=pgfId-306961></A>An active attribute is a name, say 
active, that appears to be an attribute of a class instance but which in fact is 
implemented by a triplet of functions, one each corresponding to the operations 
x.active, x.active = value, and del x.active. To create such an attribute, you 
inherit from ActiveAttributes and in your classes' initialization routine you 
do:</P>
<P class=Python><A name=pgfId-306968></A>ActiveAttributes.__init__(self) # safe 
for multiple inheritance</P>
<P class=Python><A name=pgfId-306972></A>self.add_active_attribute_handler 
("active", self.actg, </P>
<P class=Python><A name=pgfId-306989></A>self.acts, self.actd)</P>
<P class=Body><A name=pgfId-306973></A>Here actg, acts, and actd are the three 
handlers, which should be methods of this class with signatures actg(self), 
acts(self, value), and actd(self). The last two arguments to 
add_active_attribute_handler can be None, in which case the "active" attribute 
will behave as if it is read-only.</P>
<P class=Body><A name=pgfId-306990></A>The "attributes" shape, flat, real, and 
imag in class MA are actually "active" attributes.</P>
<P class=Body><A name=pgfId-306991></A>ActiveAttributes also contains 
methods:</P>
<P class=Python><A name=pgfId-306994></A>def get_active_attribute_handler (self, 
name):</P>
<P class=Python><A name=pgfId-306995></A>"Get current attribute handler 
associated with a name."</P>
<P class=Python><A name=pgfId-306998></A>def get_active_attributes (self):</P>
<P class=Python><A name=pgfId-306999></A>"Return the list of attributes that 
have handlers."</P>
<P class=Python><A name=pgfId-307002></A>def get_attribute_mode (self, 
name):</P>
<P class=Python><A name=pgfId-307003></A>"Get the mode of an attribute readonly 
('r') or writeable ('w')."</P>
<P class=Python><A name=pgfId-307006></A>def get_basic_attribute_handler 
(self):</P>
<P class=Python><A name=pgfId-307046></A>"Returns the underlying methods that 
handle the three events."</P>
<P class=Python><A name=pgfId-307071></A>def remove_active_attribute_handler 
(self, name):</P>
<P class=Python><A name=pgfId-307356></A>"Remove the `active' behavior for 
name."</P></DIV></DIV>
<DIV>
<H6 class=FM1Heading><A name=pgfId-306123></A>Examples of Using MA</H6>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306127></A>Data with a given value 
representing missing data</H6>
<P class=FirstBody><A name=pgfId-306131></A>Suppose we have read a 
one-dimensional list of elements named x. We also know that if any of the values 
are 1.e20, they represent missing data. We want to compute the average value of 
the data and the vector of deviations from average.</P>
<P class=Python><A name=pgfId-306443></A>&gt;&gt;&gt; <EM class=CodeInput>from 
MA import *</EM> </P>
<P class=Python><A name=pgfId-306505></A>&gt;&gt;&gt; x = arange(5)</P>
<P class=Python><A name=pgfId-306511></A>&gt;&gt;&gt; x[2] = 1.e20</P>
<P class=Python><A name=pgfId-306508></A>&gt;&gt;&gt; y = masked_values (x, 
1.e20)</P>
<P class=Python><A name=pgfId-306477></A>&gt;&gt;&gt; print average(y)</P>
<P class=Python><A name=pgfId-306478></A>2.0</P>
<P class=Python><A name=pgfId-306479></A>&gt;&gt;&gt; print y-average(y)</P>
<P class=Python><A name=pgfId-306482></A>[ -2.00000000e+00, -1.00000000e+00, --, 
1.00000000e+00,</P>
<P class=Python><A name=pgfId-306483></A>2.00000000e+00,]</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306145></A>Filling in the missing data</H6>
<P class=FirstBody><A name=pgfId-306155></A>Suppose now that we wish to print 
that same data, but with the missing values replaced by the average value.</P>
<P class=Python><A name=pgfId-306156></A>&gt;&gt;&gt; <EM class=CodeInput>print 
filled (y, average(y))</EM> </P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306378></A>Numerical operations</H6>
<P class=FirstBody><A name=pgfId-306382></A>We can do numerical operations 
without worrying about missing values, dividing by zero, square roots of 
negative numbers, etc.</P>
<P class=Python><A name=pgfId-306388></A>&gt;&gt;&gt; <EM class=CodeInput>from 
MA import *</EM> </P>
<P class=Python><A name=pgfId-306389></A>&gt;&gt;&gt; <EM 
class=CodeInput>x=array([1., -1., 3., 4., 5., 6.], mask=[0,0,0,0,1,0])</EM> </P>
<P class=Python><A name=pgfId-306390></A>&gt;&gt;&gt; <EM 
class=CodeInput>y=array([1., 2., 0., 4., 5., 6.], mask=[0,0,0,0,0,1])</EM> </P>
<P class=Python><A name=pgfId-306391></A>&gt;&gt;&gt; <EM class=CodeInput>print 
sqrt(x/y)</EM> </P>
<P class=Python><A name=pgfId-306392></A>[ 1.00000000e+00, --, --, 
1.00000000e+00, --, --,]</P>
<P class=Body><A name=pgfId-306383></A>Note that four values in the result are 
invalid: one from a negative square root, one from a divide by zero, and two 
more where the two arrays x and y had invalid data. Since the result was of a 
real type, the print command printed str (filled (sqrt (x/y))).</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306406></A>Seeing the mask</H6>
<P class=FirstBody><A name=pgfId-306410></A>There are various ways to see the 
mask. One is to print is directly, the other is to convert to the repr 
representation, and a third is get the mask itself. Use of getmask(x) is more 
robust than x.mask(), since it will work (returning None) if x is a Numeric 
array or list.</P>
<P class=Python><A name=pgfId-307389></A>&gt;&gt;&gt; <EM 
class=CodeInput>x=arange(10)</EM> </P>
<P class=Python><A name=pgfId-307390></A>&gt;&gt;&gt; <EM class=CodeInput>x[3:5] 
= masked</EM> </P>
<P class=Python><A name=pgfId-307391></A>&gt;&gt;&gt; <EM class=CodeInput>print 
x</EM> </P>
<P class=Python><A name=pgfId-307392></A>[0 ,1 ,2 ,-- ,-- ,5 ,6 ,7 ,8 ,9 ,]</P>
<P class=Python><A name=pgfId-307393></A>&gt;&gt;&gt; <EM class=CodeInput>print 
repr(x)</EM> </P>
<P class=Python><A name=pgfId-307394></A>*** Masked array, mask present ***</P>
<P class=Python><A name=pgfId-307395></A>Data:</P>
<P class=Python><A name=pgfId-307396></A>[0 ,1 ,2 ,-- ,-- ,5 ,6 ,7 ,8 ,9 ,]</P>
<P class=Python><A name=pgfId-307397></A>Mask (fill value [0,])</P>
<P class=Python><A name=pgfId-307398></A>[0,0,0,1,1,0,0,0,0,0,]</P>
<P class=Python><A name=pgfId-307399></A>&nbsp;</P>
<P class=Python><A name=pgfId-307400></A>&gt;&gt;&gt; <EM class=CodeInput>print 
getmask(x)</EM> </P>
<P class=Python><A name=pgfId-307401></A>[0,0,0,1,1,0,0,0,0,0,]</P>
<P class=Python><A name=pgfId-307387></A>&nbsp;</P></DIV>
<DIV>
<H6 class=FM2Heading><A name=pgfId-306428></A>Filling it your way</H6>
<P class=FirstBody><A name=pgfId-306441></A>If we want to print the data with 
-1's where the elements are masked, we use filled.</P>
<P class=Python><A name=pgfId-306433></A>&gt;&gt;&gt; <EM class=CodeInput>print 
filled(z, -1)</EM> </P>
<P class=Python><A name=pgfId-306434></A>[ 1.,-1.,-1., 1.,-1.,-1.,]</P>
<P class=Python><A name=pgfId-306415></A>&nbsp;</P>
<P class=IndexTitle><A name=pgfId-862972></A>Index</P></DIV></DIV></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869780></A>Symbols<A 
name=Symbols></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869782></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307929">103</A> 

  <LI class=Level1IX><A name=pgfId-869784></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59821">... 
  28</A> 
  <LI class=Level1IX><A name=pgfId-869786></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59830">: 
  26</A> 
  <LI class=Level1IX><A name=pgfId-869788></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59831"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59857">:: 27, 
  57</A></A> 
  <LI class=Level1IX><A name=pgfId-869791></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59753">_PyArray_multiply_list 
  72</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869793></A>A<A name=Numerics></A><A 
name=A></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869796></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59698">alltrue() 
  47</A> 
  <LI class=Level1IX><A name=pgfId-869798></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-66025">argmax() 
  42</A> 
  <LI class=Level1IX><A name=pgfId-869800></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-65840">argsort() 
  42</A> 
  <LI class=Level1IX><A name=pgfId-869802></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59794">array 
  79</A> 
  <LI class=Level1IX><A name=pgfId-869804></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59711">Array 
  Attributes 51</A> 
  <LI class=Level1IX><A name=pgfId-869806></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59632">Array 
  Functions 37</A> 
  <LI class=Level1IX><A name=pgfId-869808></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59710">Array 
  Methods 49</A> 
  <LI class=Level1IX><A name=pgfId-869810></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59546">array() 
  14</A> 
  <LI class=Level1IX><A name=pgfId-869812></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59658">array_repr() 
  45</A> 
  <LI class=Level1IX><A name=pgfId-869814></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59659">array_str() 
  45</A> 
  <LI class=Level1IX><A name=pgfId-869816></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59729">array2string 
  59</A> 
  <LI class=Level1IX><A name=pgfId-869818></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59737">arrayobject.h 
  63</A> 
  <LI class=Level1IX><A name=pgfId-869820></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59594">arrayrange() 
  19</A> 
  <LI class=Level1IX><A name=pgfId-869822></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-308206">arrays 
  with missing values 95</A> 
  <LI class=Level1IX><A name=pgfId-869824></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59617">astype 
  24</A> 
  <LI class=Level1IX><A name=pgfId-869826></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59609">Automatic 
  Coercions 22</A> 
  <LI class=Level1IX><A name=pgfId-869828></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59544">axes 
  13</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869830></A>B<A name=B></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869832></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59727">Broadcasting 
  59</A> 
  <LI class=Level1IX><A name=pgfId-869834></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68554">Bugs 
  6</A> 
  <LI class=Level1IX><A name=pgfId-869836></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59707">byteswapped() 
  49</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869838></A>C<A name=C></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869840></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59608">Casting 
  22</A> 
  <LI class=Level1IX><A name=pgfId-869842></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59548">Character 
  14</A> 
  <LI class=Level1IX><A name=pgfId-869844></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59484">choose 
  40</A> 
  <LI class=Level1IX><A name=pgfId-869846></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59647">clip() 
  43</A> 
  <LI class=Level1IX><A name=pgfId-869848></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-67986">Code 
  Organization 53</A> 
  <LI class=Level1IX><A name=pgfId-869850></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59607">Coercion 
  22</A> 
  <LI class=Level1IX><A name=pgfId-869852></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59576">Complex 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869854></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-84325">complex 
  numbers 14</A> 
  <LI class=Level1IX><A name=pgfId-869856></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59577">Complex0 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869858></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59582">Complex128 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869860></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59579">Complex16 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869862></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59580">Complex32 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869864></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59581">Complex64 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869866></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59578">Complex8 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869868></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59638">compress() 
  40</A> 
  <LI class=Level1IX><A name=pgfId-869870></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59651">concatenate() 
  44</A> 
  <LI class=Level1IX><A name=pgfId-869872></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59740">Contiguous 
  arrays 65</A> 
  <LI class=Level1IX><A name=pgfId-869874></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-60951">Convenience 
  11</A> 
  <LI class=Level1IX><A name=pgfId-869876></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-67940">convolve 
  46</A> 
  <LI class=Level1IX><A name=pgfId-869878></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-67939">correlation 
  47</A> 
  <LI class=Level1IX><A name=pgfId-869880></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-67939">cross_correlate 
  47</A> 
  <LI class=Level1IX><A name=pgfId-869882></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59697">cumproduct() 
  47</A> 
  <LI class=Level1IX><A name=pgfId-869884></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59695">cumsum() 
  47</A> 
  <LI class=Level1IX><A name=pgfId-869886></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68553">CVS 
  6</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869888></A>D<A name=D></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869890></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303081">determinant() 
  87</A> 
  <LI class=Level1IX><A name=pgfId-869892></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59639"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59662">diagonal() 
  41, 46</A></A> 
  <LI class=Level1IX><A name=pgfId-869895></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59543">dimensions 
  13</A> 
  <LI class=Level1IX><A name=pgfId-869897></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68556">Discussion 
  list 6</A> 
  <LI class=Level1IX><A name=pgfId-869899></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68604">Distutils 
  63</A> 
  <LI class=Level1IX><A name=pgfId-869901></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305509">Dubois, 
  Paul F. 95</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869903></A>E<A name=E></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869905></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303046">eigenvalues() 
  86</A> 
  <LI class=Level1IX><A name=pgfId-869907></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303057">eigenvectors() 
  87</A> 
  <LI class=Level1IX><A name=pgfId-869909></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-61094">element-wise 
  13</A> 
  <LI class=Level1IX><A name=pgfId-869911></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59725">Ellipses 
  58</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869913></A>F<A name=F></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869915></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-302950">FFT 
  83</A> 
  <LI class=Level1IX><A name=pgfId-869917></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-302957">fft() 
  83</A> 
  <LI class=Level1IX><A name=pgfId-869919></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59712">flat 
  (attribute) 51</A> 
  <LI class=Level1IX><A name=pgfId-869921></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59566">Float 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869923></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59570">Float0 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869925></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59575">Float128 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869927></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59572">Float16 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869929></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59573">Float32 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869931></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59574">Float64 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869933></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59571">Float8 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869935></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59732">floating 
  point exceptions 62</A> 
  <LI class=Level1IX><A name=pgfId-869937></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68559">Fortran 
  and Python 7</A> 
  <LI class=Level1IX><A name=pgfId-869939></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59733">fpectl 
  62</A> 
  <LI class=Level1IX><A name=pgfId-869941></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59598">fromfunction() 
  20</A> 
  <LI class=Level1IX><A name=pgfId-869943></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59645"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-67905">fromstring() 
  43, 47</A></A> 
  <LI class=Level1IX><A name=pgfId-869946></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68557">FTP 
  Site 7</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869948></A>G<A name=G></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869950></A>gather 
  <UL>
    <LI class=Level2IX><A name=pgfId-869951></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-78559">see 
    put() 38</A> </LI></UL>
  <LI class=Level1IX><A name=pgfId-869953></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303078">generalized_inverse() 
  87</A> 
  <LI class=Level1IX><A name=pgfId-869955></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303098">get_seed() 
  88</A> 
  <LI class=Level1IX><A name=pgfId-869957></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59618">Getting 
  array values 25</A> 
  <LI class=Level1IX><A name=pgfId-869959></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59531">greece 
  8</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869961></A>H<A name=H></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869963></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68605">header 
  files 63</A> 
  <LI class=Level1IX><A name=pgfId-869965></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59541">homogeneous 
  13</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-869967></A>I<A name=I></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-869969></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59606"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59693">identity() 
  21, 47</A></A> 
  <LI class=Level1IX><A name=pgfId-869972></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59534">IDLE 
  9</A> 
  <LI class=Level1IX><A name=pgfId-869974></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59714">imaginary 
  (attribute) 51</A> 
  <LI class=Level1IX><A name=pgfId-869976></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-84325">imaginary 
  numbers 14</A> 
  <LI class=Level1IX><A name=pgfId-869978></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68605">import_array() 
  63</A> 
  <LI class=Level1IX><A name=pgfId-869980></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59724">Indexing 
  57</A> 
  <LI class=Level1IX><A name=pgfId-869982></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-66266">indices() 
  43</A> 
  <LI class=Level1IX><A name=pgfId-869984></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59656">innerproduct() 
  45</A> 
  <LI class=Level1IX><A name=pgfId-869986></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59513">Installing 
  NumPy 5</A> 
  <LI class=Level1IX><A name=pgfId-869988></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59558">Int 
  14</A> 
  <LI class=Level1IX><A name=pgfId-869990></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59559">Int0 
  14</A> 
  <LI class=Level1IX><A name=pgfId-869992></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59565">Int128 
  15</A> 
  <LI class=Level1IX><A name=pgfId-869994></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59561">Int16 
  14</A> 
  <LI class=Level1IX><A name=pgfId-869996></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59562">Int32 
  14</A> 
  <LI class=Level1IX><A name=pgfId-869998></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59563">Int64 
  14</A> 
  <LI class=Level1IX><A name=pgfId-870000></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59560">Int8 
  14</A> 
  <LI class=Level1IX><A name=pgfId-870002></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303022">inverse() 
  86</A> 
  <LI class=Level1IX><A name=pgfId-870004></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-302969">inverse_fft() 
  83</A> 
  <LI class=Level1IX><A name=pgfId-870006></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-302985">inverse_real_fft() 
  84</A> 
  <LI class=Level1IX><A name=pgfId-870008></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59705">iscontiguous() 
  49</A> 
  <LI class=Level1IX><A name=pgfId-870010></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59704">itemsize() 
  49</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870012></A>L<A name=J></A><A name=K></A><A 
name=L></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870016></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307934">limiting 
  printing of large arrays 103</A> 
  <LI class=Level1IX><A name=pgfId-870018></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303084">linear_least_squares() 
  87</A> 
  <LI class=Level1IX><A name=pgfId-870020></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59626">Logical 
  Ufuncs 32</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870022></A>M<A name=M></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870024></A>MA 
  <UL>
    <LI class=Level2IX><A name=pgfId-870025></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307875">absolute 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870027></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307882">add 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870029></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307920">allclose 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870031></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307921">allequal 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870033></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307904">alltrue 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870035></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305810">arange 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870037></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307870">arccos 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870039></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307869">arcsin 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870041></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307871">arctan 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870043></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307890">arctan2 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870045></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307932">argsort 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870047></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307882">arithmetic 
    operators 101</A> 
    <LI class=Level2IX><A name=pgfId-870049></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307879">around 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870051></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305800">array 
    (constructor) 98</A> 
    <LI class=Level2IX><A name=pgfId-870053></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305817">arrayrange 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870055></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-308029">average 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870057></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307891">bitwise_and 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870059></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307892">bitwise_or 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870061></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307893">bitwise_xor 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870063></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307939">choose 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870065></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-306622">class 
    MA 101</A> 
    <LI class=Level2IX><A name=pgfId-870067></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307897">comparisons 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870069></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307928">compress 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870071></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307911">concatenate 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870073></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307865">conjugate 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870075></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305344">conversion 
    to Numeric array 98</A> 
    <LI class=Level2IX><A name=pgfId-870077></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307867">cos 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870079></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307873">cosh 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870081></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307916">count 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870083></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305349">default_character_fill_value 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870085></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305348">default_complex_fill_value 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870087></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305350">default_integer_fill_value 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870089></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305352">default_object_fill_value 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870091></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305365">default_real_fill_value 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870093></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307885">divide 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870095></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307894">equal 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870097></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307864">exp 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870099></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307876">fabs 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870101></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305346">fill_value 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870103></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305344">filled 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870105></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307880">floor 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870107></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307888">fmod 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870109></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-304071">functions 
    and operators 100</A> 
    <LI class=Level2IX><A name=pgfId-870111></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307933">get_print_limit 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870113></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305356">getmask 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870115></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305367">getmaskarray 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870117></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307899">greater 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870119></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307897">greater_equal 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870121></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307889">hypot 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870123></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307912">identity 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870125></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307913">indices 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870127></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307925">innerproduct 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870129></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305507">installing 
    95</A> 
    <LI class=Level2IX><A name=pgfId-870131></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305508">invalid, 
    defined 95</A> 
    <LI class=Level2IX><A name=pgfId-870133></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305354">is_mask 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870135></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305831">isarray 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870137></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305832">isMA 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870139></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307914">len 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870141></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307898">less 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870143></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307896">less_equal 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870145></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307862">log 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870147></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307863">log10 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870149></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307900">logical 
    operators 101</A> 
    <LI class=Level2IX><A name=pgfId-870151></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307902">logical_and 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870153></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-308197">logical_not 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870155></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307901">logical_or 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870157></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307903">logical_xor 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870159></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307935">MAError 
    104</A> 
    <LI class=Level2IX><A name=pgfId-870161></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305355">make_mask 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870163></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305366">mask 
    method 99</A> 
    <LI class=Level2IX><A name=pgfId-870165></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305802">mask_object 
    (constructor) 98</A> 
    <LI class=Level2IX><A name=pgfId-870167></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305370">mask_or 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870169></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305506">mask_values 
    95</A> 
    <LI class=Level2IX><A name=pgfId-870171></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307936">masked 
    (constant) 104</A> 
    <LI class=Level2IX><A name=pgfId-870173></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307957">masked 
    (constant), role in printing 104</A> 
    <LI class=Level2IX><A name=pgfId-870175></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-306591">masked 
    (module constant) 99</A> 
    <LI class=Level2IX><A name=pgfId-870177></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-306618">masked 
    (special constant) 101</A> 
    <LI class=Level2IX><A name=pgfId-870179></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305508">masked, 
    defined 95</A> 
    <LI class=Level2IX><A name=pgfId-870181></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307941">masked, 
    special role in choose 103</A> 
    <LI class=Level2IX><A name=pgfId-870183></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-304072">masked_array 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870185></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305801">masked_array 
    (constructor) 98</A> 
    <LI class=Level2IX><A name=pgfId-870187></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307797">masked_equal 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870189></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307789">masked_greater 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870191></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307793">masked_greater_equal 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870193></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307805">masked_less 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870195></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307809">masked_less_equal 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870197></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307801">masked_not_equal 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870199></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305745">masked_unary_function 
    104</A> 
    <LI class=Level2IX><A name=pgfId-870201></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307810">masked_values 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870203></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307732">masked_where 
    98</A> 
    <LI class=Level2IX><A name=pgfId-870205></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305353">masks 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870207></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307929">maximum 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870209></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307929">maximum 
    with two arguments 103</A> 
    <LI class=Level2IX><A name=pgfId-870211></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307930">minimum 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870213></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307884">multiply 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870215></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307877">negative 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870217></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307878">nonzero 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870219></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307895">not_equal 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870221></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305822">ones 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870223></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307926">outerproduct 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870225></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307886">power 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870227></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307918">product 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870229></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307924">put 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870231></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307906">rank 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870233></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307910">ravel 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870235></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307887">remainder 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870237></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307909">reshape 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870239></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307908">resize 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870241></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305371">set_fill_value 
    99</A> 
    <LI class=Level2IX><A name=pgfId-870243></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307934">set_print_limit 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870245></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307907">shape 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870247></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307866">sin 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870249></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307872">sinh 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870251></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307915">size 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870253></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307905">sometrue 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870255></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307931">sort 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870257></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307861">sqrt 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870259></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307883">subtract 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870261></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307917">sum 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870263></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307922">take 
    102</A> 
    <LI class=Level2IX><A name=pgfId-870265></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307868">tan 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870267></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307874">tanh 
    101</A> 
    <LI class=Level2IX><A name=pgfId-870269></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307923">transpose 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870271></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307860">where 
    103</A> 
    <LI class=Level2IX><A name=pgfId-870273></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-305826">zeros 
    102</A> </LI></UL>
  <LI class=Level1IX><A name=pgfId-870275></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68202">MA 
  (masked arrays) 10</A> 
  <LI class=Level1IX><A name=pgfId-870277></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68556">mailing 
  list 6</A> 
  <LI class=Level1IX><A name=pgfId-870279></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-308206">masked 
  arrays 95</A> 
  <LI class=Level1IX><A name=pgfId-870281></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59797">Matrix 
  79</A> 
  <LI class=Level1IX><A name=pgfId-870283></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59646">matrixmultiply() 
  43</A> 
  <LI class=Level1IX><A name=pgfId-870285></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68202"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-308206">missing 
  values 10, 95</A></A> 
  <LI class=Level1IX><A name=pgfId-870288></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59537"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59540"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-66810"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59795">multiarray 
  10, 13, 56, 79</A></A></A></A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870293></A>N<A name=N></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870295></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59733">NaNs 
  62</A> 
  <LI class=Level1IX><A name=pgfId-870297></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59833"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59726">NewAxis 
  36, 58</A></A> 
  <LI class=Level1IX><A name=pgfId-870300></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59636">nonzero() 
  40</A> 
  <LI class=Level1IX><A name=pgfId-870302></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59536">Numeric.py 
  10</A> 
  <LI class=Level1IX><A name=pgfId-870304></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59530">NumTut 
  8</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870306></A>O<A name=O></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870308></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-308207">observations, 
  dealing with missing 95</A> 
  <LI class=Level1IX><A name=pgfId-870310></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-60119">ones() 
  18</A> 
  <LI class=Level1IX><A name=pgfId-870312></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-84312">outerproduct 
  45</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870314></A>P<A name=P></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870316></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68555">Patches 
  6</A> 
  <LI class=Level1IX><A name=pgfId-870318></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303110">permutation() 
  88</A> 
  <LI class=Level1IX><A name=pgfId-870320></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59730">Pickling 
  61</A> 
  <LI class=Level1IX><A name=pgfId-870322></A>printing 
  <UL>
    <LI class=Level2IX><A name=pgfId-870323></A><A class=Index 
    href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-307934">using 
    MA to limit printing of large arrays 103</A> </LI></UL>
  <LI class=Level1IX><A name=pgfId-870325></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59696">product() 
  47</A> 
  <LI class=Level1IX><A name=pgfId-870327></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59631">Pseudo 
  Indices 35</A> 
  <LI class=Level1IX><A name=pgfId-870329></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-78558">put() 
  38</A> 
  <LI class=Level1IX><A name=pgfId-870331></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59764">PyArray_As1D 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870333></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59765">PyArray_As2D 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870335></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59751">PyArray_CanCastSafely 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870337></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59750">PyArray_Cast 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870339></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59743">PyArray_Check 
  71</A> 
  <LI class=Level1IX><A name=pgfId-870341></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59757">PyArray_ContiguousFromObject 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870343></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59762">PyArray_Copy 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870345></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59758">PyArray_CopyFromObject 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870347></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59749">PyArray_DescrFromType 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870349></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59766">PyArray_Free 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870351></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59755">PyArray_FromDims 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870353></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59756">PyArray_FromDimsAndData 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870355></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59759">PyArray_FromObject 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870357></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59745">PyArray_INCREF 
  71</A> 
  <LI class=Level1IX><A name=pgfId-870359></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59752">PyArray_ObjectType 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870361></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59761">PyArray_Reshape 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870363></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59760">PyArray_Return 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870365></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59744">PyArray_SetNumericOps 
  71</A> 
  <LI class=Level1IX><A name=pgfId-870367></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59748">PyArray_SetStringFunction 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870369></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59754">PyArray_Size 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870371></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59763">PyArray_Take 
  73</A> 
  <LI class=Level1IX><A name=pgfId-870373></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59746">PyArray_XDECREF 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870375></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59747">PyArrayError 
  72</A> 
  <LI class=Level1IX><A name=pgfId-870377></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59739"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59742">PyArrayObject 
  64, 70</A></A> 
  <LI class=Level1IX><A name=pgfId-870380></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68559">Pyfort 
  7</A> 
  <LI class=Level1IX><A name=pgfId-870382></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59583">PyObject 
  15</A> 
  <LI class=Level1IX><A name=pgfId-870384></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59768">PyUFunc_Check 
  76</A> 
  <LI class=Level1IX><A name=pgfId-870386></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59769">PyUFunc_FromFuncAndData 
  76</A> 
  <LI class=Level1IX><A name=pgfId-870388></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59770">PyUFunc_GenericFunction 
  77</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870390></A>R<A name=Q></A><A 
name=R></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870393></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303107">randint() 
  88</A> 
  <LI class=Level1IX><A name=pgfId-870395></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303101">random() 
  88</A> 
  <LI class=Level1IX><A name=pgfId-870397></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303092">RandomArray 
  88</A> 
  <LI class=Level1IX><A name=pgfId-870399></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59542"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59798">rank 
  13, 79</A></A> 
  <LI class=Level1IX><A name=pgfId-870402></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59485">ravel 
  40</A> 
  <LI class=Level1IX><A name=pgfId-870404></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59713">real 
  (attribute) 51</A> 
  <LI class=Level1IX><A name=pgfId-870406></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-302972">real_fft() 
  83</A> 
  <LI class=Level1IX><A name=pgfId-870408></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59635"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59666">repeat() 
  39, 46</A></A> 
  <LI class=Level1IX><A name=pgfId-870411></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59584">reshape 
  16</A> 
  <LI class=Level1IX><A name=pgfId-870413></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59585">resize 
  18</A> 
  <LI class=Level1IX><A name=pgfId-870415></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59660">resize() 
  45</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870417></A>S<A name=S></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870419></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303095">seed() 
  88</A> 
  <LI class=Level1IX><A name=pgfId-870421></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59619">Setting 
  array values 25</A> 
  <LI class=Level1IX><A name=pgfId-870423></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59799">shape 
  79</A> 
  <LI class=Level1IX><A name=pgfId-870425></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303075">singular_value_decomposition() 
  87</A> 
  <LI class=Level1IX><A name=pgfId-870427></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59620">Slicing 
  Arrays 26</A> 
  <LI class=Level1IX><A name=pgfId-870429></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303018">solve_linear_equations() 
  86</A> 
  <LI class=Level1IX><A name=pgfId-870431></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59699">sometrue() 
  48</A> 
  <LI class=Level1IX><A name=pgfId-870433></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-66635">sort() 
  42</A> 
  <LI class=Level1IX><A name=pgfId-870435></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-68558">SourceForge 
  6</A> 
  <LI class=Level1IX><A name=pgfId-870437></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59694">sum() 
  47</A> 
  <LI class=Level1IX><A name=pgfId-870439></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59650">swapaxes() 
  44</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870441></A>T<A name=T></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870443></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59633">take() 
  37</A> 
  <LI class=Level1IX><A name=pgfId-870445></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59728">Textual 
  representations 59</A> 
  <LI class=Level1IX><A name=pgfId-870447></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59533">thread 
  9</A> 
  <LI class=Level1IX><A name=pgfId-870449></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59532">Tk 
  9</A> 
  <LI class=Level1IX><A name=pgfId-870451></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59709">tolist() 
  50</A> 
  <LI class=Level1IX><A name=pgfId-870453></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59708">tostring() 
  49</A> 
  <LI class=Level1IX><A name=pgfId-870455></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59640">trace() 
  41</A> 
  <LI class=Level1IX><A name=pgfId-870457></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59634">transpose() 
  39</A> 
  <LI class=Level1IX><A name=pgfId-870459></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59547"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59613"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59791">typecode 
  14, 23, 79</A></A></A> 
  <LI class=Level1IX><A name=pgfId-870463></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59706">typecode() 
  49</A> 
  <LI class=Level1IX><A name=pgfId-870465></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59717">Typecodes 
  56</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870467></A>U<A name=U></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870469></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59538"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59792">ufunc 
  10, 79</A></A> 
  <LI class=Level1IX><A name=pgfId-870472></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59630">Ufunc 
  shorthands 33</A> 
  <LI class=Level1IX><A name=pgfId-870474></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59767">UfuncObject 
  74</A> 
  <LI class=Level1IX><A name=pgfId-870476></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59738">ufuncobject.h 
  63</A> 
  <LI class=Level1IX><A name=pgfId-870478></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59621">Ufuncs 
  29</A> 
  <LI class=Level1IX><A name=pgfId-870480></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59625">Unary 
  Mathematical Ufuncs 32</A> 
  <LI class=Level1IX><A name=pgfId-870482></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-303104">uniform() 
  88</A> 
  <LI class=Level1IX><A name=pgfId-870484></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59793">universal 
  function 79</A> 
  <LI class=Level1IX><A name=pgfId-870486></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59539">universal 
  functions 10</A> 
  <LI class=Level1IX><A name=pgfId-870488></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59524">Unix 
  6</A> 
  <LI class=Level1IX><A name=pgfId-870490></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59731">Unpickling 
  61</A> 
  <LI class=Level1IX><A name=pgfId-870492></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59549">UnsignedInt8 
  14</A> 
  <LI class=Level1IX><A name=pgfId-870494></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59796">UserArray 
  79</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870496></A>V<A name=V></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870498></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59535">view 
  8</A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870500></A>W<A name=W></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870502></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59637"><A 
  class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-67906">where() 
  40, 47</A></A> </LI></UL></DIV>
<DIV>
<H6 class=GroupTitlesIX><A name=pgfId-870505></A>Z<A name=X></A><A name=Y></A><A 
name=Z></A></H6>
<UL>
  <LI class=Level1IX><A name=pgfId-870509></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-59741">Zero-dimensional 
  arrays 65</A> 
  <LI class=Level1IX><A name=pgfId-870511></A><A class=Index 
  href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm#marker-60118">zeros() 
  18</A> </LI></UL></DIV></DIV></DIV>
<HR>

<DIV class=footnotes>
<DIV class=footnote>
<P class=Footnote><SPAN class=footnoteNumber>1.</SPAN> <A 
name=pgfId-59080></A>This limit is modifiable in the source code if higher 
dimensionality is needed.</P></DIV>
<DIV class=footnote>
<P class=Footnote><SPAN class=footnoteNumber>2.</SPAN> <A 
name=pgfId-59294></A>The Python syntax can allow other Python datatypes to use 
both the stride notation and multidimensional indexing, and it is relatively 
simple to write Python classes which support these operations. See the Python 
Reference manual for details.</P></DIV></DIV></BODY></HTML>
